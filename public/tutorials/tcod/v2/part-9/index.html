<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Part 9 - Ranged Scrolls and Targeting" />
<meta property="og:description" content="Adding health potions was a big step, but we won&rsquo;t stop there. Let&rsquo;s continue adding a few items, this time with a focus on offense. We&rsquo;ll add a few scrolls, which will give the player a one-time ranged attack. This gives the player a lot more tactical options to work with, and is definitely something you&rsquo;ll want to expand upon in your own game.
Before we get to that, let&rsquo;s start by adding the colors we&rsquo;ll need for this chapter:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rogueliketutorials.com/tutorials/tcod/v2/part-9/" /><meta property="article:section" content="tutorials" />
<meta property="article:published_time" content="2020-07-14T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-07-14T00:00:00&#43;00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Part 9 - Ranged Scrolls and Targeting"/>
<meta name="twitter:description" content="Adding health potions was a big step, but we won&rsquo;t stop there. Let&rsquo;s continue adding a few items, this time with a focus on offense. We&rsquo;ll add a few scrolls, which will give the player a one-time ranged attack. This gives the player a lot more tactical options to work with, and is definitely something you&rsquo;ll want to expand upon in your own game.
Before we get to that, let&rsquo;s start by adding the colors we&rsquo;ll need for this chapter:"/>



    <link rel="canonical" href="https://rogueliketutorials.com/tutorials/tcod/v2/part-9/">

    <title>
      
        Part 9 - Ranged Scrolls and Targeting | Roguelike Tutorials
      
    </title>

    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="https://rogueliketutorials.com/css/style.css" rel="stylesheet">

    

    

    
  </head>
  <body>
    
      

<header class="blog-header">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <a class="navbar-brand" href="/">
            Roguelike Tutorials
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-between" id="navbarNav">
            <ul class="navbar-nav">
                
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/">Home</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutorials/tcod/2019/">TCOD Tutorial (2019)</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutorials/tcod/v2/">TCOD Tutorial (2020)</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/about/">About</a>
                    
                </li>
                
            </ul>
            
        </div>
    </nav>
</header>

    

    
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-8 blog-main">

          

<header>
    <h2 class="blog-post-title">
    <a class="text-dark" href="/tutorials/tcod/v2/part-9/">Part 9 - Ranged Scrolls and Targeting</a>
</h2>

    


<div class="blog-post-date text-secondary">
    
        <time datetime="2020-07-14">Jul 14, 2020</time>
    
    
</div>

    
    
    <hr>
</header>
<article class="blog-post">
    <p>Adding health potions was a big step, but we won&rsquo;t stop there. Let&rsquo;s continue adding a few items, this time with a focus on offense. We&rsquo;ll add a few scrolls, which will give the player a one-time ranged attack. This gives the player a lot more tactical options to work with, and is definitely something you&rsquo;ll want to expand upon in your own game.</p>
<p>Before we get to that, let&rsquo;s start by adding the colors we&rsquo;ll need for this chapter:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">white = (0xFF, 0xFF, 0xFF)
black = (0x0, 0x0, 0x0)
<span style="color:#a6e22e">+red = (0xFF, 0x0, 0x0)
</span><span style="color:#a6e22e"></span>
player_atk = (0xE0, 0xE0, 0xE0)
enemy_atk = (0xFF, 0xC0, 0xC0)
<span style="color:#a6e22e">+needs_target = (0x3F, 0xFF, 0xFF)
</span><span style="color:#a6e22e">+status_effect_applied = (0x3F, 0xFF, 0x3F)
</span><span style="color:#a6e22e"></span>
player_die = (0xFF, 0x30, 0x30)
enemy_die = (0xFF, 0xA0, 0x30)

invalid = (0xFF, 0xFF, 0x00)
impossible = (0x80, 0x80, 0x80)
error = (0xFF, 0x40, 0x40)

welcome_text = (0x20, 0xA0, 0xFF)
health_recovered = (0x0, 0xFF, 0x0)

bar_text = white
bar_filled = (0x0, 0x60, 0x0)
bar_empty = (0x40, 0x10, 0x10)
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>white = (0xFF, 0xFF, 0xFF)
black = (0x0, 0x0, 0x0)
<span class="new-text">red = (0xFF, 0x0, 0x0)</span>

player_atk = (0xE0, 0xE0, 0xE0)
enemy_atk = (0xFF, 0xC0, 0xC0)
<span class="new-text">needs_target = (0x3F, 0xFF, 0xFF)
status_effect_applied = (0x3F, 0xFF, 0x3F)</span>

player_die = (0xFF, 0x30, 0x30)
enemy_die = (0xFF, 0xA0, 0x30)

invalid = (0xFF, 0xFF, 0x00)
impossible = (0x80, 0x80, 0x80)
error = (0xFF, 0x40, 0x40)

welcome_text = (0x20, 0xA0, 0xFF)
health_recovered = (0x0, 0xFF, 0x0)

bar_text = white
bar_filled = (0x0, 0x60, 0x0)
bar_empty = (0x40, 0x10, 0x10)</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Let&rsquo;s start simple, with a spell that just hits the closest enemy. We&rsquo;ll create a scroll of lightning, which automatically targets an enemy nearby the player.</p>
<p>First thing we need is a way to get the closest entity to the entity casting the spell. Let&rsquo;s add a <code>distance</code> function to <code>Entity</code>, which will give us the distance to an arbitrary point. Open <code>entity.py</code> and add the following function:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from __future__ import annotations

import copy
<span style="color:#a6e22e">+import math
</span><span style="color:#a6e22e"></span>from typing import Optional, Tuple, Type, TypeVar, TYPE_CHECKING, Union
...

    ...
    def place(self, x: int, y: int, gamemap: Optional[GameMap] = None) -&gt; None:
        ...

<span style="color:#a6e22e">+   def distance(self, x: int, y: int) -&gt; float:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;
</span><span style="color:#a6e22e">+       Return the distance between the current entity and the given (x, y) coordinate.
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;
</span><span style="color:#a6e22e">+       return math.sqrt((x - self.x) ** 2 + (y - self.y) ** 2)
</span><span style="color:#a6e22e"></span>
    def move(self, dx: int, dy: int) -&gt; None:
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from __future__ import annotations

import copy
<span class="new-text">import math</span>
from typing import Optional, Tuple, Type, TypeVar, TYPE_CHECKING, Union
...

    ...
    def place(self, x: int, y: int, gamemap: Optional[GameMap] = None) -> None:
        ...

    <span class="new-text">def distance(self, x: int, y: int) -> float:
        """
        Return the distance between the current entity and the given (x, y) coordinate.
        """
        return math.sqrt((x - self.x) ** 2 + (y - self.y) ** 2)</span>

    def move(self, dx: int, dy: int) -> None:
        ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>With that, we can add the component that will handle shooting our lightning bolt. Add the following class to <code>consumable.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class HealingConsumable(Consumable):
    ...


<span style="color:#a6e22e">+class LightningDamageConsumable(Consumable):
</span><span style="color:#a6e22e">+   def __init__(self, damage: int, maximum_range: int):
</span><span style="color:#a6e22e">+       self.damage = damage
</span><span style="color:#a6e22e">+       self.maximum_range = maximum_range
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def activate(self, action: actions.ItemAction) -&gt; None:
</span><span style="color:#a6e22e">+       consumer = action.entity
</span><span style="color:#a6e22e">+       target = None
</span><span style="color:#a6e22e">+       closest_distance = self.maximum_range + 1.0
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       for actor in self.engine.game_map.actors:
</span><span style="color:#a6e22e">+           if actor is not consumer and self.parent.gamemap.visible[actor.x, actor.y]:
</span><span style="color:#a6e22e">+               distance = consumer.distance(actor.x, actor.y)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+               if distance &lt; closest_distance:
</span><span style="color:#a6e22e">+                   target = actor
</span><span style="color:#a6e22e">+                   closest_distance = distance
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       if target:
</span><span style="color:#a6e22e">+           self.engine.message_log.add_message(
</span><span style="color:#a6e22e">+               f&#34;A lighting bolt strikes the {target.name} with a loud thunder, for {self.damage} damage!&#34;
</span><span style="color:#a6e22e">+           )
</span><span style="color:#a6e22e">+           target.fighter.take_damage(self.damage)
</span><span style="color:#a6e22e">+           self.consume()
</span><span style="color:#a6e22e">+       else:
</span><span style="color:#a6e22e">+           raise Impossible(&#34;No enemy is close enough to strike.&#34;)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class HealingConsumable(Consumable):
    ...


<span class="new-text">class LightningDamageConsumable(Consumable):
    def __init__(self, damage: int, maximum_range: int):
        self.damage = damage
        self.maximum_range = maximum_range

    def activate(self, action: actions.ItemAction) -> None:
        consumer = action.entity
        target = None
        closest_distance = self.maximum_range + 1.0

        for actor in self.engine.game_map.actors:
            if actor is not consumer and self.parent.gamemap.visible[actor.x, actor.y]:
                distance = consumer.distance(actor.x, actor.y)

                if distance < closest_distance:
                    target = actor
                    closest_distance = distance

        if target:
            self.engine.message_log.add_message(
                f"A lighting bolt strikes the {target.name} with a loud thunder, for {self.damage} damage!"
            )
            target.fighter.take_damage(self.damage)
            self.consume()
        else:
            raise Impossible("No enemy is close enough to strike.")</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>The <code>__init__</code> function takes two arguments: <code>damage</code>, which dictates how powerful the lightning bolt will be, and <code>maximum_range</code>, which tells us how far it can reach.</p>
<p>Similar to <code>HealingConsumable</code>, this class has an <code>activate</code> function that describes what to do when the player tries using it. It loops through the actors in the current map, and if the actor is visible and within range, it chooses that actor as the one to strike. If a target was found, we strike the target, dealing the damage (using the <code>take_damage</code> function we defined last time, which ignores defense) and printing out a message. If no target was found, we give an error, and don&rsquo;t consume the scroll.</p>
<p>In order to use this, we&rsquo;ll need to actually place some lightning scrolls on the map. We can do that by adding the scroll to <code>entity_factories.py</code>, and then adjusting the <code>place_entities</code> function in <code>procgen.py</code>. Let&rsquo;s start with <code>entity_factories.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from components.ai import HostileEnemy
<span style="color:#f92672">-from components.consumable import HealingConsumable
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from components import consumable
</span><span style="color:#a6e22e"></span>from components.fighter import Fighter
from components.inventory import Inventory
from entity import Actor, Item

...
health_potion = Item(
    char=&#34;!&#34;,
    color=(127, 0, 255),
    name=&#34;Health Potion&#34;,
<span style="color:#f92672">-   consumable=HealingConsumable(amount=4),
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   consumable=consumable.HealingConsumable(amount=4),
</span><span style="color:#a6e22e"></span>)
<span style="color:#a6e22e">+lightning_scroll = Item(
</span><span style="color:#a6e22e">+   char=&#34;~&#34;,
</span><span style="color:#a6e22e">+   color=(255, 255, 0),
</span><span style="color:#a6e22e">+   name=&#34;Lightning Scroll&#34;,
</span><span style="color:#a6e22e">+   consumable=consumable.LightningDamageConsumable(damage=20, maximum_range=5),
</span><span style="color:#a6e22e">+)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from components.ai import HostileEnemy
<span class="crossed-out-text">from components.consumable import HealingConsumable</span>
<span class="new-text">from components import consumable</span>
from components.fighter import Fighter
from components.inventory import Inventory
from entity import Actor, Item

...
health_potion = Item(
    char="!",
    color=(127, 0, 255),
    name="Health Potion",
    <span class="crossed-out-text">consumable=HealingConsumable(amount=4),</span>
    <span class="new-text">consumable=consumable.HealingConsumable(amount=4),</span>
)
<span class="new-text">lightning_scroll = Item(
    char="~",
    color=(255, 255, 0),
    name="Lightning Scroll",
    consumable=consumable.LightningDamageConsumable(damage=20, maximum_range=5),
)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Notice that we also are importing <code>consumable</code> instead of the specific classes inside, which affects our declaration of <code>health_potion</code>. This will save us from having to add a new import every time we create a new consumable class.</p>
<p>Now, for <code>procgen.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...
    for i in range(number_of_items):
        x = random.randint(room.x1 + 1, room.x2 - 1)
        y = random.randint(room.y1 + 1, room.y2 - 1)

        if not any(entity.x == x and entity.y == y for entity in dungeon.entities):
<span style="color:#f92672">-           entity_factories.health_potion.spawn(dungeon, x, y)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           item_chance = random.random()
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+           if item_chance &lt; 0.7:
</span><span style="color:#a6e22e">+               entity_factories.health_potion.spawn(dungeon, x, y)
</span><span style="color:#a6e22e">+           else:
</span><span style="color:#a6e22e">+               entity_factories.lightning_scroll.spawn(dungeon, x, y)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    ...
    for i in range(number_of_items):
        x = random.randint(room.x1 + 1, room.x2 - 1)
        y = random.randint(room.y1 + 1, room.y2 - 1)

        if not any(entity.x == x and entity.y == y for entity in dungeon.entities):
            <span class="crossed-out-text">entity_factories.health_potion.spawn(dungeon, x, y)</span>
            <span class="new-text">item_chance = random.random()

            if item_chance < 0.7:
                entity_factories.health_potion.spawn(dungeon, x, y)
            else:
                entity_factories.lightning_scroll.spawn(dungeon, x, y)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Like with the monsters, we&rsquo;re getting a random number and deciding what to spawn based on a percentage chance. Most of our items will still be health potions, but we should have a chance of getting a lightning scroll instead now.</p>
<p>Run the project, and try picking up some lightning scrolls and zapping some trolls!</p>
<p><img src="/images/part-9-lightning-scrolls.png" alt="Part 9 - Lightning Scrolls"></p>
<p>That one was a bit on the easy side. Let&rsquo;s try something a little more challenging, something that requires us to target an enemy (or an area) before shooting off the spell.</p>
<p>This will take a few steps, but one of the things we can do on the way to that goal is add a way for the player to &ldquo;look around&rdquo; the map using either the mouse or keyboard. We already kind of did this with the mouse in part 7, however, most roguelikes allow the user to play the game entirely with the keyboard.</p>
<p>Open up <code>input_handlers.py</code> and add the following contents:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
WAIT_KEYS = {
    tcod.event.K_PERIOD,
    tcod.event.K_KP_5,
    tcod.event.K_CLEAR,
}

<span style="color:#a6e22e">+CONFIRM_KEYS = {
</span><span style="color:#a6e22e">+   tcod.event.K_RETURN,
</span><span style="color:#a6e22e">+   tcod.event.K_KP_ENTER,
</span><span style="color:#a6e22e">+}
</span><span style="color:#a6e22e"></span>
...
class InventoryDropHandler(InventoryEventHandler):
    ...


<span style="color:#a6e22e">+class SelectIndexHandler(AskUserEventHandler):
</span><span style="color:#a6e22e">+   &#34;&#34;&#34;Handles asking the user for an index on the map.&#34;&#34;&#34;
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def __init__(self, engine: Engine):
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Sets the cursor to the player when this handler is constructed.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       super().__init__(engine)
</span><span style="color:#a6e22e">+       player = self.engine.player
</span><span style="color:#a6e22e">+       engine.mouse_location = player.x, player.y
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def on_render(self, console: tcod.Console) -&gt; None:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Highlight the tile under the cursor.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       super().on_render(console)
</span><span style="color:#a6e22e">+       x, y = self.engine.mouse_location
</span><span style="color:#a6e22e">+       console.tiles_rgb[&#34;bg&#34;][x, y] = color.white
</span><span style="color:#a6e22e">+       console.tiles_rgb[&#34;fg&#34;][x, y] = color.black
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def ev_keydown(self, event: tcod.event.KeyDown) -&gt; Optional[Action]:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Check for key movement or confirmation keys.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       key = event.sym
</span><span style="color:#a6e22e">+       if key in MOVE_KEYS:
</span><span style="color:#a6e22e">+           modifier = 1  # Holding modifier keys will speed up key movement.
</span><span style="color:#a6e22e">+           if event.mod &amp; (tcod.event.KMOD_LSHIFT | tcod.event.KMOD_RSHIFT):
</span><span style="color:#a6e22e">+               modifier *= 5
</span><span style="color:#a6e22e">+           if event.mod &amp; (tcod.event.KMOD_LCTRL | tcod.event.KMOD_RCTRL):
</span><span style="color:#a6e22e">+               modifier *= 10
</span><span style="color:#a6e22e">+           if event.mod &amp; (tcod.event.KMOD_LALT | tcod.event.KMOD_RALT):
</span><span style="color:#a6e22e">+               modifier *= 20
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+           x, y = self.engine.mouse_location
</span><span style="color:#a6e22e">+           dx, dy = MOVE_KEYS[key]
</span><span style="color:#a6e22e">+           x += dx * modifier
</span><span style="color:#a6e22e">+           y += dy * modifier
</span><span style="color:#a6e22e">+           # Clamp the cursor index to the map size.
</span><span style="color:#a6e22e">+           x = max(0, min(x, self.engine.game_map.width - 1))
</span><span style="color:#a6e22e">+           y = max(0, min(y, self.engine.game_map.height - 1))
</span><span style="color:#a6e22e">+           self.engine.mouse_location = x, y
</span><span style="color:#a6e22e">+           return None
</span><span style="color:#a6e22e">+       elif key in CONFIRM_KEYS:
</span><span style="color:#a6e22e">+           return self.on_index_selected(*self.engine.mouse_location)
</span><span style="color:#a6e22e">+       return super().ev_keydown(event)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def ev_mousebuttondown(self, event: tcod.event.MouseButtonDown) -&gt; Optional[Action]:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Left click confirms a selection.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       if self.engine.game_map.in_bounds(*event.tile):
</span><span style="color:#a6e22e">+           if event.button == 1:
</span><span style="color:#a6e22e">+               return self.on_index_selected(*event.tile)
</span><span style="color:#a6e22e">+       return super().ev_mousebuttondown(event)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def on_index_selected(self, x: int, y: int) -&gt; Optional[Action]:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Called when an index is selected.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       raise NotImplementedError()
</span><span style="color:#a6e22e"></span>

<span style="color:#a6e22e">+class LookHandler(SelectIndexHandler):
</span><span style="color:#a6e22e">+   &#34;&#34;&#34;Lets the player look around using the keyboard.&#34;&#34;&#34;
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def on_index_selected(self, x: int, y: int) -&gt; None:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Return to main handler.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       self.engine.event_handler = MainGameEventHandler(self.engine)
</span><span style="color:#a6e22e"></span>

class MainGameEventHandler(EventHandler):
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
WAIT_KEYS = {
    tcod.event.K_PERIOD,
    tcod.event.K_KP_5,
    tcod.event.K_CLEAR,
}

<span class="new-text">CONFIRM_KEYS = {
    tcod.event.K_RETURN,
    tcod.event.K_KP_ENTER,
}</span>

...
class InventoryDropHandler(InventoryEventHandler):
    ...


<span class="new-text">class SelectIndexHandler(AskUserEventHandler):
    """Handles asking the user for an index on the map."""

    def __init__(self, engine: Engine):
        """Sets the cursor to the player when this handler is constructed."""
        super().__init__(engine)
        player = self.engine.player
        engine.mouse_location = player.x, player.y

    def on_render(self, console: tcod.Console) -> None:
        """Highlight the tile under the cursor."""
        super().on_render(console)
        x, y = self.engine.mouse_location
        console.tiles_rgb["bg"][x, y] = color.white
        console.tiles_rgb["fg"][x, y] = color.black

    def ev_keydown(self, event: tcod.event.KeyDown) -> Optional[Action]:
        """Check for key movement or confirmation keys."""
        key = event.sym
        if key in MOVE_KEYS:
            modifier = 1  # Holding modifier keys will speed up key movement.
            if event.mod & (tcod.event.KMOD_LSHIFT | tcod.event.KMOD_RSHIFT):
                modifier *= 5
            if event.mod & (tcod.event.KMOD_LCTRL | tcod.event.KMOD_RCTRL):
                modifier *= 10
            if event.mod & (tcod.event.KMOD_LALT | tcod.event.KMOD_RALT):
                modifier *= 20

            x, y = self.engine.mouse_location
            dx, dy = MOVE_KEYS[key]
            x += dx * modifier
            y += dy * modifier
            # Clamp the cursor index to the map size.
            x = max(0, min(x, self.engine.game_map.width - 1))
            y = max(0, min(y, self.engine.game_map.height - 1))
            self.engine.mouse_location = x, y
            return None
        elif key in CONFIRM_KEYS:
            return self.on_index_selected(*self.engine.mouse_location)
        return super().ev_keydown(event)

    def ev_mousebuttondown(self, event: tcod.event.MouseButtonDown) -> Optional[Action]:
        """Left click confirms a selection."""
        if self.engine.game_map.in_bounds(*event.tile):
            if event.button == 1:
                return self.on_index_selected(*event.tile)
        return super().ev_mousebuttondown(event)

    def on_index_selected(self, x: int, y: int) -> Optional[Action]:
        """Called when an index is selected."""
        raise NotImplementedError()


class LookHandler(SelectIndexHandler):
    """Lets the player look around using the keyboard."""

    def on_index_selected(self, x: int, y: int) -> None:
        """Return to main handler."""
        self.engine.event_handler = MainGameEventHandler(self.engine)</span>


class MainGameEventHandler(EventHandler):
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p><code>SelectIndexHandler</code> is what we&rsquo;ll use when we want to select a tile on the map. It has several methods, which we&rsquo;ll break down now.</p>
<p><code>__init__</code> simply sets the <code>mouse_location</code> to the player&rsquo;s current location. This is so that the cursor we&rsquo;re about to draw appears over the player first, rather than somewhere else. Chances are, the tile the player wants to select will be nearby.</p>
<p><code>on_render</code> will render the console as normal, by calling <code>super().on_render</code>, but it also adds a cursor on top, that can be used to show where the current cursor position is. This is especially useful if the player is navigating around with the keyboard.</p>
<p><code>ev_keydown</code> gives us a way to move the cursor we&rsquo;re drawing around using the keyboard instead of the mouse (using the mouse is still possible). By using the same movement keys we use to move the player around, we can move the cursor around, with a few extra options. By holding, shift, control, or alt while pressing a movement key, the cursor will move around faster by skipping over a few spaces. This could be very helpful if you plan on making your map larger. If the user presses a &ldquo;confirm&rdquo; key, the method returns the current cursor&rsquo;s location.</p>
<p><code>ev_mousebuttondown</code> also returns the location, if the clicked space is within the map boundaries.</p>
<p><code>on_index_selected</code> is an abstract method, which will be up to the subclasses to implement. We do that immediately with <code>LookHandler</code>.</p>
<p><code>LookHandler</code> inherits from <code>SelectIndexHandler</code>, and all it does is return to the <code>MainGameEventHandler</code> when receiving a confirmation key. This is because it doesn&rsquo;t need to do anything special, it&rsquo;s just used in the case where our player wants to have a look around.</p>
<p>We can utilize <code>LookHandler</code> by adding this to <code>ev_keydown</code> in <code>MainGameEventHandler</code>:
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
        elif key == tcod.event.K_i:
            self.engine.event_handler = InventoryActivateHandler(self.engine)
        elif key == tcod.event.K_d:
            self.engine.event_handler = InventoryDropHandler(self.engine)
<span style="color:#a6e22e">+       elif key == tcod.event.K_SLASH:
</span><span style="color:#a6e22e">+           self.engine.event_handler = LookHandler(self.engine)
</span><span style="color:#a6e22e"></span>
        # No valid key was pressed
        return action
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        ...
        elif key == tcod.event.K_i:
            self.engine.event_handler = InventoryActivateHandler(self.engine)
        elif key == tcod.event.K_d:
            self.engine.event_handler = InventoryDropHandler(self.engine)
        <span class="new-text">elif key == tcod.event.K_SLASH:
            self.engine.event_handler = LookHandler(self.engine)</span>

        # No valid key was pressed
        return action</pre>

</div>

</div>

<script src="/js/codetabs.js"></script></p>
<p>By pressing the forward slash key, you can look around the map with either the mouse or keyboard. Pressing the Escape key (or any non-movement key for that matter) exits this mode.</p>
<p>Alright, with that in place, we can move on to implementing a scroll that asks for a target. Let&rsquo;s implement a confusion scroll, which will take a target, and change that target&rsquo;s AI so that it stumbles around for a few turns before returning to normal.</p>
<p>We need to define a new type of AI to handle how enemies act when they&rsquo;re confused. Open up <code>ai.py</code> and add the following:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from __future__ import annotations

<span style="color:#a6e22e">+import random
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-from typing import List, Tuple, TYPE_CHECKING
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from typing import List, Optional, Tuple, TYPE_CHECKING
</span><span style="color:#a6e22e"></span>
import numpy as np  # type: ignore
import tcod

<span style="color:#f92672">-from actions import Action, MeleeAction, MovementAction, WaitAction
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from actions import Action, BumpAction, MeleeAction, MovementAction, WaitAction
</span><span style="color:#a6e22e"></span>
if TYPE_CHECKING:
    from entity import Actor


class BaseAI(Action):
    ...


<span style="color:#a6e22e">+class ConfusedEnemy(BaseAI):
</span><span style="color:#a6e22e">+   &#34;&#34;&#34;
</span><span style="color:#a6e22e">+   A confused enemy will stumble around aimlessly for a given number of turns, then revert back to its previous AI.
</span><span style="color:#a6e22e">+   If an actor occupies a tile it is randomly moving into, it will attack.
</span><span style="color:#a6e22e">+   &#34;&#34;&#34;
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def __init__(
</span><span style="color:#a6e22e">+       self, entity: Actor, previous_ai: Optional[BaseAI], turns_remaining: int
</span><span style="color:#a6e22e">+   ):
</span><span style="color:#a6e22e">+       super().__init__(entity)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       self.previous_ai = previous_ai
</span><span style="color:#a6e22e">+       self.turns_remaining = turns_remaining
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def perform(self) -&gt; None:
</span><span style="color:#a6e22e">+       # Revert the AI back to the original state if the effect has run its course.
</span><span style="color:#a6e22e">+       if self.turns_remaining &lt;= 0:
</span><span style="color:#a6e22e">+           self.engine.message_log.add_message(
</span><span style="color:#a6e22e">+               f&#34;The {self.entity.name} is no longer confused.&#34;
</span><span style="color:#a6e22e">+           )
</span><span style="color:#a6e22e">+           self.entity.ai = self.previous_ai
</span><span style="color:#a6e22e">+       else:
</span><span style="color:#a6e22e">+           # Pick a random direction
</span><span style="color:#a6e22e">+           direction_x, direction_y = random.choice(
</span><span style="color:#a6e22e">+               [
</span><span style="color:#a6e22e">+                   (-1, -1),  # Northwest
</span><span style="color:#a6e22e">+                   (0, -1),  # North
</span><span style="color:#a6e22e">+                   (1, -1),  # Northeast
</span><span style="color:#a6e22e">+                   (-1, 0),  # West
</span><span style="color:#a6e22e">+                   (1, 0),  # East
</span><span style="color:#a6e22e">+                   (-1, 1),  # Southwest
</span><span style="color:#a6e22e">+                   (0, 1),  # South
</span><span style="color:#a6e22e">+                   (1, 1),  # Southeast
</span><span style="color:#a6e22e">+               ]
</span><span style="color:#a6e22e">+           )
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+           self.turns_remaining -= 1
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+           # The actor will either try to move or attack in the chosen random direction.
</span><span style="color:#a6e22e">+           # Its possible the actor will just bump into the wall, wasting a turn.
</span><span style="color:#a6e22e">+           return BumpAction(self.entity, direction_x, direction_y,).perform()
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from __future__ import annotations

<span class="new-text">import random</span>
<span class="crossed-out-text">from typing import List, Tuple, TYPE_CHECKING</span>
<span class="new-text">from typing import List, Optional, Tuple, TYPE_CHECKING</span>

import numpy as np  # type: ignore
import tcod

<span class="crossed-out-text">from actions import Action, MeleeAction, MovementAction, WaitAction</span>
<span class="new-text">from actions import Action, BumpAction, MeleeAction, MovementAction, WaitAction</span>

if TYPE_CHECKING:
    from entity import Actor


class BaseAI(Action):
    ...


<span class="new-text">class ConfusedEnemy(BaseAI):
    """
    A confused enemy will stumble around aimlessly for a given number of turns, then revert back to its previous AI.
    If an actor occupies a tile it is randomly moving into, it will attack.
    """

    def __init__(
        self, entity: Actor, previous_ai: Optional[BaseAI], turns_remaining: int
    ):
        super().__init__(entity)

        self.previous_ai = previous_ai
        self.turns_remaining = turns_remaining

    def perform(self) -> None:
        # Revert the AI back to the original state if the effect has run its course.
        if self.turns_remaining <= 0:
            self.engine.message_log.add_message(
                f"The {self.entity.name} is no longer confused."
            )
            self.entity.ai = self.previous_ai
        else:
            # Pick a random direction
            direction_x, direction_y = random.choice(
                [
                    (-1, -1),  # Northwest
                    (0, -1),  # North
                    (1, -1),  # Northeast
                    (-1, 0),  # West
                    (1, 0),  # East
                    (-1, 1),  # Southwest
                    (0, 1),  # South
                    (1, 1),  # Southeast
                ]
            )

            self.turns_remaining -= 1

            # The actor will either try to move or attack in the chosen random direction.
            # Its possible the actor will just bump into the wall, wasting a turn.
            return BumpAction(self.entity, direction_x, direction_y,).perform()</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>The <code>__init__</code> function takes three arguments:</p>
<ul>
<li><code>entity</code>: The actor who is being confused.</li>
<li><code>previous_ai</code>: The AI class that the actor currently has. We need this, because when the confusion effect wears off, we&rsquo;ll want to revert the entity back to its previous AI.</li>
<li><code>turns_remaining</code>: How many turns the confusion effect will last for.</li>
</ul>
<p><code>perform</code> causes the entity to move in a randomly selected direction. It uses <code>BumpAction</code>, which means that it will try to move into a tile, and if there&rsquo;s an actor there, it will attack it (regardless if its the player or another monster). Each turn, the <code>turns_remaining</code> will decrement, and when it&rsquo;s less than or equal to zero, the AI reverts back and the entity is no longer confused.</p>
<p>In order to inflict this status on an enemy, we&rsquo;ll need to do a few things. Obviously, we need a consumable that inflicts the <code>ConfusedEnemy</code> AI on an enemy, but we also need a way to select which enemy gets confused.</p>
<p>To do that, let&rsquo;s expand on our <code>SelectIndexHandler</code> from earlier. We can create a handler that allows us to select a single enemy and apply some sort of function on it. Open up <code>input_handlers.py</code> and add the following class:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from __future__ import annotations

<span style="color:#f92672">-from typing import Optional, TYPE_CHECKING
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from typing import Callable, Optional, Tuple, TYPE_CHECKING
</span><span style="color:#a6e22e"></span>
import tcod
...


class LookHandler(SelectIndexHandler):
    ...


<span style="color:#a6e22e">+class SingleRangedAttackHandler(SelectIndexHandler):
</span><span style="color:#a6e22e">+   &#34;&#34;&#34;Handles targeting a single enemy. Only the enemy selected will be affected.&#34;&#34;&#34;
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def __init__(
</span><span style="color:#a6e22e">+       self, engine: Engine, callback: Callable[[Tuple[int, int]], Optional[Action]]
</span><span style="color:#a6e22e">+   ):
</span><span style="color:#a6e22e">+       super().__init__(engine)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       self.callback = callback
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def on_index_selected(self, x: int, y: int) -&gt; Optional[Action]:
</span><span style="color:#a6e22e">+       return self.callback((x, y))
</span><span style="color:#a6e22e"></span>

class MainGameEventHandler(EventHandler):
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from __future__ import annotations

<span class="crossed-out-text">from typing import Optional, TYPE_CHECKING</span>
<span class="new-text">from typing import Callable, Optional, Tuple, TYPE_CHECKING</span>

import tcod
...


class LookHandler(SelectIndexHandler):
    ...


<span class="new-text">class SingleRangedAttackHandler(SelectIndexHandler):
    """Handles targeting a single enemy. Only the enemy selected will be affected."""

    def __init__(
        self, engine: Engine, callback: Callable[[Tuple[int, int]], Optional[Action]]
    ):
        super().__init__(engine)

        self.callback = callback

    def on_index_selected(self, x: int, y: int) -> Optional[Action]:
        return self.callback((x, y))</span>


class MainGameEventHandler(EventHandler):
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p><code>SingleRangedAttackHandler</code> doesn&rsquo;t do much, except define a <code>callback</code> function that activates when the user selects a target. <code>callback</code> can be any function with a Tuple of two integers (x and y coordinates), so <code>SingleRangedAttackHandler</code> can be used for any scroll or ranged attack that targets one location.</p>
<p>So what do we pass as the <code>callback</code>? Let&rsquo;s define that now, in <code>consumable.py</code>. We&rsquo;ll add the component that causes the confusion effect, called <code>ConfusionConsumable</code>. It looks like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
import color
<span style="color:#a6e22e">+import components.ai
</span><span style="color:#a6e22e"></span>from components.base_component import BaseComponent
from exceptions import Impossible
<span style="color:#a6e22e">+from input_handlers import SingleRangedAttackHandler
</span><span style="color:#a6e22e"></span>
if TYPE_CHECKING:
    from entity import Actor, Item


class Consumable(BaseComponent):
    parent: Item

    def consume(self, consumer: Actor) -&gt; None:
        raise NotImplementedError()


<span style="color:#a6e22e">+class ConfusionConsumable(Consumable):
</span><span style="color:#a6e22e">+   def __init__(self, number_of_turns: int):
</span><span style="color:#a6e22e">+       self.number_of_turns = number_of_turns
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def get_action(self, consumer: Actor) -&gt; Optional[actions.Action]:
</span><span style="color:#a6e22e">+       self.engine.message_log.add_message(
</span><span style="color:#a6e22e">+           &#34;Select a target location.&#34;, color.needs_target
</span><span style="color:#a6e22e">+       )
</span><span style="color:#a6e22e">+       self.engine.event_handler = SingleRangedAttackHandler(
</span><span style="color:#a6e22e">+           self.engine,
</span><span style="color:#a6e22e">+           callback=lambda xy: actions.ItemAction(consumer, self.parent, xy),
</span><span style="color:#a6e22e">+       )
</span><span style="color:#a6e22e">+       return None
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def activate(self, action: actions.ItemAction) -&gt; None:
</span><span style="color:#a6e22e">+       consumer = action.entity
</span><span style="color:#a6e22e">+       target = action.target_actor
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       if not self.engine.game_map.visible[action.target_xy]:
</span><span style="color:#a6e22e">+           raise Impossible(&#34;You cannot target an area that you cannot see.&#34;)
</span><span style="color:#a6e22e">+       if not target:
</span><span style="color:#a6e22e">+           raise Impossible(&#34;You must select an enemy to target.&#34;)
</span><span style="color:#a6e22e">+       if target is consumer:
</span><span style="color:#a6e22e">+           raise Impossible(&#34;You cannot confuse yourself!&#34;)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       self.engine.message_log.add_message(
</span><span style="color:#a6e22e">+           f&#34;The eyes of the {target.name} look vacant, as it starts to stumble around!&#34;,
</span><span style="color:#a6e22e">+           color.status_effect_applied,
</span><span style="color:#a6e22e">+       )
</span><span style="color:#a6e22e">+       target.ai = components.ai.ConfusedEnemy(
</span><span style="color:#a6e22e">+           entity=target, previous_ai=target.ai, turns_remaining=self.number_of_turns,
</span><span style="color:#a6e22e">+       )
</span><span style="color:#a6e22e">+       self.consume()
</span><span style="color:#a6e22e"></span>

class HealingConsumable(Consumable):
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
import color
<span class="new-text">import components.ai</span>
from components.base_component import BaseComponent
from exceptions import Impossible
<span class="new-text">from input_handlers import SingleRangedAttackHandler</span>

if TYPE_CHECKING:
    from entity import Actor, Item


class Consumable(BaseComponent):
    parent: Item

    def consume(self, consumer: Actor) -> None:
        raise NotImplementedError()


<span class="new-text">class ConfusionConsumable(Consumable):
    def __init__(self, number_of_turns: int):
        self.number_of_turns = number_of_turns

    def get_action(self, consumer: Actor) -> Optional[actions.Action]:
        self.engine.message_log.add_message(
            "Select a target location.", color.needs_target
        )
        self.engine.event_handler = SingleRangedAttackHandler(
            self.engine,
            callback=lambda xy: actions.ItemAction(consumer, self.parent, xy),
        )
        return None

    def activate(self, action: actions.ItemAction) -> None:
        consumer = action.entity
        target = action.target_actor

        if not self.engine.game_map.visible[action.target_xy]:
            raise Impossible("You cannot target an area that you cannot see.")
        if not target:
            raise Impossible("You must select an enemy to target.")
        if target is consumer:
            raise Impossible("You cannot confuse yourself!")

        self.engine.message_log.add_message(
            f"The eyes of the {target.name} look vacant, as it starts to stumble around!",
            color.status_effect_applied,
        )
        target.ai = components.ai.ConfusedEnemy(
            entity=target, previous_ai=target.ai, turns_remaining=self.number_of_turns,
        )
        self.consume()</span>


class HealingConsumable(Consumable):
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p><code>ConfusionConsumable</code> takes one argument in <code>__init__</code>, which is <code>number_of_turns</code>. As you might have guessed, this represents the number of turns that the confusion effect lasts for.</p>
<p><code>get_action</code> will ask the player to select a target location, and switch the game&rsquo;s event handler to <code>SingleRangedAttackHandler</code>. The <code>callback</code> is a <code>lambda</code> function (an anonymous, inline function), which takes &ldquo;xy&rdquo; as a parameter. &ldquo;xy&rdquo; will be the coordinates of the target. The lambda function executes <code>ItemAction</code>, which receives the consumer, the parent (the item), and the &ldquo;xy&rdquo; coordinates.</p>
<p><code>activate</code> is what happens when the player selects a target. First, we get the actor at the location, and make sure that the target is,</p>
<ol>
<li>In sight</li>
<li>A valid actor</li>
<li>Not the player</li>
</ol>
<p>If all those things are true, then we apply the <code>ConfusedEnemy</code> AI to that target, and consume the scroll.</p>
<p>With the consumable component in place, we can add <code>confusion_scroll</code> to <code>entity_factories.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">troll = Actor(
    ...
)

<span style="color:#a6e22e">+confusion_scroll = Item(
</span><span style="color:#a6e22e">+   char=&#34;~&#34;,
</span><span style="color:#a6e22e">+   color=(207, 63, 255),
</span><span style="color:#a6e22e">+   name=&#34;Confusion Scroll&#34;,
</span><span style="color:#a6e22e">+   consumable=consumable.ConfusionConsumable(number_of_turns=10),
</span><span style="color:#a6e22e">+)
</span><span style="color:#a6e22e"></span>health_potion = Item(
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>troll = Actor(
    ...
)

<span class="new-text">confusion_scroll = Item(
    char="~",
    color=(207, 63, 255),
    name="Confusion Scroll",
    consumable=consumable.ConfusionConsumable(number_of_turns=10),
)</span>
health_potion = Item(
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now that we can create confusion scrolls, let&rsquo;s add some to the map. Open up <code>procgen.py</code> and adjust the part that places items to look like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            if item_chance &lt; 0.7:
                entity_factories.health_potion.spawn(dungeon, x, y)
<span style="color:#a6e22e">+           elif item_chance &lt; 0.9:
</span><span style="color:#a6e22e">+               entity_factories.confusion_scroll.spawn(dungeon, x, y)
</span><span style="color:#a6e22e"></span>            else:
                entity_factories.lightning_scroll.spawn(dungeon, x, y)
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            if item_chance < 0.7:
                entity_factories.health_potion.spawn(dungeon, x, y)
            <span class="new-text">elif item_chance < 0.9:
                entity_factories.confusion_scroll.spawn(dungeon, x, y)</span>
            else:
                entity_factories.lightning_scroll.spawn(dungeon, x, y)</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Feel free to adjust these percentage values however you see fit. To test out your confusion scrolls, you might want to mess with the numbers here.</p>
<p>Run the project now, and cast some confusion on your enemies!</p>
<p><img src="/images/part-9-confusion-scrolls.png" alt="Part 9 - Confusion Scrolls"></p>
<p>So we currently have two types of ranged spells to use: One that targets the nearest enemy automatically, and one that asks for a target. We&rsquo;ll finish this chapter by implementing a third type: One that asks for a target, but affects everything within a certain radius of that target. I&rsquo;m talking, of course, about an exploding fireball spell!</p>
<p>To implement our fireball, we&rsquo;ll need a new event handler. <code>SingleRangedAttackHandler</code> isn&rsquo;t quite enough, because it targets one enemy actor and nothing else. For our fireball, we want to select an <em>area</em> to hit which can include multiple targets, and might even burn the player! It&rsquo;s not actually necessary that the cursor be on an enemy either; the fireball can be offset to catch multiple enemies in its blast radius.</p>
<p>So, with that in mind, let&rsquo;s implement a new event handler, which will handle area of effect attacks. We can call it <code>AreaRangedAttackHandler</code>, and define it like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class SingleRangedAttackHandler(SelectIndexHandler):
    ...


<span style="color:#a6e22e">+class AreaRangedAttackHandler(SelectIndexHandler):
</span><span style="color:#a6e22e">+   &#34;&#34;&#34;Handles targeting an area within a given radius. Any entity within the area will be affected.&#34;&#34;&#34;
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def __init__(
</span><span style="color:#a6e22e">+       self,
</span><span style="color:#a6e22e">+       engine: Engine,
</span><span style="color:#a6e22e">+       radius: int,
</span><span style="color:#a6e22e">+       callback: Callable[[Tuple[int, int]], Optional[Action]],
</span><span style="color:#a6e22e">+   ):
</span><span style="color:#a6e22e">+       super().__init__(engine)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       self.radius = radius
</span><span style="color:#a6e22e">+       self.callback = callback
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def on_render(self, console: tcod.Console) -&gt; None:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Highlight the tile under the cursor.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       super().on_render(console)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       x, y = self.engine.mouse_location
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       # Draw a rectangle around the targeted area, so the player can see the affected tiles.
</span><span style="color:#a6e22e">+       console.draw_frame(
</span><span style="color:#a6e22e">+           x=x - self.radius - 1,
</span><span style="color:#a6e22e">+           y=y - self.radius - 1,
</span><span style="color:#a6e22e">+           width=self.radius ** 2,
</span><span style="color:#a6e22e">+           height=self.radius ** 2,
</span><span style="color:#a6e22e">+           fg=color.red,
</span><span style="color:#a6e22e">+           clear=False,
</span><span style="color:#a6e22e">+       )
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def on_index_selected(self, x: int, y: int) -&gt; Optional[Action]:
</span><span style="color:#a6e22e">+       return self.callback((x, y))
</span><span style="color:#a6e22e"></span>

class MainGameEventHandler(EventHandler):
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class SingleRangedAttackHandler(SelectIndexHandler):
    ...


<span class="new-text">class AreaRangedAttackHandler(SelectIndexHandler):
    """Handles targeting an area within a given radius. Any entity within the area will be affected."""

    def __init__(
        self,
        engine: Engine,
        radius: int,
        callback: Callable[[Tuple[int, int]], Optional[Action]],
    ):
        super().__init__(engine)

        self.radius = radius
        self.callback = callback

    def on_render(self, console: tcod.Console) -> None:
        """Highlight the tile under the cursor."""
        super().on_render(console)

        x, y = self.engine.mouse_location

        # Draw a rectangle around the targeted area, so the player can see the affected tiles.
        console.draw_frame(
            x=x - self.radius - 1,
            y=y - self.radius - 1,
            width=self.radius ** 2,
            height=self.radius ** 2,
            fg=color.red,
            clear=False,
        )

    def on_index_selected(self, x: int, y: int) -> Optional[Action]:
        return self.callback((x, y))</span>


class MainGameEventHandler(EventHandler):
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p><code>AreaRangedAttackHandler</code> takes a <code>callback</code>, like <code>SingleRangedAttackHandler</code>, but also defies a <code>radius</code>, which tells us how large the area of effect will be.</p>
<p><code>on_render</code> highlights the cursor, but also draws a &ldquo;frame&rdquo; (an empty rectangle) around the area we&rsquo;ll be targeting. This will help the player determine which area will be in the blast.</p>
<p><code>on_index_selected</code> is the same as the one we defined for <code>SingleRangedAttackHandler</code>.</p>
<p>To do the damage, we&rsquo;ll need to implement the <code>Consumable</code> class for the fireball scroll. Open up <code>consumable.py</code> and add this class:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
from exceptions import Impossible
<span style="color:#f92672">-from input_handlers import SingleRangedAttackHandler
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from input_handlers import AreaRangedAttackHandler, SingleRangedAttackHandler
</span><span style="color:#a6e22e"></span>
if TYPE_CHECKING:
    ...


class HealingConsumable(Consumable):
    ...


<span style="color:#a6e22e">+class FireballDamageConsumable(Consumable):
</span><span style="color:#a6e22e">+   def __init__(self, damage: int, radius: int):
</span><span style="color:#a6e22e">+       self.damage = damage
</span><span style="color:#a6e22e">+       self.radius = radius
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def get_action(self, consumer: Actor) -&gt; Optional[actions.Action]:
</span><span style="color:#a6e22e">+       self.engine.message_log.add_message(
</span><span style="color:#a6e22e">+           &#34;Select a target location.&#34;, color.needs_target
</span><span style="color:#a6e22e">+       )
</span><span style="color:#a6e22e">+       self.engine.event_handler = AreaRangedAttackHandler(
</span><span style="color:#a6e22e">+           self.engine,
</span><span style="color:#a6e22e">+           radius=self.radius,
</span><span style="color:#a6e22e">+           callback=lambda xy: actions.ItemAction(consumer, self.parent, xy),
</span><span style="color:#a6e22e">+       )
</span><span style="color:#a6e22e">+       return None
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def activate(self, action: actions.ItemAction) -&gt; None:
</span><span style="color:#a6e22e">+       target_xy = action.target_xy
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       if not self.engine.game_map.visible[target_xy]:
</span><span style="color:#a6e22e">+           raise Impossible(&#34;You cannot target an area that you cannot see.&#34;)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       targets_hit = False
</span><span style="color:#a6e22e">+       for actor in self.engine.game_map.actors:
</span><span style="color:#a6e22e">+           if actor.distance(*target_xy) &lt;= self.radius:
</span><span style="color:#a6e22e">+               self.engine.message_log.add_message(
</span><span style="color:#a6e22e">+                   f&#34;The {actor.name} is engulfed in a fiery explosion, taking {self.damage} damage!&#34;
</span><span style="color:#a6e22e">+               )
</span><span style="color:#a6e22e">+               actor.fighter.take_damage(self.damage)
</span><span style="color:#a6e22e">+               targets_hit = True
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       if not targets_hit:
</span><span style="color:#a6e22e">+           raise Impossible(&#34;There are no targets in the radius.&#34;)
</span><span style="color:#a6e22e">+       self.consume()
</span><span style="color:#a6e22e"></span>

class LightningDamageConsumable(Consumable):
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
from exceptions import Impossible
<span class="crossed-out-text">from input_handlers import SingleRangedAttackHandler</span>
<span class="new-text">from input_handlers import AreaRangedAttackHandler, SingleRangedAttackHandler</span>

if TYPE_CHECKING:
    ...


class HealingConsumable(Consumable):
    ...


<span class="new-text">class FireballDamageConsumable(Consumable):
    def __init__(self, damage: int, radius: int):
        self.damage = damage
        self.radius = radius

    def get_action(self, consumer: Actor) -> Optional[actions.Action]:
        self.engine.message_log.add_message(
            "Select a target location.", color.needs_target
        )
        self.engine.event_handler = AreaRangedAttackHandler(
            self.engine,
            radius=self.radius,
            callback=lambda xy: actions.ItemAction(consumer, self.parent, xy),
        )
        return None

    def activate(self, action: actions.ItemAction) -> None:
        target_xy = action.target_xy

        if not self.engine.game_map.visible[target_xy]:
            raise Impossible("You cannot target an area that you cannot see.")

        targets_hit = False
        for actor in self.engine.game_map.actors:
            if actor.distance(*target_xy) <= self.radius:
                self.engine.message_log.add_message(
                    f"The {actor.name} is engulfed in a fiery explosion, taking {self.damage} damage!"
                )
                actor.fighter.take_damage(self.damage)
                targets_hit = True

        if not targets_hit:
            raise Impossible("There are no targets in the radius.")
        self.consume()</span>


class LightningDamageConsumable(Consumable):
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p><code>FireballDamageConsumable</code> takes <code>damage</code> and <code>radius</code> as arguments in <code>__init__</code>, which shouldn&rsquo;t be too surprising.</p>
<p><code>get_action</code>, similar to the confusion scroll, asks the user to select a target, and switches the event handler, this time to <code>AreaRangedAttackHandler</code>. The callback is once again a <code>lambda</code> function, which is similar to how we handled the confusion scroll.</p>
<p><code>activate</code> gets the target location, and ensures that it is within the line of sight. It then checks for entities within the radius, damaging any that are close enough to hit (take note, there&rsquo;s no exception for the player, so you can get blasted by your own fireball!). If no enemies were hit at all, the <code>Impossible</code> exception is raised, and the scroll isn&rsquo;t consumed, as it would probably be frustrating to waste a scroll on something like a misclick. Assuming at least one entity <em>was</em> damaged, the scroll is consumed.</p>
<p>Let&rsquo;s add the new fireball scroll to <code>entity_factories.py</code> so we can put it to use:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">confusion_scroll = Item(
    ...
)
<span style="color:#a6e22e">+fireball_scroll = Item(
</span><span style="color:#a6e22e">+   char=&#34;~&#34;,
</span><span style="color:#a6e22e">+   color=(255, 0, 0),
</span><span style="color:#a6e22e">+   name=&#34;Fireball Scroll&#34;,
</span><span style="color:#a6e22e">+   consumable=consumable.FireballDamageConsumable(damage=12, radius=3),
</span><span style="color:#a6e22e">+)
</span><span style="color:#a6e22e"></span>health_potion = Item(
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>confusion_scroll = Item(
    ...
)
<span class="new-text">fireball_scroll = Item(
    char="~",
    color=(255, 0, 0),
    name="Fireball Scroll",
    consumable=consumable.FireballDamageConsumable(damage=12, radius=3),
)</span>
health_potion = Item(
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Finally, let&rsquo;s add it to <code>procgen.py</code> so it will show up:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            if item_chance &lt; 0.7:
                entity_factories.health_potion.spawn(dungeon, x, y)
<span style="color:#a6e22e">+           elif item_chance &lt; 0.8:
</span><span style="color:#a6e22e">+               entity_factories.fireball_scroll.spawn(dungeon, x, y)
</span><span style="color:#a6e22e"></span>            elif item_chance &lt; 0.9:
                entity_factories.confusion_scroll.spawn(dungeon, x, y)
            else:
                entity_factories.lightning_scroll.spawn(dungeon, x, y)
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            if item_chance < 0.7:
                entity_factories.health_potion.spawn(dungeon, x, y)
            <span class="new-text">elif item_chance < 0.8:
                entity_factories.fireball_scroll.spawn(dungeon, x, y)</span>
            elif item_chance < 0.9:
                entity_factories.confusion_scroll.spawn(dungeon, x, y)
            else:
                entity_factories.lightning_scroll.spawn(dungeon, x, y)</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Run the project now, and blast away your enemies!</p>
<p><img src="/images/part-9-fireball-targeting.png" alt="Part 9 - Fireball Targeting"></p>
<p>With that, we&rsquo;ve now got three different types of scrolls, and four types of consumables overall! With the event handlers that are in place, it should be fairly simple to add more types of consumables, if you wish. Feel free to experiment with different types of attacks, and add variety to your game.</p>
<p>If you want to see the code so far in its entirety, <a href="https://github.com/TStand90/tcod_tutorial_v2/tree/2020/part-9">click here</a>.</p>
<p><a href="/tutorials/tcod/v2/part-10">Click here to move on to the next part of this tutorial.</a></p>


    

    


</article>



        </div>

        <aside class="col-12 col-lg-3 ml-auto blog-sidebar">
    
    
        <section>
    
        
    
        
    
</section>
    
</aside>

      </div>
    </div>
    

    
      







<footer class="blog-footer w-100">
    <nav class="navbar navbar-light bg-light">
        <p class="w-100 text-center">Last updated July 7th, 2020</p>
        <p class="w-100 text-center"><a href="#">Back to top</a></p>
    </nav>
</footer>

    

    
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
