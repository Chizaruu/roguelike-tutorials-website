<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Part 2 - The generic Entity, the render functions, and the map" />
<meta property="og:description" content="Now that we can move our little &lsquo;@&rsquo; symbol around, we need to give it something to move around in. But before that, let&rsquo;s stop for a moment and think about the player object itself.
Right now, we just represent the player with the &lsquo;@&rsquo; symbol, and its x and y coordinates. Shouldn&rsquo;t we tie those things together in an object, along with some other data and functions that pertain to it?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rogueliketutorials.com/tutorials/tcod/v2/part-2/" /><meta property="article:section" content="tutorials" />
<meta property="article:published_time" content="2020-06-23T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-06-23T00:00:00&#43;00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Part 2 - The generic Entity, the render functions, and the map"/>
<meta name="twitter:description" content="Now that we can move our little &lsquo;@&rsquo; symbol around, we need to give it something to move around in. But before that, let&rsquo;s stop for a moment and think about the player object itself.
Right now, we just represent the player with the &lsquo;@&rsquo; symbol, and its x and y coordinates. Shouldn&rsquo;t we tie those things together in an object, along with some other data and functions that pertain to it?"/>



    <link rel="canonical" href="https://rogueliketutorials.com/tutorials/tcod/v2/part-2/">

    <title>
      
        Part 2 - The generic Entity, the render functions, and the map | Roguelike Tutorials
      
    </title>

    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="https://rogueliketutorials.com/css/style.css" rel="stylesheet">

    

    

    
  </head>
  <body>
    
      

<header class="blog-header">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <a class="navbar-brand" href="/">
            Roguelike Tutorials
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-between" id="navbarNav">
            <ul class="navbar-nav">
                
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/">Home</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutorials/tcod/2019/">TCOD Tutorial (2019)</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutorials/tcod/v2/">TCOD Tutorial (2020)</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/about/">About</a>
                    
                </li>
                
            </ul>
            
        </div>
    </nav>
</header>

    

    
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-8 blog-main">

          

<header>
    <h2 class="blog-post-title">
    <a class="text-dark" href="/tutorials/tcod/v2/part-2/">Part 2 - The generic Entity, the render functions, and the map</a>
</h2>

    


<div class="blog-post-date text-secondary">
    
        <time datetime="2020-06-23">Jun 23, 2020</time>
    
    
</div>

    
    
    <hr>
</header>
<article class="blog-post">
    <p>Now that we can move our little &lsquo;@&rsquo; symbol around, we need to give it
something to move around <em>in</em>. But before that, let&rsquo;s stop for a moment
and think about the player object itself.</p>
<p>Right now, we just represent the player with the &lsquo;@&rsquo; symbol, and its x
and y coordinates. Shouldn&rsquo;t we tie those things together in an object,
along with some other data and functions that pertain to it?</p>
<p>Let&rsquo;s create a generic class to represent not just the player, but just
about <em>everything</em> in our game world. Enemies, items, and whatever other
foreign entities we can dream of will be part of this class, which we&rsquo;ll
call <code>Entity</code>.</p>
<p>Create a new file, and call it <code>entity.py</code>. In that file, put the
following class:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#f92672">from</span> typing <span style="color:#f92672">import</span> Tuple


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entity</span>:
    <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">    A generic object to represent players, enemies, items, etc.
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">def</span> __init__(self, x: int, y: int, char: str, color: Tuple[int, int, int]):
        self<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> x
        self<span style="color:#f92672">.</span>y <span style="color:#f92672">=</span> y
        self<span style="color:#f92672">.</span>char <span style="color:#f92672">=</span> char
        self<span style="color:#f92672">.</span>color <span style="color:#f92672">=</span> color

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">move</span>(self, dx: int, dy: int) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
        <span style="color:#75715e"># Move the entity by a given amount</span>
        self<span style="color:#f92672">.</span>x <span style="color:#f92672">+=</span> dx
        self<span style="color:#f92672">.</span>y <span style="color:#f92672">+=</span> dy</code></pre></div>
<p>The initializer (<code>__init__</code>) takes four arguments: <code>x</code>, <code>y</code>, <code>char</code>, and <code>color</code>.</p>
<ul>
<li><code>x</code> and <code>y</code> are pretty self explanatory: They represent the Entity&rsquo;s &ldquo;x&rdquo; and &ldquo;y&rdquo; coordinates on the map.</li>
<li><code>char</code> is the character we&rsquo;ll use to represent the entity. Our player will be an &ldquo;@&rdquo; symbol, whereas something like a Troll (coming in a later chapter) can be the letter &ldquo;T&rdquo;.</li>
<li><code>color</code> is the color we&rsquo;ll use when drawing the Entity. We define <code>color</code> as a Tuple of three integers, representing the entity&rsquo;s RGB values.</li>
</ul>
<p>The other method is <code>move</code>, which takes <code>dx</code> and <code>dy</code> as arguments, and uses them to modify the Entity&rsquo;s position. This should look familiar to what we did in the last chapter.</p>
<p>Let&rsquo;s put our fancy new class into action! Modify the first part of
<code>main.py</code> to look like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">#!/usr/bin/env python3
import tcod

from actions import EscapeAction, MovementAction
<span style="color:#a6e22e">+from entity import Entity
</span><span style="color:#a6e22e"></span>from input_handlers import EventHandler


def main() -&gt; None:
    screen_width = 80
    screen_height = 50

<span style="color:#f92672">-   player_x = int(screen_width / 2)
</span><span style="color:#f92672">-   player_y = int(screen_height / 2)
</span><span style="color:#f92672"></span>
    tileset = tcod.tileset.load_tilesheet(
        &#34;dejavu10x10_gs_tc.png&#34;, 32, 8, tcod.tileset.CHARMAP_TCOD
    )

    event_handler = EventHandler()

<span style="color:#a6e22e">+   player = Entity(int(screen_width / 2), int(screen_height / 2), &#34;@&#34;, (255, 255, 255))
</span><span style="color:#a6e22e">+   npc = Entity(int(screen_width / 2 - 5), int(screen_height / 2), &#34;@&#34;, (255, 255, 0))
</span><span style="color:#a6e22e">+   entities = {npc, player}
</span><span style="color:#a6e22e"></span>
    with tcod.context.new_terminal(
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>#!/usr/bin/env python3
import tcod

from actions import EscapeAction, MovementAction
<span class="new-text">from entity import Entity</span>
from input_handlers import EventHandler


def main() -> None:
    screen_width = 80
    screen_height = 50

    <span class="crossed-out-text">player_x = int(screen_width / 2)</span>
    <span class="crossed-out-text">player_y = int(screen_height / 2)</span>

    tileset = tcod.tileset.load_tilesheet(
        "dejavu10x10_gs_tc.png", 32, 8, tcod.tileset.CHARMAP_TCOD
    )

    event_handler = EventHandler()

    <span class="new-text">player = Entity(int(screen_width / 2), int(screen_height / 2), "@", (255, 255, 255))
    npc = Entity(int(screen_width / 2 - 5), int(screen_height / 2), "@", (255, 255, 0))
    entities = {npc, player}</span>

    with tcod.context.new_terminal(
        ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>We&rsquo;re importing the <code>Entity</code> class into <code>main.py</code>, and using it to
initialize the player and a new NPC. We store these two in a set, that
will eventually hold all our entities on the map.</p>
<p>Also modify the part where we handle movement so that the Entity class
handles the actual movement.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">                if isinstance(action, MovementAction):
<span style="color:#f92672">-                   player_x += action.dx
</span><span style="color:#f92672">-                   player_y += action.dy
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   player.move(dx=action.dx, dy=action.dy)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>                if isinstance(action, MovementAction):
                    <span class="crossed-out-text">player_x += action.dx</span>
                    <span class="crossed-out-text">player_y += action.dy</span>
                    <span class="new-text">player.move(dx=action.dx, dy=action.dy)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Lastly, update the drawing functions to use the new player object:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        while True:
<span style="color:#f92672">-           root_console.print(x=player_x, y=player_y, string=&#34;@&#34;)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           root_console.print(x=player.x, y=player.y, string=player.char, fg=player.color)
</span><span style="color:#a6e22e"></span>
            context.present(root_console)
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        while True:
            <span class="crossed-out-text">root_console.print(x=player_x, y=player_y, string="@")</span>
            <span class="new-text">root_console.print(x=player.x, y=player.y, string=player.char, fg=player.color)</span>

            context.present(root_console)</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>If you run the project now, only the player gets drawn. We&rsquo;ll need to modify things to draw both entities, and eventually, draw the map we&rsquo;re going to create as well.</p>
<p>Before doing that, it&rsquo;s worth stopping and taking a moment to think about our overall design. Currently, our <code>main.py</code> file is responsible for:</p>
<ul>
<li>Setting up the initial variables, like screen size and the tileset.</li>
<li>Creating the entities</li>
<li>Drawing the screen and everything on it.</li>
<li>Reacting to the player&rsquo;s input.</li>
</ul>
<p>Soon, we&rsquo;re going to need to add a map as well. It&rsquo;s starting to become a bit much.</p>
<p>One thing we can do is pass of some of these responsibilities to another class, which will be responsible for &ldquo;running&rdquo; our game. The <code>main.py</code> file can still set things up and tell that new class what to do, but this design should help keep the <code>main.py</code> file from getting too large over time.</p>
<p>Let&rsquo;s create an <code>Engine</code> class, which will take the responsibilities of drawing the map and entities, as well as handling the player&rsquo;s input. Create a new file, and call it <code>engine.py</code>. In that file, put the following contents:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#f92672">from</span> typing <span style="color:#f92672">import</span> Set, Iterable, Any

<span style="color:#f92672">from</span> tcod.context <span style="color:#f92672">import</span> Context
<span style="color:#f92672">from</span> tcod.console <span style="color:#f92672">import</span> Console

<span style="color:#f92672">from</span> actions <span style="color:#f92672">import</span> EscapeAction, MovementAction
<span style="color:#f92672">from</span> entity <span style="color:#f92672">import</span> Entity
<span style="color:#f92672">from</span> input_handlers <span style="color:#f92672">import</span> EventHandler


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Engine</span>:
    <span style="color:#66d9ef">def</span> __init__(self, entities: Set[Entity], event_handler: EventHandler, player: Entity):
        self<span style="color:#f92672">.</span>entities <span style="color:#f92672">=</span> entities
        self<span style="color:#f92672">.</span>event_handler <span style="color:#f92672">=</span> event_handler
        self<span style="color:#f92672">.</span>player <span style="color:#f92672">=</span> player

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">handle_events</span>(self, events: Iterable[Any]) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
        <span style="color:#66d9ef">for</span> event <span style="color:#f92672">in</span> events:
            action <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>event_handler<span style="color:#f92672">.</span>dispatch(event)

            <span style="color:#66d9ef">if</span> action <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
                <span style="color:#66d9ef">continue</span>

            <span style="color:#66d9ef">if</span> isinstance(action, MovementAction):
                self<span style="color:#f92672">.</span>player<span style="color:#f92672">.</span>move(dx<span style="color:#f92672">=</span>action<span style="color:#f92672">.</span>dx, dy<span style="color:#f92672">=</span>action<span style="color:#f92672">.</span>dy)

            <span style="color:#66d9ef">elif</span> isinstance(action, EscapeAction):
                <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">SystemExit</span>()

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">render</span>(self, console: Console, context: Context) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
        <span style="color:#66d9ef">for</span> entity <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>entities:
            console<span style="color:#f92672">.</span>print(entity<span style="color:#f92672">.</span>x, entity<span style="color:#f92672">.</span>y, entity<span style="color:#f92672">.</span>char, fg<span style="color:#f92672">=</span>entity<span style="color:#f92672">.</span>color)

        context<span style="color:#f92672">.</span>present(console)

        console<span style="color:#f92672">.</span>clear()
</code></pre></div><p>Let&rsquo;s walk through the class a bit, to understand what we&rsquo;re trying to get at here.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Engine</span>:
    <span style="color:#66d9ef">def</span> __init__(self, entities: Set[Entity], event_handler: EventHandler, player: Entity):
        self<span style="color:#f92672">.</span>entities <span style="color:#f92672">=</span> entities
        self<span style="color:#f92672">.</span>event_handler <span style="color:#f92672">=</span> event_handler
        self<span style="color:#f92672">.</span>player <span style="color:#f92672">=</span> player
</code></pre></div><p>The <code>__init__</code> function takes three arguments:</p>
<ul>
<li><code>entities</code> is a set (of entities), which behaves kind of like a list that enforces uniqueness. That is, we can&rsquo;t add an Entity to the set twice, whereas a list would allow that. In our case, having an entity in <code>entities</code> twice doesn&rsquo;t make sense.</li>
<li><code>event_handler</code> is the same <code>event_handler</code> that we used in <code>main.py</code>. It will handle our events.</li>
<li><code>player</code> is the player Entity. We have a separate reference to it outside of <code>entities</code> for ease of access. We&rsquo;ll need to access <code>player</code> a lot more than a random entity in <code>entities</code>.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">handle_events</span>(self, events: Iterable[Any]) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
        <span style="color:#66d9ef">for</span> event <span style="color:#f92672">in</span> events:
            action <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>event_handler<span style="color:#f92672">.</span>dispatch(event)

            <span style="color:#66d9ef">if</span> action <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
                <span style="color:#66d9ef">continue</span>

            <span style="color:#66d9ef">if</span> isinstance(action, MovementAction):
                self<span style="color:#f92672">.</span>player<span style="color:#f92672">.</span>move(dx<span style="color:#f92672">=</span>action<span style="color:#f92672">.</span>dx, dy<span style="color:#f92672">=</span>action<span style="color:#f92672">.</span>dy)

            <span style="color:#66d9ef">elif</span> isinstance(action, EscapeAction):
                <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">SystemExit</span>()
</code></pre></div><p>This should look familiar: It&rsquo;s almost identical to our event processing in <code>main.py</code>. We pass the <code>events</code> to it so it can iterate through them, and it uses <code>self.event_handler</code> to handle the events.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">render</span>(self, console: Console, context: Context) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
        <span style="color:#66d9ef">for</span> entity <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>entities:
            console<span style="color:#f92672">.</span>print(entity<span style="color:#f92672">.</span>x, entity<span style="color:#f92672">.</span>y, entity<span style="color:#f92672">.</span>char, fg<span style="color:#f92672">=</span>entity<span style="color:#f92672">.</span>color)

        context<span style="color:#f92672">.</span>present(console)

        console<span style="color:#f92672">.</span>clear()
</code></pre></div><p>This handles drawing our screen. We iterate through the <code>self.entities</code> and print them to their proper locations, then present the context, and clear the console, like we did in <code>main.py</code>.</p>
<p>To make use of our new <code>Engine</code> class, we&rsquo;ll need to modify <code>main.py</code> quite a bit.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">#!/usr/bin/env python3
import tcod

<span style="color:#f92672">-from actions import EscapeAction, MovementAction
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from engine import Engine
</span><span style="color:#a6e22e"></span>from entity import Entity
from input_handlers import EventHandler


def main() -&gt; None:
    screen_width = 80
    screen_height = 50

    tileset = tcod.tileset.load_tilesheet(
        &#34;dejavu10x10_gs_tc.png&#34;, 32, 8, tcod.tileset.CHARMAP_TCOD
    )

    event_handler = EventHandler()

    player = Entity(int(screen_width / 2), int(screen_height / 2), &#34;@&#34;, (255, 255, 255))
    npc = Entity(int(screen_width / 2 - 5), int(screen_height / 2), &#34;@&#34;, (255, 255, 0))
    entities = {npc, player}

<span style="color:#a6e22e">+   engine = Engine(entities=entities, event_handler=event_handler, player=player)
</span><span style="color:#a6e22e"></span>
    with tcod.context.new_terminal(
        screen_width,
        screen_height,
        tileset=tileset,
        title=&#34;Yet Another Roguelike Tutorial&#34;,
        vsync=True,
    ) as context:
        root_console = tcod.Console(screen_width, screen_height, order=&#34;F&#34;)
        while True:
<span style="color:#f92672">-           root_console.print(x=player_x, y=player_y, string=&#34;@&#34;)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           engine.render(console=root_console, context=context)
</span><span style="color:#a6e22e"></span>
<span style="color:#f92672">-           context.present(root_console)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           events = tcod.event.wait()
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+           engine.handle_events(events)
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-           root_console.clear()
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-           for event in tcod.event.wait():
</span><span style="color:#f92672">-               action = event_handler.dispatch(event)
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-               if action is None:
</span><span style="color:#f92672">-                   continue
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-               if isinstance(action, MovementAction):
</span><span style="color:#f92672">-                   player_x += action.dx
</span><span style="color:#f92672">-                   player_y += action.dy
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-               elif isinstance(action, EscapeAction):
</span><span style="color:#f92672">-                   raise SystemExit()
</span><span style="color:#f92672"></span>

if __name__ == &#34;__main__&#34;:
    main()
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>#!/usr/bin/env python3
import tcod

<span class="crossed-out-text">from actions import EscapeAction, MovementAction</span>
<span class="new-text">from engine import Engine</span>
from entity import Entity
from input_handlers import EventHandler


def main() -> None:
    screen_width = 80
    screen_height = 50

    tileset = tcod.tileset.load_tilesheet(
        "dejavu10x10_gs_tc.png", 32, 8, tcod.tileset.CHARMAP_TCOD
    )

    event_handler = EventHandler()

    player = Entity(int(screen_width / 2), int(screen_height / 2), "@", (255, 255, 255))
    npc = Entity(int(screen_width / 2 - 5), int(screen_height / 2), "@", (255, 255, 0))
    entities = {npc, player}

    <span class="new-text">engine = Engine(entities=entities, event_handler=event_handler, player=player)</span>

    with tcod.context.new_terminal(
        screen_width,
        screen_height,
        tileset=tileset,
        title="Yet Another Roguelike Tutorial",
        vsync=True,
    ) as context:
        root_console = tcod.Console(screen_width, screen_height, order="F")
        while True:
            <span class="crossed-out-text">root_console.print(x=player_x, y=player_y, string="@")</span>
            <span class="new-text">engine.render(console=root_console, context=context)</span>

            <span class="crossed-out-text">context.present(root_console)</span>
            <span class="new-text">events = tcod.event.wait()</span>

            <span class="new-text">engine.handle_events(events)</span>
            <span class="crossed-out-text">root_console.clear()</span>

            <span class="crossed-out-text">for event in tcod.event.wait():</span>
                <span class="crossed-out-text">action = event_handler.dispatch(event)</span>

                <span class="crossed-out-text">if action is None:</span>
                    <span class="crossed-out-text">continue</span>

                <span class="crossed-out-text">if isinstance(action, MovementAction):</span>
                    <span class="crossed-out-text">player_x += action.dx</span>
                    <span class="crossed-out-text">player_y += action.dy</span>

                <span class="crossed-out-text">elif isinstance(action, EscapeAction):</span>
                    <span class="crossed-out-text">raise SystemExit()</span>


if __name__ == "__main__":
    main()</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Because we&rsquo;ve moved the rendering and event handling code to the <code>Engine</code> class, we no longer need it in <code>main.py</code>. All we need to do is create the <code>Engine</code> instance, pass the needed variables to it, and use the methods we wrote for it.</p>
<p>Run the project now, and your screen should look like this:</p>
<p><img src="/images/part-2-drawing-both-entities.png" alt="Part 2 - Both Entities"></p>
<p>Our <code>main.py</code> file is looking a lot smaller and simpler, and we&rsquo;ve rendered both the player and the NPC to the screen. With that, we&rsquo;ll want to move on to creating a map for our entity to move around in. We won&rsquo;t do the procedural dungeon generation in this chapter (that&rsquo;s next), but we&rsquo;ll at least get our class that will hold that map set up.</p>
<p>We can represent the map with a new class, called <code>GameMap</code>. The map itself will be made up of tiles, which will contain certain data about if the tile is &ldquo;walkable&rdquo; (True if it&rsquo;s a floor, False if its a wall), &ldquo;transparency&rdquo; (again, True for floors, False for walls), and how to render the tile to the screen.</p>
<p>We&rsquo;ll create the <code>tiles</code> first. Create a new file called <code>tile_types.py</code> and fill it with the following contents:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#f92672">from</span> typing <span style="color:#f92672">import</span> Tuple

<span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np  <span style="color:#75715e"># type: ignore</span>

<span style="color:#75715e"># Tile graphics structured type compatible with Console.tiles_rgb.</span>
graphic_dt <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>dtype(
    [
        (<span style="color:#e6db74">&#34;ch&#34;</span>, np<span style="color:#f92672">.</span>int32),  <span style="color:#75715e"># Unicode codepoint.</span>
        (<span style="color:#e6db74">&#34;fg&#34;</span>, <span style="color:#e6db74">&#34;3B&#34;</span>),  <span style="color:#75715e"># 3 unsigned bytes, for RGB colors.</span>
        (<span style="color:#e6db74">&#34;bg&#34;</span>, <span style="color:#e6db74">&#34;3B&#34;</span>),
    ]
)

<span style="color:#75715e"># Tile struct used for statically defined tile data.</span>
tile_dt <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>dtype(
    [
        (<span style="color:#e6db74">&#34;walkable&#34;</span>, np<span style="color:#f92672">.</span>bool),  <span style="color:#75715e"># True if this tile can be walked over.</span>
        (<span style="color:#e6db74">&#34;transparent&#34;</span>, np<span style="color:#f92672">.</span>bool),  <span style="color:#75715e"># True if this tile doesn&#39;t block FOV.</span>
        (<span style="color:#e6db74">&#34;dark&#34;</span>, graphic_dt),  <span style="color:#75715e"># Graphics for when this tile is not in FOV.</span>
    ]
)


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">new_tile</span>(
    <span style="color:#f92672">*</span>,  <span style="color:#75715e"># Enforce the use of keywords, so that parameter order doesn&#39;t matter.</span>
    walkable: int,
    transparent: int,
    dark: Tuple[int, Tuple[int, int, int], Tuple[int, int, int]],
) <span style="color:#f92672">-&gt;</span> np<span style="color:#f92672">.</span>ndarray:
    <span style="color:#e6db74">&#34;&#34;&#34;Helper function for defining individual tile types &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>array((walkable, transparent, dark), dtype<span style="color:#f92672">=</span>tile_dt)


floor <span style="color:#f92672">=</span> new_tile(
    walkable<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, transparent<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, dark<span style="color:#f92672">=</span>(ord(<span style="color:#e6db74">&#34; &#34;</span>), (<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>), (<span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">150</span>)),
)
wall <span style="color:#f92672">=</span> new_tile(
    walkable<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, transparent<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, dark<span style="color:#f92672">=</span>(ord(<span style="color:#e6db74">&#34; &#34;</span>), (<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>), (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>)),
)
</code></pre></div><p>That&rsquo;s quite a lot to take in all at once. Let&rsquo;s go through it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#75715e"># Tile graphics structured type compatible with Console.tiles_rgb.</span>
graphic_dt <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>dtype(
    [
        (<span style="color:#e6db74">&#34;ch&#34;</span>, np<span style="color:#f92672">.</span>int32),  <span style="color:#75715e"># Unicode codepoint.</span>
        (<span style="color:#e6db74">&#34;fg&#34;</span>, <span style="color:#e6db74">&#34;3B&#34;</span>),  <span style="color:#75715e"># 3 unsigned bytes, for RGB colors.</span>
        (<span style="color:#e6db74">&#34;bg&#34;</span>, <span style="color:#e6db74">&#34;3B&#34;</span>),
    ]
)
</code></pre></div><p><code>dtype</code> creates a data type which Numpy can use, which behaves similarly to a <code>struct</code> in a language like C. Our data type is made up of three parts:</p>
<ul>
<li><code>ch</code>: The character, represented in integer format. We&rsquo;ll translate it from the integer into Unicode.</li>
<li><code>fg</code>: The foreground color. &ldquo;3B&rdquo; means 3 unsigned bytes, which can be used for RGB color codes.</li>
<li><code>bg</code>: The background color. Similar to <code>fg</code>.</li>
</ul>
<p>We take this new data type and use it in the next bit:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#75715e"># Tile struct used for statically defined tile data.</span>
tile_dt <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>dtype(
    [
        (<span style="color:#e6db74">&#34;walkable&#34;</span>, np<span style="color:#f92672">.</span>bool),  <span style="color:#75715e"># True if this tile can be walked over.</span>
        (<span style="color:#e6db74">&#34;transparent&#34;</span>, np<span style="color:#f92672">.</span>bool),  <span style="color:#75715e"># True if this tile doesn&#39;t block FOV.</span>
        (<span style="color:#e6db74">&#34;dark&#34;</span>, graphic_dt),  <span style="color:#75715e"># Graphics for when this tile is not in FOV.</span>
    ]
)
</code></pre></div><p>This is yet another <code>dtype</code>, which we&rsquo;ll use in the actual tile itself. It&rsquo;s also made up of three parts:</p>
<ul>
<li><code>walkable</code>: A boolean that describes if the player can walk across this tile.</li>
<li><code>transparent</code>: A boolean that describes if this tile does or does not block the field of view. Not used in this chapter, but will be in chapter 4.</li>
<li><code>dark</code>: This uses our previously defined <code>dtype</code>, which holds the character to print, the foreground color, and the background color. Why is it called <code>dark</code>? Because later on, we&rsquo;ll want to differentiate between tiles that are and aren&rsquo;t in the field of view. <code>dark</code> will represent tiles that are not in the current field of view. Again, we&rsquo;ll cover that in part 4.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">new_tile</span>(
    <span style="color:#f92672">*</span>,  <span style="color:#75715e"># Enforce the use of keywords, so that parameter order doesn&#39;t matter.</span>
    walkable: int,
    transparent: int,
    dark: Tuple[int, Tuple[int, int, int], Tuple[int, int, int]],
) <span style="color:#f92672">-&gt;</span> np<span style="color:#f92672">.</span>ndarray:
    <span style="color:#e6db74">&#34;&#34;&#34;Helper function for defining individual tile types &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>array((walkable, transparent, dark), dtype<span style="color:#f92672">=</span>tile_dt)
</code></pre></div><p>This is a helper function, that we&rsquo;ll use in the next section to define our tile types. It takes the parameters <code>walkable</code>, <code>transparent</code>, and <code>dark</code>, which should look familiar, since they&rsquo;re the same data points we used in <code>tile_dt</code>. It creates a Numpy array of just the one <code>tile_dt</code> element, and returns it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">floor <span style="color:#f92672">=</span> new_tile(
    walkable<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, transparent<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, dark<span style="color:#f92672">=</span>(ord(<span style="color:#e6db74">&#34; &#34;</span>), (<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>), (<span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">150</span>)),
)
wall <span style="color:#f92672">=</span> new_tile(
    walkable<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, transparent<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, dark<span style="color:#f92672">=</span>(ord(<span style="color:#e6db74">&#34; &#34;</span>), (<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>), (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>)),
)
</code></pre></div><p>Finally, we arrive to our actual tile types. We&rsquo;ve got two: <code>floor</code> and <code>wall</code>.</p>
<p><code>floor</code> is both <code>walkable</code> and <code>transparent</code>. Its <code>dark</code> attribute consists of the space character (feel free to change this to something else, a lot of roguelikes use &ldquo;#&quot;) and defines its foreground color as white (won&rsquo;t matter since it&rsquo;s an empty space) and a background color.</p>
<p><code>wall</code> is neither <code>walkable</code> nor <code>transparent</code>, and its <code>dark</code> attribute differs from <code>floor</code> slightly in its background color.</p>
<p>Now let&rsquo;s use our newly created tiles by creating our map class. Create a file called <code>game_map.py</code> and fill it with the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np  <span style="color:#75715e"># type: ignore</span>
<span style="color:#f92672">from</span> tcod.console <span style="color:#f92672">import</span> Console

<span style="color:#f92672">import</span> tile_types


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GameMap</span>:
    <span style="color:#66d9ef">def</span> __init__(self, width: int, height: int):
        self<span style="color:#f92672">.</span>width, self<span style="color:#f92672">.</span>height <span style="color:#f92672">=</span> width, height
        self<span style="color:#f92672">.</span>tiles <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>full((width, height), fill_value<span style="color:#f92672">=</span>tile_types<span style="color:#f92672">.</span>floor, order<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;F&#34;</span>)

        self<span style="color:#f92672">.</span>tiles[<span style="color:#ae81ff">30</span>:<span style="color:#ae81ff">33</span>, <span style="color:#ae81ff">22</span>] <span style="color:#f92672">=</span> tile_types<span style="color:#f92672">.</span>wall

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">in_bounds</span>(self, x: int, y: int) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#e6db74">&#34;&#34;&#34;Return True if x and y are inside of the bounds of this map.&#34;&#34;&#34;</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>width <span style="color:#f92672">and</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> y <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>height

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">render</span>(self, console: Console) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
        console<span style="color:#f92672">.</span>tiles_rgb[<span style="color:#ae81ff">0</span>:self<span style="color:#f92672">.</span>width, <span style="color:#ae81ff">0</span>:self<span style="color:#f92672">.</span>height] <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>tiles[<span style="color:#e6db74">&#34;dark&#34;</span>]
</code></pre></div><p>Let&rsquo;s break down <code>GameMap</code> a bit:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">    <span style="color:#66d9ef">def</span> __init__(self, width: int, height: int):
        self<span style="color:#f92672">.</span>width, self<span style="color:#f92672">.</span>height <span style="color:#f92672">=</span> width, height
        self<span style="color:#f92672">.</span>tiles <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>full((width, height), fill_value<span style="color:#f92672">=</span>tile_types<span style="color:#f92672">.</span>floor, order<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;F&#34;</span>)

        self<span style="color:#f92672">.</span>tiles[<span style="color:#ae81ff">30</span>:<span style="color:#ae81ff">33</span>, <span style="color:#ae81ff">22</span>] <span style="color:#f92672">=</span> tile_types<span style="color:#f92672">.</span>wall
</code></pre></div><p>The initializer takes <code>width</code> and <code>height</code> integers and assigns them, in one line.</p>
<p>The <code>self.tiles</code> line might look a little strange if you&rsquo;re not used to Numpy. Basically, we create a 2D array, filled with the same values, which in this case, is the <code>tile_types.floor</code> that we created earlier. This will fill <code>self.tiles</code> with floor tiles.</p>
<p><code>self.tiles[30:33, 22] = tile_types.wall</code> creates a small, three tile wide wall at the specified location. We won&rsquo;t normally hard-code walls like this, the wall is just for demonstration purposes. We&rsquo;ll remove it in the next part.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">in_bounds</span>(self, x: int, y: int) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#e6db74">&#34;&#34;&#34;Return True if x and y are inside of the bounds of this map.&#34;&#34;&#34;</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>width <span style="color:#f92672">and</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> y <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>height
</code></pre></div><p>As the docstring alludes to, this method returns <code>True</code> if the given x and y values are within the map&rsquo;s boundaries. We can use this to ensure the player doesn&rsquo;t move beyond the map, into the void.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">render</span>(self, console: Console) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
        console<span style="color:#f92672">.</span>tiles_rgb[<span style="color:#ae81ff">0</span>:self<span style="color:#f92672">.</span>width, <span style="color:#ae81ff">0</span>:self<span style="color:#f92672">.</span>height] <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>tiles[<span style="color:#e6db74">&#34;dark&#34;</span>]
</code></pre></div><p>Using the <code>Console</code> class&rsquo;s <code>tiles_rgb</code> method, we can quickly render the entire map. This method proves much faster than using the <code>console.print</code> method that we use for the individual entities.</p>
<p>With our <code>GameMap</code> class ready to go, let&rsquo;s modify <code>main.py</code> to make use of it. We&rsquo;ll also need to modify <code>Engine</code> to hold the map. Let&rsquo;s start with <code>main.py</code> though:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">#!/usr/bin/env python3
import tcod

from engine import Engine
from entity import Entity
<span style="color:#a6e22e">+from game_map import GameMap
</span><span style="color:#a6e22e"></span>from input_handlers import EventHandler


def main() -&gt; None:
    screen_width = 80
    screen_height = 50

<span style="color:#a6e22e">+   map_width = 80
</span><span style="color:#a6e22e">+   map_height = 45
</span><span style="color:#a6e22e"></span>
    tileset = tcod.tileset.load_tilesheet(
        &#34;dejavu10x10_gs_tc.png&#34;, 32, 8, tcod.tileset.CHARMAP_TCOD
    )

    event_handler = EventHandler()

    player = Entity(int(screen_width / 2), int(screen_height / 2), &#34;@&#34;, (255, 255, 255))
    npc = Entity(int(screen_width / 2 - 5), int(screen_height / 2), &#34;@&#34;, (255, 255, 0))
    entities = {npc, player}

<span style="color:#a6e22e">+   game_map = GameMap(map_width, map_height)
</span><span style="color:#a6e22e"></span>
<span style="color:#f92672">-   engine = Engine(entities=entities, event_handler=event_handler, player=player)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   engine = Engine(entities=entities, event_handler=event_handler, game_map=game_map, player=player)
</span><span style="color:#a6e22e"></span>
    with tcod.context.new_terminal(
        screen_width,
        screen_height,
        tileset=tileset,
        title=&#34;Yet Another Roguelike Tutorial&#34;,
        vsync=True,
    ) as context:
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>#!/usr/bin/env python3
import tcod

from engine import Engine
from entity import Entity
<span class="new-text">from game_map import GameMap</span>
from input_handlers import EventHandler


def main() -> None:
    screen_width = 80
    screen_height = 50

    <span class="new-text">map_width = 80
    map_height = 45</span>

    tileset = tcod.tileset.load_tilesheet(
        "dejavu10x10_gs_tc.png", 32, 8, tcod.tileset.CHARMAP_TCOD
    )

    event_handler = EventHandler()

    player = Entity(int(screen_width / 2), int(screen_height / 2), "@", (255, 255, 255))
    npc = Entity(int(screen_width / 2 - 5), int(screen_height / 2), "@", (255, 255, 0))
    entities = {npc, player}

    <span class="new-text">game_map = GameMap(map_width, map_height)</span>

    <span class="crossed-out-text">engine = Engine(entities=entities, event_handler=event_handler, player=player)</span>
    <span class="new-text">engine = Engine(entities=entities, event_handler=event_handler, game_map=game_map, player=player)</span>

    with tcod.context.new_terminal(
        screen_width,
        screen_height,
        tileset=tileset,
        title="Yet Another Roguelike Tutorial",
        vsync=True,
    ) as context:</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>We&rsquo;ve added <code>map_width</code> and <code>map_height</code>, two integers, which we use in the <code>GameMap</code> class to describe its width and height. The <code>game_map</code> variable holds our initialized <code>GameMap</code>, and we then pass it into <code>engine</code>. The <code>Engine</code> class doesn&rsquo;t yet accept a <code>GameMap</code> in its <code>__init__</code> function, so let&rsquo;s fix that now.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from typing import Set, Iterable, Any

from tcod.context import Context
from tcod.console import Console

from actions import EscapeAction, MovementAction
from entity import Entity
<span style="color:#a6e22e">+from game_map import GameMap
</span><span style="color:#a6e22e"></span>from input_handlers import EventHandler


class Engine:
<span style="color:#f92672">-   def __init__(self, entities: Set[Entity], event_handler: EventHandler, player: Entity):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def __init__(self, entities: Set[Entity], event_handler: EventHandler, game_map: GameMap, player: Entity):
</span><span style="color:#a6e22e"></span>        self.entities = entities
        self.event_handler = event_handler
<span style="color:#a6e22e">+       self.game_map = game_map
</span><span style="color:#a6e22e"></span>        self.player = player

    def handle_events(self, events: Iterable[Any]) -&gt; None:
        for event in events:
            action = self.event_handler.dispatch(event)

            if action is None:
                continue

            if isinstance(action, MovementAction):
<span style="color:#f92672">-               self.player.move(dx=action.dx, dy=action.dy)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+               if self.game_map.tiles[&#34;walkable&#34;][self.player.x + action.dx, self.player.y + action.dy]:
</span><span style="color:#a6e22e">+                   self.player.move(dx=action.dx, dy=action.dy)
</span><span style="color:#a6e22e"></span>
            elif isinstance(action, EscapeAction):
                raise SystemExit()

    def render(self, console: Console, context: Context) -&gt; None:
<span style="color:#a6e22e">+       self.game_map.render(console)
</span><span style="color:#a6e22e"></span>
        for entity in self.entities:
            console.print(entity.x, entity.y, entity.char, fg=entity.color)

        context.present(console)

        console.clear()
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from typing import Set, Iterable, Any

from tcod.context import Context
from tcod.console import Console

from actions import EscapeAction, MovementAction
from entity import Entity
<span class="new-text">from game_map import GameMap</span>
from input_handlers import EventHandler


class Engine:
    <span class="crossed-out-text">def __init__(self, entities: Set[Entity], event_handler: EventHandler, player: Entity):</span>
    <span class="new-text">def __init__(self, entities: Set[Entity], event_handler: EventHandler, game_map: GameMap, player: Entity):</span>
        self.entities = entities
        self.event_handler = event_handler
        <span class="new-text">self.game_map = game_map</span>
        self.player = player

    def handle_events(self, events: Iterable[Any]) -> None:
        for event in events:
            action = self.event_handler.dispatch(event)

            if action is None:
                continue

            if isinstance(action, MovementAction):
                <span class="crossed-out-text">self.player.move(dx=action.dx, dy=action.dy)</span>
                <span class="new-text">if self.game_map.tiles["walkable"][self.player.x + action.dx, self.player.y + action.dy]:
                    self.player.move(dx=action.dx, dy=action.dy)</span>

            elif isinstance(action, EscapeAction):
                raise SystemExit()

    def render(self, console: Console, context: Context) -> None:
        <span class="new-text">self.game_map.render(console)</span>

        for entity in self.entities:
            console.print(entity.x, entity.y, entity.char, fg=entity.color)

        context.present(console)

        console.clear()</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>We&rsquo;ve imported the <code>GameMap</code> class, and we&rsquo;re now passing an instance of it in the <code>Engine</code> class&rsquo;s initializer. From there, we utilize it in two ways:</p>
<ul>
<li>In <code>handle_events</code>, we use it to check if the tile is &ldquo;walkable&rdquo;, and only then do we move the player.</li>
<li>In <code>render</code>, we call the <code>GameMap</code>&rsquo;s <code>render</code> method to draw it to the screen.</li>
</ul>
<p>If you run the project now, it should look like this:</p>
<p><img src="/images/part-2-entities-and-map.png" alt="Part 2 - Both Entities and Map"></p>
<p>The darker squares represent the wall, which, if you try to move your character through, should prove to be impenetrable.</p>
<p>Before we finish this up, there&rsquo;s one last improvement we can make, thanks to our new <code>Engine</code> class: We can expand our <code>Action</code> classes to do a bit more of the heavy lifting, rather than leaving it to the <code>Engine</code>. This is because we can pass the <code>Engine</code> to the <code>Action</code>, providing it with the context it needs to do what we want.</p>
<p>Here&rsquo;s what that looks like:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#a6e22e">+from __future__ import annotations
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+from typing import TYPE_CHECKING
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+if TYPE_CHECKING:
</span><span style="color:#a6e22e">+   from engine import Engine
</span><span style="color:#a6e22e">+   from entity import Entity
</span><span style="color:#a6e22e"></span>

class Action:
<span style="color:#f92672">-   pass
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def perform(self, engine: Engine, entity: Entity) -&gt; None:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Perform this action with the objects needed to determine its scope.
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       `engine` is the scope this action is being performed in.
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       `entity` is the object performing the action.
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       This method must be overridden by Action subclasses.
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;
</span><span style="color:#a6e22e">+       raise NotImplementedError()
</span><span style="color:#a6e22e"></span>

class EscapeAction(Action):
<span style="color:#f92672">-   pass
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def perform(self, engine: Engine, entity: Entity) -&gt; None:
</span><span style="color:#a6e22e">+       raise SystemExit()
</span><span style="color:#a6e22e"></span>

class MovementAction(Action):
    def __init__(self, dx: int, dy: int):
        super().__init__()

        self.dx = dx
        self.dy = dy

<span style="color:#a6e22e">+   def perform(self, engine: Engine, entity: Entity) -&gt; None:
</span><span style="color:#a6e22e">+       dest_x = entity.x + self.dx
</span><span style="color:#a6e22e">+       dest_y = entity.y + self.dy
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       if not engine.game_map.in_bounds(dest_x, dest_y):
</span><span style="color:#a6e22e">+           return  # Destination is out of bounds.
</span><span style="color:#a6e22e">+       if not engine.game_map.tiles[&#34;walkable&#34;][dest_x, dest_y]:
</span><span style="color:#a6e22e">+           return  # Destination is blocked by a tile.
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       entity.move(self.dx, self.dy)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="new-text">from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from engine import Engine
    from entity import Entity</span>


class Action:
    <span class="crossed-out-text">pass</span>
    <span class="new-text">def perform(self, engine: Engine, entity: Entity) -> None:
        """Perform this action with the objects needed to determine its scope.

        `engine` is the scope this action is being performed in.

        `entity` is the object performing the action.

        This method must be overridden by Action subclasses.
        """
        raise NotImplementedError()</span>


class EscapeAction(Action):
    <span class="crossed-out-text">pass</span>
    <span class="new-text">def perform(self, engine: Engine, entity: Entity) -> None:
        raise SystemExit()</span>


class MovementAction(Action):
    def __init__(self, dx: int, dy: int):
        super().__init__()

        self.dx = dx
        self.dy = dy

    <span class="new-text">def perform(self, engine: Engine, entity: Entity) -> None:
        dest_x = entity.x + self.dx
        dest_y = entity.y + self.dy

        if not engine.game_map.in_bounds(dest_x, dest_y):
            return  # Destination is out of bounds.
        if not engine.game_map.tiles["walkable"][dest_x, dest_y]:
            return  # Destination is blocked by a tile.

        entity.move(self.dx, self.dy)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now we&rsquo;re passing in the <code>Engine</code> and the <code>Entity</code> performing the action to each <code>Action</code> subclass. Each subclass needs to implement its own version of the <code>perform</code> method. In the case of <code>EscapeAction</code>, we&rsquo;re just raising <code>SystemExit</code>. In the case of <code>MovementAction</code>, we double check that the move is &ldquo;in bounds&rdquo; and on a &ldquo;walkable&rdquo; tile, and if either is true, we return without doing anything. If neither of those cases prove true, then we move the entity, as before.</p>
<p>So what does this new technique do for us? As it turns out, we can simplify the <code>Engine.handle_events</code> method like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
<span style="color:#f92672">-from actions import EscapeAction, MovementAction
</span><span style="color:#f92672"></span>from entity import Entity
from game_map import GameMap
from input_handlers import EventHandler


class Engine:
    ...

    def handle_events(self, events: Iterable[Any]) -&gt; None:
        for event in events:
            action = self.event_handler.dispatch(event)

            if action is None:
                continue

<span style="color:#a6e22e">+           action.perform(self, self.player)
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-           if isinstance(action, MovementAction):
</span><span style="color:#f92672">-               if self.game_map.tiles[&#34;walkable&#34;][self.player.x + action.dx, self.player.y + action.dy]:
</span><span style="color:#f92672">-                   self.player.move(dx=action.dx, dy=action.dy)
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-           elif isinstance(action, EscapeAction):
</span><span style="color:#f92672">-               raise SystemExit()
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
<span class="crossed-out-text">from actions import EscapeAction, MovementAction</span>
from entity import Entity
from game_map import GameMap
from input_handlers import EventHandler


class Engine:
    ...

    def handle_events(self, events: Iterable[Any]) -> None:
        for event in events:
            action = self.event_handler.dispatch(event)

            if action is None:
                continue

            <span class="new-text">action.perform(self, self.player)</span>
            <span class="crossed-out-text">if isinstance(action, MovementAction):</span>
                <span class="crossed-out-text">if self.game_map.tiles["walkable"][self.player.x + action.dx, self.player.y + action.dy]:</span>
                    <span class="crossed-out-text">self.player.move(dx=action.dx, dy=action.dy)</span>

            <span class="crossed-out-text">elif isinstance(action, EscapeAction):</span>
                <span class="crossed-out-text">raise SystemExit()</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Much simpler! Run the project again, and it should function the same as before.</p>
<p>With that, Part 2 is now complete! We&rsquo;ve managed to lay the groundwork for generating dungeons and moving through them, which, as it happens, is what the next part is all about.</p>
<p>If you want to see the code so far in its entirety, <a href="https://github.com/TStand90/tcod_tutorial_v2/tree/2020/part-2">click
here</a>.</p>
<p><a href="/tutorials/tcod/v2/part-3">Click here to move on to the next part of this
tutorial.</a></p>


    

    


</article>



        </div>

        <aside class="col-12 col-lg-3 ml-auto blog-sidebar">
    
    
        <section>
    
        
    
        
    
</section>
    
</aside>

      </div>
    </div>
    

    
      







<footer class="blog-footer w-100">
    <nav class="navbar navbar-light bg-light">
        <p class="w-100 text-center">Last updated July 7th, 2020</p>
        <p class="w-100 text-center"><a href="#">Back to top</a></p>
    </nav>
</footer>

    

    
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
