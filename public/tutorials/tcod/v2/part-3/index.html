<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Part 3 - Generating a dungeon" />
<meta property="og:description" content="Note: This part of the tutorial relies on TCOD version 11.14 or higher. You might need to upgrade the library (and your requirements.txt file, if you&rsquo;re using one).
Remember how we created a wall in the last part? We won&rsquo;t need that anymore. Additionally, our dungeon generator will start by filling the entire map with &ldquo;wall&rdquo; tiles and &ldquo;carving&rdquo; out rooms, so we can modify our GameMap class to fill in walls instead of floors." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rogueliketutorials.com/tutorials/tcod/v2/part-3/" /><meta property="article:section" content="tutorials" />
<meta property="article:published_time" content="2020-06-23T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-06-23T00:00:00&#43;00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Part 3 - Generating a dungeon"/>
<meta name="twitter:description" content="Note: This part of the tutorial relies on TCOD version 11.14 or higher. You might need to upgrade the library (and your requirements.txt file, if you&rsquo;re using one).
Remember how we created a wall in the last part? We won&rsquo;t need that anymore. Additionally, our dungeon generator will start by filling the entire map with &ldquo;wall&rdquo; tiles and &ldquo;carving&rdquo; out rooms, so we can modify our GameMap class to fill in walls instead of floors."/>



    <link rel="canonical" href="https://rogueliketutorials.com/tutorials/tcod/v2/part-3/">

    <title>
      
        Part 3 - Generating a dungeon | Roguelike Tutorials
      
    </title>

    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="https://rogueliketutorials.com/css/style.css" rel="stylesheet">

    

    

    
  </head>
  <body>
    
      

<header class="blog-header">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <a class="navbar-brand" href="/">
            Roguelike Tutorials
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-between" id="navbarNav">
            <ul class="navbar-nav">
                
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/">Home</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutorials/tcod/2019/">TCOD Tutorial (2019)</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutorials/tcod/v2/">TCOD Tutorial (2020)</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/about/">About</a>
                    
                </li>
                
            </ul>
            
        </div>
    </nav>
</header>

    

    
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-8 blog-main">

          

<header>
    <h2 class="blog-post-title">
    <a class="text-dark" href="/tutorials/tcod/v2/part-3/">Part 3 - Generating a dungeon</a>
</h2>

    


<div class="blog-post-date text-secondary">
    
        <time datetime="2020-06-23">Jun 23, 2020</time>
    
    
</div>

    
    
    <hr>
</header>
<article class="blog-post">
    <p><em>Note: This part of the tutorial relies on TCOD version 11.14 or higher. You might need to upgrade the library (and your requirements.txt file, if you&rsquo;re using one).</em></p>
<p>Remember how we created a wall in the last part? We won&rsquo;t need that anymore. Additionally, our dungeon generator will start by filling the entire map with &ldquo;wall&rdquo; tiles and &ldquo;carving&rdquo; out rooms, so we can modify our <code>GameMap</code> class to fill in walls instead of floors.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class GameMap:
    def __init__(self, width: int, height: int):
        self.width, self.height = width, height
<span style="color:#f92672">-       self.tiles = np.full((width, height), fill_value=tile_types.floor, order=&#34;F&#34;)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       self.tiles = np.full((width, height), fill_value=tile_types.wall, order=&#34;F&#34;)
</span><span style="color:#a6e22e"></span>
<span style="color:#f92672">-       self.tiles[30:33, 22] = tile_types.wall
</span><span style="color:#f92672"></span>        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class GameMap:
    def __init__(self, width: int, height: int):
        self.width, self.height = width, height
        <span class="crossed-out-text">self.tiles = np.full((width, height), fill_value=tile_types.floor, order="F")</span>
        <span class="new-text">self.tiles = np.full((width, height), fill_value=tile_types.wall, order="F")</span>

        <span class="crossed-out-text">self.tiles[30:33, 22] = tile_types.wall</span>
        ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now, on to our dungeon generator.</p>
<p>The original version of this tutorial put all of the dungeon generation in the <code>GameMap</code> class. In fact, this was my plan for this tutorial as well. But, as HexDecimal (author of the TCOD library) pointed out in a pull request, that&rsquo;s not very extensible. It puts a lot of code in <code>GameMap</code> where it doesn&rsquo;t necessarily belong, and the class will grow to huge proportions if you ever decide to add an alternate dungeon generator.</p>
<p>The better approach is to put our new code in a separate file, and utilize <code>GameMap</code> there. Let&rsquo;s create a new file, called <code>procgen.py</code>, which will house our procedural generator.</p>
<p>Let&rsquo;s start by creating a class which we&rsquo;ll use to create our rooms. We can call it <code>RectangularRoom</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#f92672">from</span> typing <span style="color:#f92672">import</span> Tuple


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RectangularRoom</span>:
    <span style="color:#66d9ef">def</span> __init__(self, x: int, y: int, width: int, height: int):
        self<span style="color:#f92672">.</span>x1 <span style="color:#f92672">=</span> x
        self<span style="color:#f92672">.</span>y1 <span style="color:#f92672">=</span> y
        self<span style="color:#f92672">.</span>x2 <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> width
        self<span style="color:#f92672">.</span>y2 <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> height

    <span style="color:#a6e22e">@property</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">center</span>(self) <span style="color:#f92672">-&gt;</span> Tuple[int, int]:
        center_x <span style="color:#f92672">=</span> int((self<span style="color:#f92672">.</span>x1 <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>x2) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)
        center_y <span style="color:#f92672">=</span> int((self<span style="color:#f92672">.</span>y1 <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>y2) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)

        <span style="color:#66d9ef">return</span> center_x, center_y

    <span style="color:#a6e22e">@property</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inner</span>(self) <span style="color:#f92672">-&gt;</span> Tuple[slice, slice]:
        <span style="color:#e6db74">&#34;&#34;&#34;Return the inner area of this room as a 2D array index.&#34;&#34;&#34;</span>
        <span style="color:#66d9ef">return</span> slice(self<span style="color:#f92672">.</span>x1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, self<span style="color:#f92672">.</span>x2), slice(self<span style="color:#f92672">.</span>y1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, self<span style="color:#f92672">.</span>y2)
</code></pre></div><p>The <code>__init__</code> function takes the x and y coordinates of the top left corner, and computes the bottom right corner based on the w and h parameters (width and height).</p>
<p><code>center</code> is a &ldquo;property&rdquo;, which essentially acts like a read-only variable for our <code>RectangularRoom</code> class. It describes the &ldquo;x&rdquo; and &ldquo;y&rdquo; coordinates of the center of a room. It will be useful later on.</p>
<p>The <code>inner</code> property returns two &ldquo;slices&rdquo;, which represent the inner portion of our room. This is the part that we&rsquo;ll be &ldquo;digging out&rdquo; for our room in our dungeon generator. It gives us an easy way to get the area to carve out, which we&rsquo;ll demonstrate soon.</p>
<p>We&rsquo;ll be adding more to this class shortly, but to get us started, that&rsquo;s all we need.</p>
<p>What&rsquo;s with the + 1 on <code>self.x1</code> and <code>self.y1</code>? Think about what we&rsquo;re saying when we tell our program that we want a room at coordinates (1, 1) that goes to (6, 6). You might assume that would carve out a room like this one (remember that lists are 0-indexed, so (0, 0) is a wall in this case):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">  0 1 2 3 4 5 6 7
0 # # # # # # # #
1 # . . . . . . #
2 # . . . . . . #
3 # . . . . . . #
4 # . . . . . . #
5 # . . . . . . #
6 # . . . . . . #
7 # # # # # # # #
</code></pre></div><p>That&rsquo;s all fine and good, but what happens if we put a room right next to it? Let&rsquo;s say this room starts at (7, 1) and goes to (9, 6)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">  0 1 2 3 4 5 6 7 8 9 10
0 # # # # # # # # # # #
1 # . . . . . . . . . #
2 # . . . . . . . . . #
3 # . . . . . . . . . #
4 # . . . . . . . . . #
5 # . . . . . . . . . #
6 # . . . . . . . . . #
7 # # # # # # # # # # #
</code></pre></div><p>There&rsquo;s no wall separating the two! That means that if two rooms are one right next to the other, then there won&rsquo;t be a wall between them! So long story short, our function needs to take the walls into account when digging out a room. So if we have a rectangle with coordinates x1 = 1, x2 = 6, y1 = 1, and y2 = 6, then the room should actually look like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">  0 1 2 3 4 5 6 7
0 # # # # # # # #
1 # # # # # # # #
2 # # . . . . # #
3 # # . . . . # #
4 # # . . . . # #
5 # # . . . . # #
6 # # # # # # # #
7 # # # # # # # #
</code></pre></div><p>This ensures that we&rsquo;ll always have at least a one tile wide wall between our rooms, unless we choose to create overlapping rooms. In order to accomplish this, we add + 1 to x1 and y1.</p>
<p>Before we dive into a truly procedurally generated dungeon, let&rsquo;s begin with a simple map that consists of two rooms, connected by a tunnel. We can create a new function to create our dungeon, intuitively named <code>generate_dungeon</code>, which will return a <code>GameMap</code>. As arguments, it will take the needed width and the height to create the <code>GameMap</code>, and it will utilize the <code>RectangularRoom</code> class to create the needed rooms. Here&rsquo;s what that looks like:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from typing import Tuple

<span style="color:#a6e22e">+from game_map import GameMap
</span><span style="color:#a6e22e">+import tile_types
</span><span style="color:#a6e22e"></span>

class RectangularRoom:
    def __init__(self, x: int, y: int, width: int, height: int):
        self.x1 = x
        self.y1 = y
        self.x2 = x + width
        self.y2 = y + height

    @property
    def inner(self) -&gt; Tuple[slice, slice]:
        &#34;&#34;&#34;Return the inner area of this room as a 2D array index.&#34;&#34;&#34;
        return slice(self.x1 + 1, self.x2), slice(self.y1 + 1, self.y2)


<span style="color:#a6e22e">+def generate_dungeon(map_width, map_height) -&gt; GameMap:
</span><span style="color:#a6e22e">+   dungeon = GameMap(map_width, map_height)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   room_1 = RectangularRoom(x=20, y=15, width=10, height=15)
</span><span style="color:#a6e22e">+   room_2 = RectangularRoom(x=35, y=15, width=10, height=15)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   dungeon.tiles[room_1.inner] = tile_types.floor
</span><span style="color:#a6e22e">+   dungeon.tiles[room_2.inner] = tile_types.floor
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   return dungeon
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from typing import Tuple

<span class="new-text">from game_map import GameMap
import tile_types</span>


class RectangularRoom:
    def __init__(self, x: int, y: int, width: int, height: int):
        self.x1 = x
        self.y1 = y
        self.x2 = x + width
        self.y2 = y + height

    @property
    def inner(self) -> Tuple[slice, slice]:
        """Return the inner area of this room as a 2D array index."""
        return slice(self.x1 + 1, self.x2), slice(self.y1 + 1, self.y2)


<span class="new-text">def generate_dungeon(map_width, map_height) -> GameMap:
    dungeon = GameMap(map_width, map_height)

    room_1 = RectangularRoom(x=20, y=15, width=10, height=15)
    room_2 = RectangularRoom(x=35, y=15, width=10, height=15)

    dungeon.tiles[room_1.inner] = tile_types.floor
    dungeon.tiles[room_2.inner] = tile_types.floor

    return dungeon</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now we can modify <code>main.py</code> to utilize our now <code>generate_dungeon</code> function.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">#!/usr/bin/env python3
import tcod

from engine import Engine
from entity import Entity
<span style="color:#f92672">-from game_map import GameMap
</span><span style="color:#f92672"></span>from input_handlers import EventHandler
<span style="color:#a6e22e">+from procgen import generate_dungeon
</span><span style="color:#a6e22e"></span>

def main() -&gt; None:
    ...

    entities = {npc, player}

<span style="color:#f92672">-   game_map = GameMap(map_width, map_height)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   game_map = generate_dungeon(map_width, map_height)
</span><span style="color:#a6e22e"></span>
    engine = Engine(entities=entities, event_handler=event_handler, game_map=game_map, player=player)
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>#!/usr/bin/env python3
import tcod

from engine import Engine
from entity import Entity
<span class="crossed-out-text">from game_map import GameMap</span>
from input_handlers import EventHandler
<span class="new-text">from procgen import generate_dungeon</span>


def main() -> None:
    ...

    entities = {npc, player}

    <span class="crossed-out-text">game_map = GameMap(map_width, map_height)</span>
    <span class="new-text">game_map = generate_dungeon(map_width, map_height)</span>

    engine = Engine(entities=entities, event_handler=event_handler, game_map=game_map, player=player)
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now is a good time to run your code and make sure everything works as expected. The changes we&rsquo;ve made puts two sample rooms on the map, with our player in one of them (our poor NPC is stuck in a wall though).</p>
<p><img src="/images/part-3-two-rooms.png" alt="Part 3 - Two Rooms"></p>
<p>I&rsquo;m sure you&rsquo;ve noticed already, but the rooms are not connected. What&rsquo;s the use of creating a dungeon if we&rsquo;re stuck in one room? Not to worry, let&rsquo;s write some code to generate tunnels from one room to another. Add the following function to <code>procgen.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#a6e22e">+import random
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-from typing import Tuple
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from typing import Iterator, Tuple
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+import tcod
</span><span style="color:#a6e22e"></span>
from game_map import GameMap
import tile_types

...

        ...
        return slice(self.x1 + 1, self.x2), slice(self.y1 + 1, self.y2)


<span style="color:#a6e22e">+def tunnel_between(
</span><span style="color:#a6e22e">+   start: Tuple[int, int], end: Tuple[int, int]
</span><span style="color:#a6e22e">+) -&gt; Iterator[Tuple[int, int]]:
</span><span style="color:#a6e22e">+   &#34;&#34;&#34;Return an L-shaped tunnel between these two points.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+   x1, y1 = start
</span><span style="color:#a6e22e">+   x2, y2 = end
</span><span style="color:#a6e22e">+   if random.random() &lt; 0.5:  # 50% chance.
</span><span style="color:#a6e22e">+       # Move horizontally, then vertically.
</span><span style="color:#a6e22e">+       corner_x, corner_y = x2, y1
</span><span style="color:#a6e22e">+   else:
</span><span style="color:#a6e22e">+       # Move vertically, then horizontally.
</span><span style="color:#a6e22e">+       corner_x, corner_y = x1, y2
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   # Generate the coordinates for this tunnel.
</span><span style="color:#a6e22e">+   for x, y in tcod.los.bresenham((x1, y1), (corner_x, corner_y)).tolist():
</span><span style="color:#a6e22e">+       yield x, y
</span><span style="color:#a6e22e">+   for x, y in tcod.los.bresenham((corner_x, corner_y), (x2, y2)).tolist():
</span><span style="color:#a6e22e">+       yield x, y
</span><span style="color:#a6e22e"></span>

def generate_dungeon(map_width, map_height) -&gt; GameMap:
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="new-text">import random</span>
<span class="crossed-out-text">from typing import Tuple</span>
<span class="new-text">from typing import Iterator, Tuple</span>

<span class="new-text">import tcod</span>

from game_map import GameMap
import tile_types

...

        ...
        return slice(self.x1 + 1, self.x2), slice(self.y1 + 1, self.y2)


<span class="new-text">def tunnel_between(
    start: Tuple[int, int], end: Tuple[int, int]
) -> Iterator[Tuple[int, int]]:
    """Return an L-shaped tunnel between these two points."""
    x1, y1 = start
    x2, y2 = end
    if random.random() < 0.5:  # 50% chance.
        # Move horizontally, then vertically.
        corner_x, corner_y = x2, y1
    else:
        # Move vertically, then horizontally.
        corner_x, corner_y = x1, y2

    # Generate the coordinates for this tunnel.
    for x, y in tcod.los.bresenham((x1, y1), (corner_x, corner_y)).tolist():
        yield x, y
    for x, y in tcod.los.bresenham((corner_x, corner_y), (x2, y2)).tolist():
        yield x, y</span>


def generate_dungeon(map_width, map_height) -> GameMap:
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Let&rsquo;s dive into this method.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">tunnel_between</span>(
    start: Tuple[int, int], end: Tuple[int, int]
) <span style="color:#f92672">-&gt;</span> Iterator[Tuple[int, int]]:
</code></pre></div><p>The function takes two arguments, both Tuples consisting of two integers. It should return an Iterator of a Tuple of two ints. All the Tuples will be &ldquo;x&rdquo; and &ldquo;y&rdquo; coordinates on the map.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">    <span style="color:#e6db74">&#34;&#34;&#34;Return an L-shaped tunnel between these two points.&#34;&#34;&#34;</span>
    x1, y1 <span style="color:#f92672">=</span> start
    x2, y2 <span style="color:#f92672">=</span> end
</code></pre></div><p>We grab the coordinates out of the Tuples. Simple enough.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">    <span style="color:#66d9ef">if</span> random<span style="color:#f92672">.</span>random() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.5</span>:  <span style="color:#75715e"># 50% chance.</span>
        <span style="color:#75715e"># Move horizontally, then vertically.</span>
        corner_x, corner_y <span style="color:#f92672">=</span> x2, y1
    <span style="color:#66d9ef">else</span>:
        <span style="color:#75715e"># Move vertically, then horizontally.</span>
        corner_x, corner_y <span style="color:#f92672">=</span> x1, y2
</code></pre></div><p>We&rsquo;re randomly picking between two options: Moving horizontally, then vertically, or the opposite. Based on what&rsquo;s chosen, we&rsquo;ll set the <code>corner_x</code> and <code>corner_y</code> values to different points.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">    <span style="color:#75715e"># Generate the coordinates for this tunnel.</span>
    <span style="color:#66d9ef">for</span> x, y <span style="color:#f92672">in</span> tcod<span style="color:#f92672">.</span>los<span style="color:#f92672">.</span>bresenham((x1, y1), (corner_x, corner_y))<span style="color:#f92672">.</span>tolist():
        <span style="color:#66d9ef">yield</span> x, y
    <span style="color:#66d9ef">for</span> x, y <span style="color:#f92672">in</span> tcod<span style="color:#f92672">.</span>los<span style="color:#f92672">.</span>bresenham((corner_x, corner_y), (x2, y2))<span style="color:#f92672">.</span>tolist():
        <span style="color:#66d9ef">yield</span> x, y
</code></pre></div><p>This part is where the &ldquo;magic&rdquo; happens.</p>
<p>tcod includes a function in its line-of-sight module to draw <a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Bresenham lines</a>. While we&rsquo;re not working with line-of-sight in this case, the function still proves useful to get a line from one point to another. In this case, we get one line, then another, to create an &ldquo;L&rdquo; shaped tunnel. <code>.tolist()</code> converts the points in the line into, as you might have already guessed, a list.</p>
<p>What&rsquo;s with the <code>yield</code> lines though? <a href="https://docs.python.org/3.5/reference/expressions.html#yield-expressions">Yield expressions</a> are an interesting part of Python, which allows you to return a &ldquo;generator&rdquo;. Essentially, rather than returning the values and exiting the function altogether, we return the values, but keep the local state. This allows the function to pick up where it left off when called again, instead of starting from the beginning, as most functions do.</p>
<p>Why is this helpful? In the next section, we&rsquo;re going to iterate the <code>x</code> and <code>y</code> values that we receive from the <code>tunnel_between</code> function to dig out our tunnel.</p>
<p>Let&rsquo;s put this code to use by drawing a tunnel between our two rooms.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...
    dungeon.tiles[room_2.inner] = tile_types.floor

<span style="color:#a6e22e">+   for x, y in tunnel_between(room_2.center, room_1.center):
</span><span style="color:#a6e22e">+       dungeon.tiles[x, y] = tile_types.floor
</span><span style="color:#a6e22e"></span>
    return dungeon
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    ...
    dungeon.tiles[room_2.inner] = tile_types.floor

    <span class="new-text">for x, y in tunnel_between(room_2.center, room_1.center):
        dungeon.tiles[x, y] = tile_types.floor</span>

    return dungeon</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Run the project, and you&rsquo;ll see a horizontal tunnel that connects the two rooms. It&rsquo;s starting to come together!</p>
<p><img src="/images/part-3-two-rooms-connected.png" alt="Part 3 - Two Rooms"></p>
<p>Now that we&rsquo;ve demonstrated to ourselves that our room and tunnel functions work as intended, it&rsquo;s time to move on to an actual dungeon generation algorithm. Ours will be fairly simple; we&rsquo;ll place rooms one at a time, making sure they don&rsquo;t overlap, and connect them with tunnels.</p>
<p>We&rsquo;ll want a method that tells us if our room is intersecting with another room. Enter the following into the <code>RectangularRoom</code> class:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#a6e22e">+from __future__ import annotations
</span><span style="color:#a6e22e"></span>
import random
from typing import Iterator, Tuple

import tcod

from game_map import GameMap
import tile_types


class RectangularRoom:
    def __init__(self, x: int, y: int, width: int, height: int):
        self.x1 = x
        self.y1 = y
        self.x2 = x + width
        self.y2 = y + height

    @property
    def center(self) -&gt; Tuple[int, int]:
        center_x = int((self.x1 + self.x2) / 2)
        center_y = int((self.y1 + self.y2) / 2)

        return center_x, center_y

    @property
    def inner(self) -&gt; Tuple[slice, slice]:
        &#34;&#34;&#34;Return the inner area of this room as a 2D array index.&#34;&#34;&#34;
        return slice(self.x1 + 1, self.x2), slice(self.y1 + 1, self.y2)

<span style="color:#a6e22e">+   def intersects(self, other: RectangularRoom) -&gt; bool:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Return True if this room overlaps with another RectangularRoom.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       return (
</span><span style="color:#a6e22e">+           self.x1 &lt;= other.x2
</span><span style="color:#a6e22e">+           and self.x2 &gt;= other.x1
</span><span style="color:#a6e22e">+           and self.y1 &lt;= other.y2
</span><span style="color:#a6e22e">+           and self.y2 &gt;= other.y1
</span><span style="color:#a6e22e">+       )
</span><span style="color:#a6e22e"></span>

def tunnel_between(
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="new-text">from __future__ import annotations</span>

import random
from typing import Iterator, Tuple

import tcod

from game_map import GameMap
import tile_types


class RectangularRoom:
    def __init__(self, x: int, y: int, width: int, height: int):
        self.x1 = x
        self.y1 = y
        self.x2 = x + width
        self.y2 = y + height

    @property
    def center(self) -> Tuple[int, int]:
        center_x = int((self.x1 + self.x2) / 2)
        center_y = int((self.y1 + self.y2) / 2)

        return center_x, center_y

    @property
    def inner(self) -> Tuple[slice, slice]:
        """Return the inner area of this room as a 2D array index."""
        return slice(self.x1 + 1, self.x2), slice(self.y1 + 1, self.y2)

    <span class="new-text">def intersects(self, other: RectangularRoom) -> bool:
        """Return True if this room overlaps with another RectangularRoom."""
        return (
            self.x1 <= other.x2
            and self.x2 >= other.x1
            and self.y1 <= other.y2
            and self.y2 >= other.y1
        )</span>


def tunnel_between(
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p><code>intersects</code> checks if the room and another room (<code>other</code> in the arguments) intersect or not. It returns <code>True</code> if the do, <code>False</code> if they don&rsquo;t. We&rsquo;ll use this to determine if two rooms are overlapping or not.</p>
<p>We&rsquo;re going to need a few variables to set the maximum and minimum size of the rooms, along with the maximum number of rooms one floor can have. Add the following to <code>main.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...
    map_height = 45

<span style="color:#a6e22e">+   room_max_size = 10
</span><span style="color:#a6e22e">+   room_min_size = 6
</span><span style="color:#a6e22e">+   max_rooms = 30
</span><span style="color:#a6e22e"></span>
    tileset = tcod.tileset.load_tilesheet(
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    ...
    map_height = 45

    <span class="new-text">room_max_size = 10
    room_min_size = 6
    max_rooms = 30</span>

    tileset = tcod.tileset.load_tilesheet(
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>At long last, it&rsquo;s time to modify <code>generate_dungeon</code> to, well, generate our dungeon! You can completely remove our old implementation and replace it with the following:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from __future__ import annotations

import random
<span style="color:#f92672">-from typing import Iterator, Tuple
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from typing import Iterator, List, Tuple, TYPE_CHECKING
</span><span style="color:#a6e22e"></span>
from game_map import GameMap
import tile_types


<span style="color:#a6e22e">+if TYPE_CHECKING:
</span><span style="color:#a6e22e">+   from entity import Entity
</span><span style="color:#a6e22e"></span>
...

<span style="color:#f92672">-def generate_dungeon(map_width, map_height) -&gt; GameMap:
</span><span style="color:#f92672">-   dungeon = GameMap(map_width, map_height)
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-   room_1 = RectangularRoom(x=20, y=15, width=10, height=15)
</span><span style="color:#f92672">-   room_2 = RectangularRoom(x=35, y=15, width=10, height=15)
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-   dungeon.tiles[room_1.inner] = tile_types.floor
</span><span style="color:#f92672">-   dungeon.tiles[room_2.inner] = tile_types.floor
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-   create_horizontal_tunnel(dungeon, 25, 40, 23)
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-   return dungeon
</span><span style="color:#f92672"></span>

<span style="color:#a6e22e">+def generate_dungeon(
</span><span style="color:#a6e22e">+   max_rooms: int,
</span><span style="color:#a6e22e">+   room_min_size: int,
</span><span style="color:#a6e22e">+   room_max_size: int,
</span><span style="color:#a6e22e">+   map_width: int,
</span><span style="color:#a6e22e">+   map_height: int,
</span><span style="color:#a6e22e">+   player: Entity,
</span><span style="color:#a6e22e">+) -&gt; GameMap:
</span><span style="color:#a6e22e">+   &#34;&#34;&#34;Generate a new dungeon map.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+   dungeon = GameMap(map_width, map_height)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   rooms: List[RectangularRoom] = []
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   for r in range(max_rooms):
</span><span style="color:#a6e22e">+       room_width = random.randint(room_min_size, room_max_size)
</span><span style="color:#a6e22e">+       room_height = random.randint(room_min_size, room_max_size)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       x = random.randint(0, dungeon.width - room_width - 1)
</span><span style="color:#a6e22e">+       y = random.randint(0, dungeon.height - room_height - 1)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       # &#34;RectangularRoom&#34; class makes rectangles easier to work with
</span><span style="color:#a6e22e">+       new_room = RectangularRoom(x, y, room_width, room_height)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       # Run through the other rooms and see if they intersect with this one.
</span><span style="color:#a6e22e">+       if any(new_room.intersects(other_room) for other_room in rooms):
</span><span style="color:#a6e22e">+           continue  # This room intersects, so go to the next attempt.
</span><span style="color:#a6e22e">+       # If there are no intersections then the room is valid.
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       # Dig out this rooms inner area.
</span><span style="color:#a6e22e">+       dungeon.tiles[new_room.inner] = tile_types.floor
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       if len(rooms) == 0:
</span><span style="color:#a6e22e">+           # The first room, where the player starts.
</span><span style="color:#a6e22e">+           player.x, player.y = new_room.center
</span><span style="color:#a6e22e">+       else:  # All rooms after the first.
</span><span style="color:#a6e22e">+           # Dig out a tunnel between this room and the previous one.
</span><span style="color:#a6e22e">+           for x, y in tunnel_between(rooms[-1].center, new_room.center):
</span><span style="color:#a6e22e">+               dungeon.tiles[x, y] = tile_types.floor
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       # Finally, append the new room to the list.
</span><span style="color:#a6e22e">+       rooms.append(new_room)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   return dungeon
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from __future__ import annotations

import random
<span class="crossed-out-text">from typing import Iterator, Tuple</span>
<span class="new-text">from typing import Iterator, List, Tuple, TYPE_CHECKING</span>

from game_map import GameMap
import tile_types


<span class="new-text">if TYPE_CHECKING:
    from entity import Entity</span>

...

<span class="crossed-out-text">def generate_dungeon(map_width, map_height) -> GameMap:</span>
    <span class="crossed-out-text">dungeon = GameMap(map_width, map_height)</span>

    <span class="crossed-out-text">room_1 = RectangularRoom(x=20, y=15, width=10, height=15)</span>
    <span class="crossed-out-text">room_2 = RectangularRoom(x=35, y=15, width=10, height=15)</span>

    <span class="crossed-out-text">dungeon.tiles[room_1.inner] = tile_types.floor</span>
    <span class="crossed-out-text">dungeon.tiles[room_2.inner] = tile_types.floor</span>

    <span class="crossed-out-text">create_horizontal_tunnel(dungeon, 25, 40, 23)</span>

    <span class="crossed-out-text">return dungeon</span>


<span class="new-text">def generate_dungeon(
    max_rooms: int,
    room_min_size: int,
    room_max_size: int,
    map_width: int,
    map_height: int,
    player: Entity,
) -> GameMap:
    """Generate a new dungeon map."""
    dungeon = GameMap(map_width, map_height)

    rooms: List[RectangularRoom] = []

    for r in range(max_rooms):
        room_width = random.randint(room_min_size, room_max_size)
        room_height = random.randint(room_min_size, room_max_size)

        x = random.randint(0, dungeon.width - room_width - 1)
        y = random.randint(0, dungeon.height - room_height - 1)

        # "RectangularRoom" class makes rectangles easier to work with
        new_room = RectangularRoom(x, y, room_width, room_height)

        # Run through the other rooms and see if they intersect with this one.
        if any(new_room.intersects(other_room) for other_room in rooms):
            continue  # This room intersects, so go to the next attempt.
        # If there are no intersections then the room is valid.

        # Dig out this rooms inner area.
        dungeon.tiles[new_room.inner] = tile_types.floor

        if len(rooms) == 0:
            # The first room, where the player starts.
            player.x, player.y = new_room.center
        else:  # All rooms after the first.
            # Dig out a tunnel between this room and the previous one.
            for x, y in tunnel_between(rooms[-1].center, new_room.center):
                dungeon.tiles[x, y] = tile_types.floor

        # Finally, append the new room to the list.
        rooms.append(new_room)

    return dungeon</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>That&rsquo;s quite a lengthy function! Let&rsquo;s break it down and figure out what&rsquo;s doing what.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generate_dungeon</span>(
    max_rooms: int,
    room_min_size: int,
    room_max_size: int,
    map_width: int,
    map_height: int,
    player: Entity,
) <span style="color:#f92672">-&gt;</span> GameMap:
</code></pre></div><p>This is the function definition itself. We pass several arguments to it.</p>
<ul>
<li><code>max_rooms</code>: The maximum number of rooms allowed in the dungeon. We&rsquo;ll use this to control our iteration.</li>
<li><code>room_min_size</code>: The minimum size of one room.</li>
<li><code>room_max_size</code>: The maximum size of one room. We&rsquo;ll pick a random size between this and <code>room_min_size</code> for both the width and the height of one room to carve out.</li>
<li><code>map_width</code> and <code>map_height</code>: The width and height of the <code>GameMap</code> to create. This is no different than it was before.</li>
<li><code>player</code>: The player Entity. We need this to know where to place the player.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">    <span style="color:#e6db74">&#34;&#34;&#34;Generate a new dungeon map.&#34;&#34;&#34;</span>
    dungeon <span style="color:#f92672">=</span> GameMap(map_width, map_height)
</code></pre></div><p>This isn&rsquo;t anything new, we&rsquo;re just creating the initial <code>GameMap</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">    rooms: List[RectangularRoom] <span style="color:#f92672">=</span> []
</code></pre></div><p>We&rsquo;ll keep a running list of all the rooms.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">    <span style="color:#66d9ef">for</span> r <span style="color:#f92672">in</span> range(max_rooms):
</code></pre></div><p>We iterate from 0 to <code>max_rooms</code> - 1. Our algorithm may or may not place a room depending on if it intersects with another, so we won&rsquo;t know how many rooms we&rsquo;re going to end up with. But at least we&rsquo;ll know that number can&rsquo;t exceed a certain amount.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">        room_width <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>randint(room_min_size, room_max_size)
        room_height <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>randint(room_min_size, room_max_size)

        x <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">0</span>, dungeon<span style="color:#f92672">.</span>width <span style="color:#f92672">-</span> room_width <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
        y <span style="color:#f92672">=</span> random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">0</span>, dungeon<span style="color:#f92672">.</span>height <span style="color:#f92672">-</span> room_height <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)

        <span style="color:#75715e"># &#34;RectangularRoom&#34; class makes rectangles easier to work with</span>
        new_room <span style="color:#f92672">=</span> RectangularRoom(x, y, room_width, room_height)
</code></pre></div><p>Here, we use the given minimum and maximum room sizes to set the room&rsquo;s width and height. We then get a random pair of <code>x</code> and <code>y</code> coordinates to try and place the room down. The coordinates must be between 0 and the map&rsquo;s width and heights.</p>
<p>We use these variables to then create an instance of our <code>RectangularRoom</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">        <span style="color:#75715e"># Run through the other rooms and see if they intersect with this one.</span>
        <span style="color:#66d9ef">if</span> any(new_room<span style="color:#f92672">.</span>intersects(other_room) <span style="color:#66d9ef">for</span> other_room <span style="color:#f92672">in</span> rooms):
            <span style="color:#66d9ef">continue</span>  <span style="color:#75715e"># This room intersects, so go to the next attempt.</span>
</code></pre></div><p>So what happens if a room <em>does</em> intersect with another? In that case, we can just toss it out, by using <code>continue</code> to skip the rest of the loop. Obviously there are more elegant ways of dealing with a collision, but for our simplistic algorithm, we&rsquo;ll just pretend like it didn&rsquo;t happen and try the next one.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">        <span style="color:#75715e"># If there are no intersections then the room is valid.</span>

        <span style="color:#75715e"># Dig out this rooms inner area.</span>
        dungeon<span style="color:#f92672">.</span>tiles[new_room<span style="color:#f92672">.</span>inner] <span style="color:#f92672">=</span> tile_types<span style="color:#f92672">.</span>floor
</code></pre></div><p>Here, we &ldquo;dig&rdquo; the room out. This is similar to what we were doing before to dig out the two connected rooms.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">        <span style="color:#66d9ef">if</span> len(rooms) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#75715e"># The first room, where the player starts.</span>
            player<span style="color:#f92672">.</span>x, player<span style="color:#f92672">.</span>y <span style="color:#f92672">=</span> new_room<span style="color:#f92672">.</span>center
</code></pre></div><p>We put our player down in the center of the first room we created. If this room isn&rsquo;t the first, we move on to the <code>else</code> statement:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">        <span style="color:#66d9ef">else</span>:  <span style="color:#75715e"># All rooms after the first.</span>
            <span style="color:#75715e"># Dig out a tunnel between this room and the previous one.</span>
            <span style="color:#66d9ef">for</span> x, y <span style="color:#f92672">in</span> tunnel_between(rooms[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>center, new_room<span style="color:#f92672">.</span>center):
                dungeon<span style="color:#f92672">.</span>tiles[x, y] <span style="color:#f92672">=</span> tile_types<span style="color:#f92672">.</span>floor
</code></pre></div><p>This is similar to how we dug the tunnel before, except this time, we&rsquo;re using a negative index with <code>rooms</code> to grab the previous room, and connecting the new room to it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">        <span style="color:#75715e"># Finally, append the new room to the list.</span>
        rooms<span style="color:#f92672">.</span>append(new_room)
</code></pre></div><p>Regardless if it&rsquo;s the first room or not, we want to append it to the list, so the next iteration can use it.</p>
<p>So that&rsquo;s our <code>generate_dungeon</code> function, but we&rsquo;re not quite finished yet. We need to modify the call we make to this function in <code>main.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...
    entities = {npc, player}

<span style="color:#f92672">-   game_map = generate_dungeon(map_width, map_height)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   game_map = generate_dungeon(
</span><span style="color:#a6e22e">+       max_rooms=max_rooms,
</span><span style="color:#a6e22e">+       room_min_size=room_min_size,
</span><span style="color:#a6e22e">+       room_max_size=room_max_size,
</span><span style="color:#a6e22e">+       map_width=map_width,
</span><span style="color:#a6e22e">+       map_height=map_height,
</span><span style="color:#a6e22e">+       player=player
</span><span style="color:#a6e22e">+   )
</span><span style="color:#a6e22e"></span>
    engine = Engine(entities=entities, event_handler=event_handler, game_map=game_map, player=player)
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    ...
    entities = {npc, player}

    <span class="crossed-out-text">game_map = generate_dungeon(map_width, map_height)</span>
    <span class="new-text">game_map = generate_dungeon(
        max_rooms=max_rooms,
        room_min_size=room_min_size,
        room_max_size=room_max_size,
        map_width=map_width,
        map_height=map_height,
        player=player
    )</span>

    engine = Engine(entities=entities, event_handler=event_handler, game_map=game_map, player=player)
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>And that&rsquo;s it! There&rsquo;s our functioning, albeit basic, dungeon generation algorithm. Run the project now and you should be placed in a procedurally generated dungeon! Note that our NPC isn&rsquo;t being placed intelligently here, so it may or may not be stuck in a wall.</p>
<p><img src="/images/part-3-dungeon.png" alt="Part 3 - Generated Dungeon"></p>
<p><em>Note: Your dungeon will look different from this one, so don&rsquo;t worry if it doesn&rsquo;t match the screenshot.</em></p>
<p>If you want to see the code so far in its entirety, <a href="https://github.com/TStand90/tcod_tutorial_v2/tree/2020/part-3">click
here</a>.</p>
<p><a href="/tutorials/tcod/v2/part-4">Click here to move on to the next part of this
tutorial.</a></p>


    

    


</article>



        </div>

        <aside class="col-12 col-lg-3 ml-auto blog-sidebar">
    
    
        <section>
    
        
    
        
    
</section>
    
</aside>

      </div>
    </div>
    

    
      







<footer class="blog-footer w-100">
    <nav class="navbar navbar-light bg-light">
        <p class="w-100 text-center">Last updated July 7th, 2020</p>
        <p class="w-100 text-center"><a href="#">Back to top</a></p>
    </nav>
</footer>

    

    
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
