<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Part 4 - Field of View" />
<meta property="og:description" content="We have a dungeon now, and we can move about it freely. But are we really exploring the dungeon if we can just see it all from the beginning?
Most roguelikes (not all!) only let you see within a certain range of your character, and ours will be no different. We need to implement a way to calculate the &ldquo;Field of View&rdquo; for our adventurer, and fortunately, tcod makes that easy!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rogueliketutorials.com/tutorials/tcod/v2/part-4/" /><meta property="article:section" content="tutorials" />
<meta property="article:published_time" content="2020-06-29T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-06-29T00:00:00&#43;00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Part 4 - Field of View"/>
<meta name="twitter:description" content="We have a dungeon now, and we can move about it freely. But are we really exploring the dungeon if we can just see it all from the beginning?
Most roguelikes (not all!) only let you see within a certain range of your character, and ours will be no different. We need to implement a way to calculate the &ldquo;Field of View&rdquo; for our adventurer, and fortunately, tcod makes that easy!"/>



    <link rel="canonical" href="https://rogueliketutorials.com/tutorials/tcod/v2/part-4/">

    <title>
      
        Part 4 - Field of View | Roguelike Tutorials
      
    </title>

    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="https://rogueliketutorials.com/css/style.css" rel="stylesheet">

    

    

    
  </head>
  <body>
    
      

<header class="blog-header">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <a class="navbar-brand" href="/">
            Roguelike Tutorials
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-between" id="navbarNav">
            <ul class="navbar-nav">
                
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/">Home</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutorials/tcod/2019/">TCOD Tutorial (2019)</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutorials/tcod/v2/">TCOD Tutorial (2020)</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/about/">About</a>
                    
                </li>
                
            </ul>
            
        </div>
    </nav>
</header>

    

    
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-8 blog-main">

          

<header>
    <h2 class="blog-post-title">
    <a class="text-dark" href="/tutorials/tcod/v2/part-4/">Part 4 - Field of View</a>
</h2>

    


<div class="blog-post-date text-secondary">
    
        <time datetime="2020-06-29">Jun 29, 2020</time>
    
    
</div>

    
    
    <hr>
</header>
<article class="blog-post">
    <p>We have a dungeon now, and we can move about it freely. But are we
really <em>exploring</em> the dungeon if we can just see it all from the
beginning?</p>
<p>Most roguelikes (not all!) only let you see within a certain range of
your character, and ours will be no different. We need to implement a way
to calculate the &ldquo;Field of View&rdquo; for our adventurer, and fortunately,
tcod makes that easy!</p>
<p>When walking around the dungeon, there will essentially be three &ldquo;states&rdquo; a tile can be in, relating to our field of view.</p>
<ol>
<li>Visible</li>
<li>Not visible</li>
<li>Not visible, but previously seen</li>
</ol>
<p>What this means is that we should draw the &ldquo;visible&rdquo; tiles as well as the &ldquo;not visible, but previously seen&rdquo; ones to the screen, but differentiate them somehow. The &ldquo;not visible&rdquo; tiles can simply be drawn as an empty tile, with the color black, gray, or whatever you want to use.</p>
<p>In order to differentiate between these tiles, we&rsquo;ll need two new Numpy arrays: One to keep track of the tiles that are currently visible, and another to keep track of all the tiles that our character has seen before. Add the two arrays to <code>GameMap</code> like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class GameMap:
    def __init__(self, width: int, height: int):
        self.width, self.height = width, height
        self.tiles = np.full((width, height), fill_value=tile_types.wall, order=&#34;F&#34;)

<span style="color:#a6e22e">+       self.visible = np.full((width, height), fill_value=False, order=&#34;F&#34;)  # Tiles the player can currently see
</span><span style="color:#a6e22e">+       self.explored = np.full((width, height), fill_value=False, order=&#34;F&#34;)  # Tiles the player has seen before
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class GameMap:
    def __init__(self, width: int, height: int):
        self.width, self.height = width, height
        self.tiles = np.full((width, height), fill_value=tile_types.wall, order="F")

        <span class="new-text">self.visible = np.full((width, height), fill_value=False, order="F")  # Tiles the player can currently see
        self.explored = np.full((width, height), fill_value=False, order="F")  # Tiles the player has seen before</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>We create two arrays, <code>visible</code> and <code>explored</code>, and fill them with the value <code>False</code>. In a moment, we&rsquo;ll create a function that will update these arrays based on what&rsquo;s in the field of view.</p>
<p>Let&rsquo;s turn our attention back to the tile types. Remember when we specified the &ldquo;walkable&rdquo;, &ldquo;transparent&rdquo;, and &ldquo;dark&rdquo; attributes? We called it &ldquo;dark&rdquo; because it&rsquo;s what the tile will look like when its not in the field of view, but what about when it <em>is</em>?</p>
<p>For that, we&rsquo;ll want a new <code>graphic_dt</code> in the <code>tile_dt</code> type, called <code>light</code>. We can add that by modifying <code>tile_types.py</code> like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">tile_dt = np.dtype(
    [
        (&#34;walkable&#34;, np.bool),  # True if this tile can be walked over.
        (&#34;transparent&#34;, np.bool),  # True if this tile doesn&#39;t block FOV.
        (&#34;dark&#34;, graphic_dt),  # Graphics for when this tile is not in FOV.
<span style="color:#a6e22e">+       (&#34;light&#34;, graphic_dt),  # Graphics for when the tile is in FOV.
</span><span style="color:#a6e22e"></span>    ]
)


def new_tile(
    *,  # Enforce the use of keywords, so that parameter order doesn&#39;t matter.
    walkable: int,
    transparent: int,
    dark: Tuple[int, Tuple[int, int, int], Tuple[int, int, int]],
<span style="color:#a6e22e">+   light: Tuple[int, Tuple[int, int, int], Tuple[int, int, int]],
</span><span style="color:#a6e22e"></span>) -&gt; np.ndarray:
    &#34;&#34;&#34;Helper function for defining individual tile types &#34;&#34;&#34;
<span style="color:#f92672">-   return np.array((walkable, transparent, dark), dtype=tile_dt)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   return np.array((walkable, transparent, dark, light), dtype=tile_dt)
</span><span style="color:#a6e22e"></span>

<span style="color:#a6e22e">+# SHROUD represents unexplored, unseen tiles
</span><span style="color:#a6e22e">+SHROUD = np.array((ord(&#34; &#34;), (255, 255, 255), (0, 0, 0)), dtype=graphic_dt)
</span><span style="color:#a6e22e"></span>
floor = new_tile(
<span style="color:#f92672">-   walkable=True, transparent=True, dark=(ord(&#34; &#34;), (255, 255, 255), (50, 50, 150)),
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   walkable=True,
</span><span style="color:#a6e22e">+   transparent=True,
</span><span style="color:#a6e22e">+   dark=(ord(&#34; &#34;), (255, 255, 255), (50, 50, 150)),
</span><span style="color:#a6e22e">+   light=(ord(&#34; &#34;), (255, 255, 255), (200, 180, 50)),
</span><span style="color:#a6e22e"></span>)
wall = new_tile(
<span style="color:#f92672">-   walkable=False, transparent=False, dark=(ord(&#34; &#34;), (255, 255, 255), (0, 0, 100)),
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   walkable=False,
</span><span style="color:#a6e22e">+   transparent=False,
</span><span style="color:#a6e22e">+   dark=(ord(&#34; &#34;), (255, 255, 255), (0, 0, 100)),
</span><span style="color:#a6e22e">+   light=(ord(&#34; &#34;), (255, 255, 255), (130, 110, 50)),
</span><span style="color:#a6e22e"></span>)
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>tile_dt = np.dtype(
    [
        ("walkable", np.bool),  # True if this tile can be walked over.
        ("transparent", np.bool),  # True if this tile doesn't block FOV.
        ("dark", graphic_dt),  # Graphics for when this tile is not in FOV.
        <span class="new-text">("light", graphic_dt),  # Graphics for when the tile is in FOV.</span>
    ]
)


def new_tile(
    *,  # Enforce the use of keywords, so that parameter order doesn't matter.
    walkable: int,
    transparent: int,
    dark: Tuple[int, Tuple[int, int, int], Tuple[int, int, int]],
    <span class="new-text">light: Tuple[int, Tuple[int, int, int], Tuple[int, int, int]],</span>
) -> np.ndarray:
    """Helper function for defining individual tile types """
    <span class="crossed-out-text">return np.array((walkable, transparent, dark), dtype=tile_dt)</span>
    <span class="new-text">return np.array((walkable, transparent, dark, light), dtype=tile_dt)</span>


<span class="new-text"># SHROUD represents unexplored, unseen tiles
SHROUD = np.array((ord(" "), (255, 255, 255), (0, 0, 0)), dtype=graphic_dt)</span>

floor = new_tile(
    <span class="crossed-out-text">walkable=True, transparent=True, dark=(ord(" "), (255, 255, 255), (50, 50, 150)),</span>
    <span class="new-text">walkable=True,
    transparent=True,
    dark=(ord(" "), (255, 255, 255), (50, 50, 150)),
    light=(ord(" "), (255, 255, 255), (200, 180, 50)),</span>
)
wall = new_tile(
    <span class="crossed-out-text">walkable=False, transparent=False, dark=(ord(" "), (255, 255, 255), (0, 0, 100)),</span>
    <span class="new-text">walkable=False,
    transparent=False,
    dark=(ord(" "), (255, 255, 255), (0, 0, 100)),
    light=(ord(" "), (255, 255, 255), (130, 110, 50)),</span>
)</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Let&rsquo;s go through the new additions.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">tile_dt <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>dtype(
    [
        (<span style="color:#e6db74">&#34;walkable&#34;</span>, np<span style="color:#f92672">.</span>bool),  <span style="color:#75715e"># True if this tile can be walked over.</span>
        (<span style="color:#e6db74">&#34;transparent&#34;</span>, np<span style="color:#f92672">.</span>bool),  <span style="color:#75715e"># True if this tile doesn&#39;t block FOV.</span>
        (<span style="color:#e6db74">&#34;dark&#34;</span>, graphic_dt),  <span style="color:#75715e"># Graphics for when this tile is not in FOV.</span>
        (<span style="color:#e6db74">&#34;light&#34;</span>, graphic_dt),  <span style="color:#75715e"># Graphics for when the tile is in FOV.</span>
    ]
)
</code></pre></div><p>We&rsquo;re adding a new <code>graphic_dt</code> to the <code>tile_dt</code> that we use to define our tiles. <code>light</code> will hold the information about what our tile looks like when it&rsquo;s in the field of view.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">new_tile</span>(
    <span style="color:#f92672">*</span>,  <span style="color:#75715e"># Enforce the use of keywords, so that parameter order doesn&#39;t matter.</span>
    walkable: int,
    transparent: int,
    dark: Tuple[int, Tuple[int, int, int], Tuple[int, int, int]],
    light: Tuple[int, Tuple[int, int, int], Tuple[int, int, int]],
) <span style="color:#f92672">-&gt;</span> np<span style="color:#f92672">.</span>ndarray:
    <span style="color:#e6db74">&#34;&#34;&#34;Helper function for defining individual tile types &#34;&#34;&#34;</span>
    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>array((walkable, transparent, dark, light), dtype<span style="color:#f92672">=</span>tile_dt)
</code></pre></div><p>We&rsquo;ve modified the <code>new_tile</code> function to account for the new <code>light</code> attribute. <code>light</code> works the same as <code>dark</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#75715e"># SHROUD represents unexplored, unseen tiles</span>
SHROUD <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array((ord(<span style="color:#e6db74">&#34; &#34;</span>), (<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>), (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)), dtype<span style="color:#f92672">=</span>graphic_dt)
</code></pre></div><p><code>SHROUD</code> is what we&rsquo;ll use for when a tile is neither in view nor has been &ldquo;explored&rdquo;. It&rsquo;s set to just draw a black tile.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">floor <span style="color:#f92672">=</span> new_tile(
    walkable<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>,
    transparent<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>,
    dark<span style="color:#f92672">=</span>(ord(<span style="color:#e6db74">&#34; &#34;</span>), (<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>), (<span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">150</span>)),
    light<span style="color:#f92672">=</span>(ord(<span style="color:#e6db74">&#34; &#34;</span>), (<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>), (<span style="color:#ae81ff">200</span>, <span style="color:#ae81ff">180</span>, <span style="color:#ae81ff">50</span>)),
)
wall <span style="color:#f92672">=</span> new_tile(
    walkable<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>,
    transparent<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>,
    dark<span style="color:#f92672">=</span>(ord(<span style="color:#e6db74">&#34; &#34;</span>), (<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>), (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">100</span>)),
    light<span style="color:#f92672">=</span>(ord(<span style="color:#e6db74">&#34; &#34;</span>), (<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>), (<span style="color:#ae81ff">130</span>, <span style="color:#ae81ff">110</span>, <span style="color:#ae81ff">50</span>)),
)
</code></pre></div><p>Finally, we add <code>light</code> to both the <code>floor</code> and <code>wall</code> tiles. We also modify the functions to fit a bit better on the screen, adding new lines after each argument. This is just for the sake of readability.</p>
<p><code>light</code> in both cases is set to a brighter color, so that when we draw the field of view to the screen, the player can easily differentiate between what&rsquo;s in view and what&rsquo;s not. As usual, feel free to play with the color schemes to match whatever you might have in mind.</p>
<p>With all that in place, we need to modify the way <code>GameMap</code> draws itself to the screen.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class GameMap:
    ...

    def render(self, console: Console) -&gt; None:
<span style="color:#f92672">-       console.tiles_rgb[0:self.width, 0:self.height] = self.tiles[&#34;dark&#34;]
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       &#34;&#34;&#34;
</span><span style="color:#a6e22e">+       Renders the map.
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       If a tile is in the &#34;visible&#34; array, then draw it with the &#34;light&#34; colors.
</span><span style="color:#a6e22e">+       If it isn&#39;t, but it&#39;s in the &#34;explored&#34; array, then draw it with the &#34;dark&#34; colors.
</span><span style="color:#a6e22e">+       Otherwise, the default is &#34;SHROUD&#34;.
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;
</span><span style="color:#a6e22e">+       console.tiles_rgb[0:self.width, 0:self.height] = np.select(
</span><span style="color:#a6e22e">+           condlist=[self.visible, self.explored],
</span><span style="color:#a6e22e">+           choicelist=[self.tiles[&#34;light&#34;], self.tiles[&#34;dark&#34;]],
</span><span style="color:#a6e22e">+           default=tile_types.SHROUD
</span><span style="color:#a6e22e">+       )
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class GameMap:
    ...

    def render(self, console: Console) -> None:
        <span class="crossed-out-text">console.tiles_rgb[0:self.width, 0:self.height] = self.tiles["dark"]</span>
        <span class="new-text">"""
        Renders the map.

        If a tile is in the "visible" array, then draw it with the "light" colors.
        If it isn't, but it's in the "explored" array, then draw it with the "dark" colors.
        Otherwise, the default is "SHROUD".
        """
        console.tiles_rgb[0:self.width, 0:self.height] = np.select(
            condlist=[self.visible, self.explored],
            choicelist=[self.tiles["light"], self.tiles["dark"]],
            default=tile_types.SHROUD
        )</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>The first part of the statement, <code>console.tiles_rgb[0:self.width, 0:self.height]</code>, hasn&rsquo;t changed. But instead of just setting it to <code>self.tiles[&quot;dark&quot;]</code>, we&rsquo;re using <code>np.select</code>.</p>
<p><code>np.select</code> allows us to conditionally draw the tiles we want, based on what&rsquo;s specified in <code>condlist</code>. Since we&rsquo;re passing <code>[self.visible, self.explored]</code>, it will check if the tile being drawn is either visible, then explored. If it&rsquo;s visible, it uses the first value in <code>choicelist</code>, in this case, <code>self.tiles[&quot;light&quot;]</code>. If it&rsquo;s not visible, but explored, then we draw <code>self.tiles[&quot;dark&quot;]</code>. If neither is true, we use the <code>default</code> argument, which is just the <code>SHROUD</code> we defined earlier.</p>
<p>If you run the project now, none of the tiles will be drawn to the screen. This is because we need a way to actually modify the <code>visible</code> and <code>explored</code> tiles. Let&rsquo;s modify <code>Engine</code> to do just that:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
from tcod.context import Context
from tcod.console import Console
<span style="color:#a6e22e">+from tcod.map import compute_fov
</span><span style="color:#a6e22e"></span>
from entity import Entity
...

class Engine:
    def __init__(self, entities: Set[Entity], event_handler: EventHandler, game_map: GameMap, player: Entity):
        self.entities = entities
        self.event_handler = event_handler
        self.game_map = game_map
        self.player = player
<span style="color:#a6e22e">+       self.update_fov()
</span><span style="color:#a6e22e"></span>
    def handle_events(self, events: Iterable[Any]) -&gt; None:
        for event in events:
            action = self.event_handler.dispatch(event)

            if action is None:
                continue

            action.perform(self, self.player)

<span style="color:#a6e22e">+           self.update_fov()  # Update the FOV before the players next action.
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def update_fov(self) -&gt; None:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Recompute the visible area based on the players point of view.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       self.game_map.visible[:] = compute_fov(
</span><span style="color:#a6e22e">+           self.game_map.tiles[&#34;transparent&#34;],
</span><span style="color:#a6e22e">+           (self.player.x, self.player.y),
</span><span style="color:#a6e22e">+           radius=8,
</span><span style="color:#a6e22e">+       )
</span><span style="color:#a6e22e">+       # If a tile is &#34;visible&#34; it should be added to &#34;explored&#34;.
</span><span style="color:#a6e22e">+       self.game_map.explored |= self.game_map.visible
</span><span style="color:#a6e22e"></span>
    def render(self, console: Console, context: Context) -&gt; None:
        self.game_map.render(console)

        for entity in self.entities:
<span style="color:#f92672">-           console.print(entity.x, entity.y, entity.char, fg=entity.color)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           # Only print entities that are in the FOV
</span><span style="color:#a6e22e">+           if self.game_map.visible[entity.x, entity.y]:
</span><span style="color:#a6e22e">+               console.print(entity.x, entity.y, entity.char, fg=entity.color)
</span><span style="color:#a6e22e"></span>
        context.present(console)

        console.clear()
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
from tcod.context import Context
from tcod.console import Console
<span class="new-text">from tcod.map import compute_fov</span>

from entity import Entity
...

class Engine:
    def __init__(self, entities: Set[Entity], event_handler: EventHandler, game_map: GameMap, player: Entity):
        self.entities = entities
        self.event_handler = event_handler
        self.game_map = game_map
        self.player = player
        <span class="new-text">self.update_fov()</span>

    def handle_events(self, events: Iterable[Any]) -> None:
        for event in events:
            action = self.event_handler.dispatch(event)

            if action is None:
                continue

            action.perform(self, self.player)

            <span class="new-text">self.update_fov()  # Update the FOV before the players next action.</span>

    <span class="new-text">def update_fov(self) -> None:
        """Recompute the visible area based on the players point of view."""
        self.game_map.visible[:] = compute_fov(
            self.game_map.tiles["transparent"],
            (self.player.x, self.player.y),
            radius=8,
        )
        # If a tile is "visible" it should be added to "explored".
        self.game_map.explored |= self.game_map.visible</span>

    def render(self, console: Console, context: Context) -> None:
        self.game_map.render(console)

        for entity in self.entities:
            <span class="crossed-out-text">console.print(entity.x, entity.y, entity.char, fg=entity.color)</span>
            <span class="new-text"># Only print entities that are in the FOV
            if self.game_map.visible[entity.x, entity.y]:
                console.print(entity.x, entity.y, entity.char, fg=entity.color)</span>

        context.present(console)

        console.clear()</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>The most important part of our additions is the <code>update_fov</code> function.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">update_fov</span>(self) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
        <span style="color:#e6db74">&#34;&#34;&#34;Recompute the visible area based on the players point of view.&#34;&#34;&#34;</span>
        self<span style="color:#f92672">.</span>game_map<span style="color:#f92672">.</span>visible[:] <span style="color:#f92672">=</span> compute_fov(
            self<span style="color:#f92672">.</span>game_map<span style="color:#f92672">.</span>tiles[<span style="color:#e6db74">&#34;transparent&#34;</span>],
            (self<span style="color:#f92672">.</span>player<span style="color:#f92672">.</span>x, self<span style="color:#f92672">.</span>player<span style="color:#f92672">.</span>y),
            radius<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>,
        )
        <span style="color:#75715e"># If a tile is &#34;visible&#34; it should be added to &#34;explored&#34;.</span>
        self<span style="color:#f92672">.</span>game_map<span style="color:#f92672">.</span>explored <span style="color:#f92672">|=</span> self<span style="color:#f92672">.</span>game_map<span style="color:#f92672">.</span>visible
</code></pre></div><p>We&rsquo;re setting the <code>game_map</code>&rsquo;s <code>visible</code> tiles to equal the result of the <code>compute_fov</code>. We&rsquo;re giving <code>compute_fov</code> three arguments, which it uses to compute our field of view.</p>
<ul>
<li><code>transparency</code>: This is the first argument, which we&rsquo;re passing <code>self.game_map.tiles[&quot;transparent&quot;]</code>. <code>transparency</code> takes a 2D numpy array, and considers any non-zero values to be transparent. This is the array it uses to calculate the field of view.</li>
<li><code>pov</code>: The origin point for the field of view, which is a 2D index. We use the player&rsquo;s x and y position here.</li>
<li><code>radius</code>: How far the FOV extends.</li>
</ul>
<p>There&rsquo;s more that this function can do, including not lighting up walls, and using different algorithms to calculate the FOV. If you&rsquo;re interested, you can find the documentation <a href="https://python-tcod.readthedocs.io/en/latest/tcod/map.html#tcod.map.compute_fov">here</a>.</p>
<p>The line <code>self.game_map.explored |= self.game_map.visible</code> sets the <code>explored</code> array to include everything in the <code>visible</code> array, plus whatever it already had. This means that any tile the player can see, the player has also &ldquo;explored.&rdquo;</p>
<p>That&rsquo;s all we need to do to update our field of view. Notice that we call the function when we initialize the <code>Engine</code> class, so that the field of view is created before the player can move, and after handling an action, so that whenever the player does move, the field of view will be updated.</p>
<p>Lastly, we modify the part that draws the entities, so that only entities in the field of view are drawn.</p>
<p>Run the project now, and you&rsquo;ll see something like this:</p>
<p><img src="/images/part-4-fov.png" alt="Part 4 - FOV" title="Field of View"></p>
<p>It&rsquo;s hard to believe, but that&rsquo;s all we need to do for a functioning field of view!</p>
<p>This chapter was a shorter one, but we&rsquo;ve accomplished quite a lot. Our dungeon feels a lot more mysterious, and in coming chapters, it will get a lot more dangerous.</p>
<p>If you want to see the code so far in its entirety, <a href="https://github.com/TStand90/tcod_tutorial_v2/tree/2020/part-4">click
here</a>.</p>
<p><a href="/tutorials/tcod/v2/part-5">Click here to move on to the next part of this
tutorial.</a></p>


    

    


</article>



        </div>

        <aside class="col-12 col-lg-3 ml-auto blog-sidebar">
    
    
        <section>
    
        
    
        
    
</section>
    
</aside>

      </div>
    </div>
    

    
      







<footer class="blog-footer w-100">
    <nav class="navbar navbar-light bg-light">
        <p class="w-100 text-center">Last updated July 7th, 2020</p>
        <p class="w-100 text-center"><a href="#">Back to top</a></p>
    </nav>
</footer>

    

    
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
