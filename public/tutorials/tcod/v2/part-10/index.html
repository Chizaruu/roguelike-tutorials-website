<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Part 10 - Saving and loading" />
<meta property="og:description" content="Saving and loading is essential to almost every roguelike, but it can be a pain to manage if you don&rsquo;t start early. By the end of this chapter, our game will be able to save and load one file to the disk, which you could easily expand to multiple saves if you wanted to.
Let&rsquo;s start by defining the colors we&rsquo;ll need this chapter, by opening color.py and entering the following:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rogueliketutorials.com/tutorials/tcod/v2/part-10/" /><meta property="article:section" content="tutorials" />
<meta property="article:published_time" content="2020-07-21T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-07-21T00:00:00&#43;00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Part 10 - Saving and loading"/>
<meta name="twitter:description" content="Saving and loading is essential to almost every roguelike, but it can be a pain to manage if you don&rsquo;t start early. By the end of this chapter, our game will be able to save and load one file to the disk, which you could easily expand to multiple saves if you wanted to.
Let&rsquo;s start by defining the colors we&rsquo;ll need this chapter, by opening color.py and entering the following:"/>



    <link rel="canonical" href="https://rogueliketutorials.com/tutorials/tcod/v2/part-10/">

    <title>
      
        Part 10 - Saving and loading | Roguelike Tutorials
      
    </title>

    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="https://rogueliketutorials.com/css/style.css" rel="stylesheet">

    

    

    
  </head>
  <body>
    
      

<header class="blog-header">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <a class="navbar-brand" href="/">
            Roguelike Tutorials
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-between" id="navbarNav">
            <ul class="navbar-nav">
                
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/">Home</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutorials/tcod/2019/">TCOD Tutorial (2019)</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutorials/tcod/v2/">TCOD Tutorial (2020)</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/about/">About</a>
                    
                </li>
                
            </ul>
            
        </div>
    </nav>
</header>

    

    
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-8 blog-main">

          

<header>
    <h2 class="blog-post-title">
    <a class="text-dark" href="/tutorials/tcod/v2/part-10/">Part 10 - Saving and loading</a>
</h2>

    


<div class="blog-post-date text-secondary">
    
        <time datetime="2020-07-21">Jul 21, 2020</time>
    
    
</div>

    
    
    <hr>
</header>
<article class="blog-post">
    <p>Saving and loading is essential to almost every roguelike, but it can be a pain to manage if you don&rsquo;t start early. By the end of this chapter, our game will be able to save and load one file to the disk, which you could easily expand to multiple saves if you wanted to.</p>
<p>Let&rsquo;s start by defining the colors we&rsquo;ll need this chapter, by opening <code>color.py</code> and entering the following:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
bar_empty = (0x40, 0x10, 0x10)

<span style="color:#a6e22e">+menu_title = (255, 255, 63)
</span><span style="color:#a6e22e">+menu_text = white
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
bar_empty = (0x40, 0x10, 0x10)

<span class="new-text">menu_title = (255, 255, 63)
menu_text = white</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Another thing we&rsquo;ll need is a new type of exception. This will be used when we want to quit the game, but not save it. Normally, we&rsquo;ll save the game when the user quits, but if the game is over (because the player is dead), we don&rsquo;t want to create a save file.</p>
<p>We can put this exception in <code>exceptions.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class Impossible(Exception):
    &#34;&#34;&#34;Exception raised when an action is impossible to be performed.

    The reason is given as the exception message.
    &#34;&#34;&#34;


<span style="color:#a6e22e">+class QuitWithoutSaving(SystemExit):
</span><span style="color:#a6e22e">+   &#34;&#34;&#34;Can be raised to exit the game without automatically saving.&#34;&#34;&#34;
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class Impossible(Exception):
    """Exception raised when an action is impossible to be performed.

    The reason is given as the exception message.
    """


<span class="new-text">class QuitWithoutSaving(SystemExit):
    """Can be raised to exit the game without automatically saving."""</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>There&rsquo;s a bit of refactoring we can do to make things easier for ourselves in the future: By creating a base class that can be either an Action or an EventHandler, we don&rsquo;t need to set the engine&rsquo;s &ldquo;event handler&rdquo; to the new handler when we want to switch, we can just return that event handler instead. A benefit of this is that the <code>Engine</code> class won&rsquo;t need to store the event handler anymore. This works by keeping track of the handler in the <code>main.py</code> file instead, and switching it when necessary.</p>
<p>To make the change, start by adding the following to <code>input_handlers.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from __future__ import annotations

<span style="color:#f92672">-from typing import Callable, Optional, Tuple, TYPE_CHECKING
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from typing import Callable, Optional, Tuple, TYPE_CHECKING, Union
</span><span style="color:#a6e22e"></span>
import tcod
...

...
CONFIRM_KEYS = {
    tcod.event.K_RETURN,
    tcod.event.K_KP_ENTER,
}


<span style="color:#a6e22e">+ActionOrHandler = Union[Action, &#34;BaseEventHandler&#34;]
</span><span style="color:#a6e22e">+&#34;&#34;&#34;An event handler return value which can trigger an action or switch active handlers.
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+If a handler is returned then it will become the active handler for future events.
</span><span style="color:#a6e22e">+If an action is returned it will be attempted and if it&#39;s valid then
</span><span style="color:#a6e22e">+MainGameEventHandler will become the active handler.
</span><span style="color:#a6e22e">+&#34;&#34;&#34;
</span><span style="color:#a6e22e"></span>

<span style="color:#a6e22e">+class BaseEventHandler(tcod.event.EventDispatch[ActionOrHandler]):
</span><span style="color:#a6e22e">+   def handle_events(self, event: tcod.event.Event) -&gt; BaseEventHandler:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Handle an event and return the next active event handler.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       state = self.dispatch(event)
</span><span style="color:#a6e22e">+       if isinstance(state, BaseEventHandler):
</span><span style="color:#a6e22e">+           return state
</span><span style="color:#a6e22e">+       assert not isinstance(state, Action), f&#34;{self!r} can not handle actions.&#34;
</span><span style="color:#a6e22e">+       return self
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def on_render(self, console: tcod.Console) -&gt; None:
</span><span style="color:#a6e22e">+       raise NotImplementedError()
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def ev_quit(self, event: tcod.event.Quit) -&gt; Optional[Action]:
</span><span style="color:#a6e22e">+       raise SystemExit()
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from __future__ import annotations

<span class="crossed-out-text">from typing import Callable, Optional, Tuple, TYPE_CHECKING</span>
<span class="new-text">from typing import Callable, Optional, Tuple, TYPE_CHECKING, Union</span>

import tcod
...

...
CONFIRM_KEYS = {
    tcod.event.K_RETURN,
    tcod.event.K_KP_ENTER,
}


<span class="new-text">ActionOrHandler = Union[Action, "BaseEventHandler"]
"""An event handler return value which can trigger an action or switch active handlers.

If a handler is returned then it will become the active handler for future events.
If an action is returned it will be attempted and if it's valid then
MainGameEventHandler will become the active handler.
"""</span>


<span class="new-text">class BaseEventHandler(tcod.event.EventDispatch[ActionOrHandler]):
    def handle_events(self, event: tcod.event.Event) -> BaseEventHandler:
        """Handle an event and return the next active event handler."""
        state = self.dispatch(event)
        if isinstance(state, BaseEventHandler):
            return state
        assert not isinstance(state, Action), f"{self!r} can not handle actions."
        return self

    def on_render(self, console: tcod.Console) -> None:
        raise NotImplementedError()

    def ev_quit(self, event: tcod.event.Quit) -> Optional[Action]:
        raise SystemExit()</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>As the docstring explains, <code>ActionOrHandler</code> can be either an <code>Action</code> or an <code>EventHandler</code>. If it&rsquo;s an <code>Action</code>, the action will be attempted, and if its a handler, the handler will be changed.</p>
<p><code>BaseEventHandler</code> will be the base class for all of our handlers (we&rsquo;ll change that to be the case next). It will return a new instance of <code>BaseEventHandler</code> or its subclasses if one was returned, or return itself. This allows us to change event handlers based on the context of what happens in the actions.</p>
<p>We also need to adjust <code>EventHandler</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-class EventHandler(tcod.event.EventDispatch[Action]):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+class EventHandler(BaseEventHandler):
</span><span style="color:#a6e22e"></span>    def __init__(self, engine: Engine):
        self.engine = engine

<span style="color:#f92672">-   def handle_events(self, event: tcod.event.Event) -&gt; None:
</span><span style="color:#f92672">-       self.handle_action(self.dispatch(event))
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def handle_events(self, event: tcod.event.Event) -&gt; BaseEventHandler:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Handle events for input handlers with an engine.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       action_or_state = self.dispatch(event)
</span><span style="color:#a6e22e">+       if isinstance(action_or_state, BaseEventHandler):
</span><span style="color:#a6e22e">+           return action_or_state
</span><span style="color:#a6e22e">+       if self.handle_action(action_or_state):
</span><span style="color:#a6e22e">+           # A valid action was performed.
</span><span style="color:#a6e22e">+           if not self.engine.player.is_alive:
</span><span style="color:#a6e22e">+               # The player was killed sometime during or after the action.
</span><span style="color:#a6e22e">+               return GameOverEventHandler(self.engine)
</span><span style="color:#a6e22e">+           return MainGameEventHandler(self.engine)  # Return to the main handler.
</span><span style="color:#a6e22e">+       return self
</span><span style="color:#a6e22e"></span>
    def handle_action(self, action: Optional[Action]) -&gt; bool:
        ...

<span style="color:#f92672">-   def ev_quit(self, event: tcod.event.Quit) -&gt; Optional[Action]:
</span><span style="color:#f92672">-       raise SystemExit()
</span><span style="color:#f92672"></span>
    def on_render(self, console: tcod.Console) -&gt; None:
        self.engine.render(console)
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="crossed-out-text">class EventHandler(tcod.event.EventDispatch[Action]):</span>
<span class="new-text">class EventHandler(BaseEventHandler):</span>
    def __init__(self, engine: Engine):
        self.engine = engine

    <span class="crossed-out-text">def handle_events(self, event: tcod.event.Event) -> None:</span>
        <span class="crossed-out-text">self.handle_action(self.dispatch(event))</span>
    <span class="new-text">def handle_events(self, event: tcod.event.Event) -> BaseEventHandler:
        """Handle events for input handlers with an engine."""
        action_or_state = self.dispatch(event)
        if isinstance(action_or_state, BaseEventHandler):
            return action_or_state
        if self.handle_action(action_or_state):
            # A valid action was performed.
            if not self.engine.player.is_alive:
                # The player was killed sometime during or after the action.
                return GameOverEventHandler(self.engine)
            return MainGameEventHandler(self.engine)  # Return to the main handler.
        return self</span>

    def handle_action(self, action: Optional[Action]) -> bool:
        ...

    <span class="crossed-out-text">def ev_quit(self, event: tcod.event.Quit) -> Optional[Action]:</span>
        <span class="crossed-out-text">raise SystemExit()</span>

    def on_render(self, console: tcod.Console) -> None:
        self.engine.render(console)</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>The <code>handle_events</code> method of <code>EventHandler</code> is similar to <code>BaseEventHandler</code>, except it includes logic to handle actions as well. It also contains the logic for changing our handler to a game over if the player is dead.</p>
<p>To adjust our existing handlers, we&rsquo;ll need to continue editing <code>input_handlers</code>. This next code section is quite long, but the idea is consistent throughout: We want to modify our return types to return <code>Optional[ActionOrHandler]</code> instead of <code>Optional[Action]</code>, and instead of setting <code>self.engine.event_handler</code> to change the handler, we&rsquo;ll return the handler instead.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class AskUserEventHandler(EventHandler):
    &#34;&#34;&#34;Handles user input for actions which require special input.&#34;&#34;&#34;

<span style="color:#f92672">-   def handle_action(self, action: Optional[Action]) -&gt; bool:
</span><span style="color:#f92672">-       &#34;&#34;&#34;Return to the main event handler when a valid action was performed.&#34;&#34;&#34;
</span><span style="color:#f92672">-       if super().handle_action(action):
</span><span style="color:#f92672">-           self.engine.event_handler = MainGameEventHandler(self.engine)
</span><span style="color:#f92672">-           return True
</span><span style="color:#f92672">-       return False
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-   def ev_keydown(self, event: tcod.event.KeyDown) -&gt; Optional[Action]:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def ev_keydown(self, event: tcod.event.KeyDown) -&gt; Optional[ActionOrHandler]:
</span><span style="color:#a6e22e"></span>        &#34;&#34;&#34;By default any key exits this input handler.&#34;&#34;&#34;
        if event.sym in {  # Ignore modifier keys.
            tcod.event.K_LSHIFT,
            tcod.event.K_RSHIFT,
            tcod.event.K_LCTRL,
            tcod.event.K_RCTRL,
            tcod.event.K_LALT,
            tcod.event.K_RALT,
        }:
            return None
        return self.on_exit()

<span style="color:#f92672">-   def ev_mousebuttondown(self, event: tcod.event.MouseButtonDown) -&gt; Optional[Action]:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def ev_mousebuttondown(
</span><span style="color:#a6e22e">+       self, event: tcod.event.MouseButtonDown
</span><span style="color:#a6e22e">+   ) -&gt; Optional[ActionOrHandler]:
</span><span style="color:#a6e22e"></span>        &#34;&#34;&#34;By default any mouse click exits this input handler.&#34;&#34;&#34;
        return self.on_exit()

<span style="color:#f92672">-   def on_exit(self) -&gt; Optional[Action]:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def on_exit(self) -&gt; Optional[ActionOrHandler]:
</span><span style="color:#a6e22e"></span>        &#34;&#34;&#34;Called when the user is trying to exit or cancel an action.

        By default this returns to the main event handler.
        &#34;&#34;&#34;
<span style="color:#f92672">-       self.engine.event_handler = MainGameEventHandler(self.engine)
</span><span style="color:#f92672">-       return None
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       return MainGameEventHandler(self.engine)
</span><span style="color:#a6e22e"></span>

class InventoryEventHandler(AskUserEventHandler):
    ...

<span style="color:#f92672">-   def ev_keydown(self, event: tcod.event.KeyDown) -&gt; Optional[Action]:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def ev_keydown(self, event: tcod.event.KeyDown) -&gt; Optional[ActionOrHandler]:
</span><span style="color:#a6e22e"></span>        player = self.engine.player
        key = event.sym
        index = key - tcod.event.K_a

        if 0 &lt;= index &lt;= 26:
            try:
                selected_item = player.inventory.items[index]
            except IndexError:
                self.engine.message_log.add_message(&#34;Invalid entry.&#34;, color.invalid)
                return None
            return self.on_item_selected(selected_item)
        return super().ev_keydown(event)

<span style="color:#f92672">-   def on_item_selected(self, item: Item) -&gt; Optional[Action]:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def on_item_selected(self, item: Item) -&gt; Optional[ActionOrHandler]:
</span><span style="color:#a6e22e"></span>        &#34;&#34;&#34;Called when the user selects a valid item.&#34;&#34;&#34;
        raise NotImplementedError()


class InventoryActivateHandler(InventoryEventHandler):
    &#34;&#34;&#34;Handle using an inventory item.&#34;&#34;&#34;

    TITLE = &#34;Select an item to use&#34;

<span style="color:#f92672">-   def on_item_selected(self, item: Item) -&gt; Optional[Action]:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def on_item_selected(self, item: Item) -&gt; Optional[ActionOrHandler]:
</span><span style="color:#a6e22e"></span>        &#34;&#34;&#34;Return the action for the selected item.&#34;&#34;&#34;
        return item.consumable.get_action(self.engine.player)


class InventoryDropHandler(InventoryEventHandler):
    &#34;&#34;&#34;Handle dropping an inventory item.&#34;&#34;&#34;

    TITLE = &#34;Select an item to drop&#34;

<span style="color:#f92672">-   def on_item_selected(self, item: Item) -&gt; Optional[Action]:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def on_item_selected(self, item: Item) -&gt; Optional[ActionOrHandler]:
</span><span style="color:#a6e22e"></span>        &#34;&#34;&#34;Drop this item.&#34;&#34;&#34;
        return actions.DropItem(self.engine.player, item)


class SelectIndexHandler(AskUserEventHandler):
    ...

<span style="color:#f92672">-   def ev_keydown(self, event: tcod.event.KeyDown) -&gt; Optional[Action]:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def ev_keydown(self, event: tcod.event.KeyDown) -&gt; Optional[ActionOrHandler]:
</span><span style="color:#a6e22e"></span>        ...

<span style="color:#f92672">-   def ev_mousebuttondown(self, event: tcod.event.MouseButtonDown) -&gt; Optional[Action]:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def ev_mousebuttondown(
</span><span style="color:#a6e22e">+       self, event: tcod.event.MouseButtonDown
</span><span style="color:#a6e22e">+   ) -&gt; Optional[ActionOrHandler]:
</span><span style="color:#a6e22e"></span>        ...

<span style="color:#f92672">-   def on_index_selected(self, x: int, y: int) -&gt; Optional[Action]:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def on_index_selected(self, x: int, y: int) -&gt; Optional[ActionOrHandler]:
</span><span style="color:#a6e22e"></span>        &#34;&#34;&#34;Called when an index is selected.&#34;&#34;&#34;
        raise NotImplementedError()


class LookHandler(SelectIndexHandler):
    &#34;&#34;&#34;Lets the player look around using the keyboard.&#34;&#34;&#34;

<span style="color:#f92672">-   def on_index_selected(self, x: int, y: int) -&gt; None:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def on_index_selected(self, x: int, y: int) -&gt; MainGameEventHandler:
</span><span style="color:#a6e22e"></span>        &#34;&#34;&#34;Return to main handler.&#34;&#34;&#34;
<span style="color:#f92672">-       self.engine.event_handler = MainGameEventHandler(self.engine)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       return MainGameEventHandler(self.engine)
</span><span style="color:#a6e22e"></span>
...

class MainGameEventHandler(EventHandler):
<span style="color:#f92672">-   def ev_keydown(self, event: tcod.event.KeyDown) -&gt; Optional[Action]:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def ev_keydown(self, event: tcod.event.KeyDown) -&gt; Optional[ActionOrHandler]:
</span><span style="color:#a6e22e"></span>        action: Optional[Action] = None

        key = event.sym

        player = self.engine.player

        if key in MOVE_KEYS:
            dx, dy = MOVE_KEYS[key]
            action = BumpAction(player, dx, dy)
        elif key in WAIT_KEYS:
            action = WaitAction(player)

        elif key == tcod.event.K_ESCAPE:
            raise SystemExit()
        elif key == tcod.event.K_v:
<span style="color:#f92672">-           self.engine.event_handler = HistoryViewer(self.engine)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           return HistoryViewer(self.engine)
</span><span style="color:#a6e22e"></span>
        elif key == tcod.event.K_g:
            action = PickupAction(player)

        elif key == tcod.event.K_i:
<span style="color:#f92672">-           self.engine.event_handler = InventoryActivateHandler(self.engine)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           return InventoryActivateHandler(self.engine)
</span><span style="color:#a6e22e"></span>        elif key == tcod.event.K_d:
<span style="color:#f92672">-           self.engine.event_handler = InventoryDropHandler(self.engine)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           return InventoryDropHandler(self.engine)
</span><span style="color:#a6e22e"></span>        elif key == tcod.event.K_SLASH:
<span style="color:#f92672">-           self.engine.event_handler = LookHandler(self.engine)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           return LookHandler(self.engine)
</span><span style="color:#a6e22e"></span>
        # No valid key was pressed
        return action


...
class HistoryViewer(EventHandler):
    ...

<span style="color:#f92672">-   def ev_keydown(self, event: tcod.event.KeyDown) -&gt; None:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def ev_keydown(self, event: tcod.event.KeyDown) -&gt; Optional[MainGameEventHandler]:
</span><span style="color:#a6e22e"></span>        # Fancy conditional movement to make it feel right.
        if event.sym in CURSOR_Y_KEYS:
            adjust = CURSOR_Y_KEYS[event.sym]
            if adjust &lt; 0 and self.cursor == 0:
                # Only move from the top to the bottom when you&#39;re on the edge.
                self.cursor = self.log_length - 1
            elif adjust &gt; 0 and self.cursor == self.log_length - 1:
                # Same with bottom to top movement.
                self.cursor = 0
            else:
                # Otherwise move while staying clamped to the bounds of the history log.
                self.cursor = max(0, min(self.cursor + adjust, self.log_length - 1))
        elif event.sym == tcod.event.K_HOME:
            self.cursor = 0  # Move directly to the top message.
        elif event.sym == tcod.event.K_END:
            self.cursor = self.log_length - 1  # Move directly to the last message.
        else:  # Any other key moves back to the main game state.
<span style="color:#f92672">-           self.engine.event_handler = MainGameEventHandler(self.engine)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           return MainGameEventHandler(self.engine)
</span><span style="color:#a6e22e">+       return None
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class AskUserEventHandler(EventHandler):
    """Handles user input for actions which require special input."""

    <span class="crossed-out-text">def handle_action(self, action: Optional[Action]) -> bool:</span>
        <span class="crossed-out-text">"""Return to the main event handler when a valid action was performed."""</span>
        <span class="crossed-out-text">if super().handle_action(action):</span>
            <span class="crossed-out-text">self.engine.event_handler = MainGameEventHandler(self.engine)</span>
            <span class="crossed-out-text">return True</span>
        <span class="crossed-out-text">return False</span>

    <span class="crossed-out-text">def ev_keydown(self, event: tcod.event.KeyDown) -> Optional[Action]:</span>
    <span class="new-text">def ev_keydown(self, event: tcod.event.KeyDown) -> Optional[ActionOrHandler]:</span>
        """By default any key exits this input handler."""
        if event.sym in {  # Ignore modifier keys.
            tcod.event.K_LSHIFT,
            tcod.event.K_RSHIFT,
            tcod.event.K_LCTRL,
            tcod.event.K_RCTRL,
            tcod.event.K_LALT,
            tcod.event.K_RALT,
        }:
            return None
        return self.on_exit()

    <span class="crossed-out-text">def ev_mousebuttondown(self, event: tcod.event.MouseButtonDown) -> Optional[Action]:</span>
    <span class="new-text">def ev_mousebuttondown(
        self, event: tcod.event.MouseButtonDown
    ) -> Optional[ActionOrHandler]:</span>
        """By default any mouse click exits this input handler."""
        return self.on_exit()

    <span class="crossed-out-text">def on_exit(self) -> Optional[Action]:</span>
    <span class="new-text">def on_exit(self) -> Optional[ActionOrHandler]:</span>
        """Called when the user is trying to exit or cancel an action.

        By default this returns to the main event handler.
        """
        <span class="crossed-out-text">self.engine.event_handler = MainGameEventHandler(self.engine)</span>
        <span class="crossed-out-text">return None</span>
        <span class="new-text">return MainGameEventHandler(self.engine)</span>


class InventoryEventHandler(AskUserEventHandler):
    ...

    <span class="crossed-out-text">def ev_keydown(self, event: tcod.event.KeyDown) -> Optional[Action]:</span>
    <span class="new-text">def ev_keydown(self, event: tcod.event.KeyDown) -> Optional[ActionOrHandler]:</span>
        player = self.engine.player
        key = event.sym
        index = key - tcod.event.K_a

        if 0 <= index <= 26:
            try:
                selected_item = player.inventory.items[index]
            except IndexError:
                self.engine.message_log.add_message("Invalid entry.", color.invalid)
                return None
            return self.on_item_selected(selected_item)
        return super().ev_keydown(event)

    <span class="crossed-out-text">def on_item_selected(self, item: Item) -> Optional[Action]:</span>
    <span class="new-text">def on_item_selected(self, item: Item) -> Optional[ActionOrHandler]:</span>
        """Called when the user selects a valid item."""
        raise NotImplementedError()


class InventoryActivateHandler(InventoryEventHandler):
    """Handle using an inventory item."""

    TITLE = "Select an item to use"

    <span class="crossed-out-text">def on_item_selected(self, item: Item) -> Optional[Action]:</span>
    <span class="new-text">def on_item_selected(self, item: Item) -> Optional[ActionOrHandler]:</span>
        """Return the action for the selected item."""
        return item.consumable.get_action(self.engine.player)


class InventoryDropHandler(InventoryEventHandler):
    """Handle dropping an inventory item."""

    TITLE = "Select an item to drop"

    <span class="crossed-out-text">def on_item_selected(self, item: Item) -> Optional[Action]:</span>
    <span class="new-text">def on_item_selected(self, item: Item) -> Optional[ActionOrHandler]:</span>
        """Drop this item."""
        return actions.DropItem(self.engine.player, item)


class SelectIndexHandler(AskUserEventHandler):
    ...

    <span class="crossed-out-text">def ev_keydown(self, event: tcod.event.KeyDown) -> Optional[Action]:</span>
    <span class="new-text">def ev_keydown(self, event: tcod.event.KeyDown) -> Optional[ActionOrHandler]:</span>
        ...

    <span class="crossed-out-text">def ev_mousebuttondown(self, event: tcod.event.MouseButtonDown) -> Optional[Action]:</span>
    <span class="new-text">def ev_mousebuttondown(
        self, event: tcod.event.MouseButtonDown
    ) -> Optional[ActionOrHandler]:</span>
        ...

    <span class="crossed-out-text">def on_index_selected(self, x: int, y: int) -> Optional[Action]:</span>
    <span class="new-text">def on_index_selected(self, x: int, y: int) -> Optional[ActionOrHandler]:</span>
        """Called when an index is selected."""
        raise NotImplementedError()


class LookHandler(SelectIndexHandler):
    """Lets the player look around using the keyboard."""

    <span class="crossed-out-text">def on_index_selected(self, x: int, y: int) -> None:</span>
    <span class="new-text">def on_index_selected(self, x: int, y: int) -> MainGameEventHandler:</span>
        """Return to main handler."""
        <span class="crossed-out-text">self.engine.event_handler = MainGameEventHandler(self.engine)</span>
        <span class="new-text">return MainGameEventHandler(self.engine)</span>

...

class MainGameEventHandler(EventHandler):
    <span class="crossed-out-text">def ev_keydown(self, event: tcod.event.KeyDown) -> Optional[Action]:</span>
    <span class="new-text">def ev_keydown(self, event: tcod.event.KeyDown) -> Optional[ActionOrHandler]:</span>
        action: Optional[Action] = None

        key = event.sym

        player = self.engine.player

        if key in MOVE_KEYS:
            dx, dy = MOVE_KEYS[key]
            action = BumpAction(player, dx, dy)
        elif key in WAIT_KEYS:
            action = WaitAction(player)

        elif key == tcod.event.K_ESCAPE:
            raise SystemExit()
        elif key == tcod.event.K_v:
            <span class="crossed-out-text">self.engine.event_handler = HistoryViewer(self.engine)</span>
            <span class="new-text">return HistoryViewer(self.engine)</span>

        elif key == tcod.event.K_g:
            action = PickupAction(player)

        elif key == tcod.event.K_i:
            <span class="crossed-out-text">self.engine.event_handler = InventoryActivateHandler(self.engine)</span>
            <span class="new-text">return InventoryActivateHandler(self.engine)</span>
        elif key == tcod.event.K_d:
            <span class="crossed-out-text">self.engine.event_handler = InventoryDropHandler(self.engine)</span>
            <span class="new-text">return InventoryDropHandler(self.engine)</span>
        elif key == tcod.event.K_SLASH:
            <span class="crossed-out-text">self.engine.event_handler = LookHandler(self.engine)</span>
            <span class="new-text">return LookHandler(self.engine)</span>

        # No valid key was pressed
        return action


...
class HistoryViewer(EventHandler):
    ...

    <span class="crossed-out-text">def ev_keydown(self, event: tcod.event.KeyDown) -> None:</span>
    <span class="new-text">def ev_keydown(self, event: tcod.event.KeyDown) -> Optional[MainGameEventHandler]:</span>
        # Fancy conditional movement to make it feel right.
        if event.sym in CURSOR_Y_KEYS:
            adjust = CURSOR_Y_KEYS[event.sym]
            if adjust < 0 and self.cursor == 0:
                # Only move from the top to the bottom when you're on the edge.
                self.cursor = self.log_length - 1
            elif adjust > 0 and self.cursor == self.log_length - 1:
                # Same with bottom to top movement.
                self.cursor = 0
            else:
                # Otherwise move while staying clamped to the bounds of the history log.
                self.cursor = max(0, min(self.cursor + adjust, self.log_length - 1))
        elif event.sym == tcod.event.K_HOME:
            self.cursor = 0  # Move directly to the top message.
        elif event.sym == tcod.event.K_END:
            self.cursor = self.log_length - 1  # Move directly to the last message.
        else:  # Any other key moves back to the main game state.
            <span class="crossed-out-text">self.engine.event_handler = MainGameEventHandler(self.engine)</span>
            <span class="new-text">return MainGameEventHandler(self.engine)
        return None</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>We&rsquo;ll also need to make a few adjustments in <code>consumable.py</code>, because some of the methods there also affected the input handlers.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
import components.ai
import components.inventory
from components.base_component import BaseComponent
from exceptions import Impossible
<span style="color:#f92672">-from input_handlers import AreaRangedAttackHandler, SingleRangedAttackHandler
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from input_handlers import (
</span><span style="color:#a6e22e">+   ActionOrHandler,
</span><span style="color:#a6e22e">+   AreaRangedAttackHandler,
</span><span style="color:#a6e22e">+   SingleRangedAttackHandler,
</span><span style="color:#a6e22e">+)
</span><span style="color:#a6e22e"></span>
if TYPE_CHECKING:
    ...

...
class Consumable(BaseComponent):
    parent: Item

<span style="color:#f92672">-   def get_action(self, consumer: Actor) -&gt; Optional[actions.Action]:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def get_action(self, consumer: Actor) -&gt; Optional[ActionOrHandler]:
</span><span style="color:#a6e22e"></span>        &#34;&#34;&#34;Try to return the action for this item.&#34;&#34;&#34;
        return actions.ItemAction(consumer, self.parent)

    ...

class ConfusionConsumable(Consumable):
    def __init__(self, number_of_turns: int):
        self.number_of_turns = number_of_turns

<span style="color:#f92672">-   def get_action(self, consumer: Actor) -&gt; Optional[actions.Action]:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def get_action(self, consumer: Actor) -&gt; SingleRangedAttackHandler:
</span><span style="color:#a6e22e"></span>        self.engine.message_log.add_message(
            &#34;Select a target location.&#34;, color.needs_target
        )
<span style="color:#f92672">-       self.engine.event_handler = SingleRangedAttackHandler(
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       return SingleRangedAttackHandler(
</span><span style="color:#a6e22e"></span>            self.engine,
            callback=lambda xy: actions.ItemAction(consumer, self.parent, xy),
        )
<span style="color:#f92672">-       return None
</span><span style="color:#f92672"></span>
    ...

class FireballDamageConsumable(Consumable):
    def __init__(self, damage: int, radius: int):
        self.damage = damage
        self.radius = radius

<span style="color:#f92672">-   def get_action(self, consumer: Actor) -&gt; Optional[actions.Action]:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def get_action(self, consumer: Actor) -&gt; AreaRangedAttackHandler:
</span><span style="color:#a6e22e"></span>        self.engine.message_log.add_message(
            &#34;Select a target location.&#34;, color.needs_target
        )
<span style="color:#f92672">-       self.engine.event_handler = AreaRangedAttackHandler(
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       return AreaRangedAttackHandler(
</span><span style="color:#a6e22e"></span>            self.engine,
            radius=self.radius,
            callback=lambda xy: actions.ItemAction(consumer, self.parent, xy),
        )
<span style="color:#f92672">-       return None
</span><span style="color:#f92672"></span>
    def activate(self, action: actions.ItemAction) -&gt; None:
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
import components.ai
import components.inventory
from components.base_component import BaseComponent
from exceptions import Impossible
<span class="crossed-out-text">from input_handlers import AreaRangedAttackHandler, SingleRangedAttackHandler</span>
<span class="new-text">from input_handlers import (
    ActionOrHandler,
    AreaRangedAttackHandler,
    SingleRangedAttackHandler,
)</span>

if TYPE_CHECKING:
    ...

...
class Consumable(BaseComponent):
    parent: Item

    <span class="crossed-out-text">def get_action(self, consumer: Actor) -> Optional[actions.Action]:</span>
    <span class="new-text">def get_action(self, consumer: Actor) -> Optional[ActionOrHandler]:</span>
        """Try to return the action for this item."""
        return actions.ItemAction(consumer, self.parent)

    ...

class ConfusionConsumable(Consumable):
    def __init__(self, number_of_turns: int):
        self.number_of_turns = number_of_turns

    <span class="crossed-out-text">def get_action(self, consumer: Actor) -> Optional[actions.Action]:</span>
    <span class="new-text">def get_action(self, consumer: Actor) -> SingleRangedAttackHandler:</span>
        self.engine.message_log.add_message(
            "Select a target location.", color.needs_target
        )
        <span class="crossed-out-text">self.engine.event_handler = SingleRangedAttackHandler(</span>
        <span class="new-text">return SingleRangedAttackHandler(</span>
            self.engine,
            callback=lambda xy: actions.ItemAction(consumer, self.parent, xy),
        )
        <span class="crossed-out-text">return None</span>

    ...

class FireballDamageConsumable(Consumable):
    def __init__(self, damage: int, radius: int):
        self.damage = damage
        self.radius = radius

    <span class="crossed-out-text">def get_action(self, consumer: Actor) -> Optional[actions.Action]:</span>
    <span class="new-text">def get_action(self, consumer: Actor) -> AreaRangedAttackHandler:</span>
        self.engine.message_log.add_message(
            "Select a target location.", color.needs_target
        )
        <span class="crossed-out-text">self.engine.event_handler = AreaRangedAttackHandler(</span>
        <span class="new-text">return AreaRangedAttackHandler(</span>
            self.engine,
            radius=self.radius,
            callback=lambda xy: actions.ItemAction(consumer, self.parent, xy),
        )
        <span class="crossed-out-text">return None</span>

    def activate(self, action: actions.ItemAction) -> None:
        ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>We also need to make a small adjustmet to <code>fighter.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from typing import TYPE_CHECKING

import color
from components.base_component import BaseComponent
<span style="color:#f92672">-from input_handlers import GameOverEventHandler
</span><span style="color:#f92672"></span>from render_order import RenderOrder

...

        ...
        if self.engine.player is self.parent:
            death_message = &#34;You died!&#34;
            death_message_color = color.player_die
<span style="color:#f92672">-           self.engine.event_handler = GameOverEventHandler(self.engine)
</span><span style="color:#f92672"></span>        else:
            death_message = f&#34;{self.parent.name} is dead!&#34;
            death_message_color = color.enemy_die
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from typing import TYPE_CHECKING

import color
from components.base_component import BaseComponent
<span class="crossed-out-text">from input_handlers import GameOverEventHandler</span>
from render_order import RenderOrder

...

        ...
        if self.engine.player is self.parent:
            death_message = "You died!"
            death_message_color = color.player_die
            <span class="crossed-out-text">self.engine.event_handler = GameOverEventHandler(self.engine)</span>
        else:
            death_message = f"{self.parent.name} is dead!"
            death_message_color = color.enemy_die
        ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Since the logic associated with setting <code>GameOverEventHandler</code> is now handled in the <code>EventHandler</code> class, this line in <code>fighter.py</code> wasn&rsquo;t needed anymore.</p>
<p>In order to make these changes work, we need to adjust the way that the input handlers are&hellip; well, handled. What we&rsquo;ll want to do is have the handler exist on its own in <code>main.py</code> rather than be part of the <code>Engine</code> class.</p>
<p>Open up <code>main.py</code> and add make the following changes:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">#!/usr/bin/env python3
import copy
import traceback

import tcod

import color
from engine import Engine
import entity_factories
<span style="color:#a6e22e">+import exceptions
</span><span style="color:#a6e22e">+import input_handlers
</span><span style="color:#a6e22e"></span>from procgen import generate_dungeon

def main() -&gt; None:
    ...
    engine.message_log.add_message(
        &#34;Hello and welcome, adventurer, to yet another dungeon!&#34;, color.welcome_text
    )

<span style="color:#a6e22e">+   handler: input_handlers.BaseEventHandler = input_handlers.MainGameEventHandler(engine)
</span><span style="color:#a6e22e"></span>
    with tcod.context.new_terminal(
        screen_width,
        screen_height,
        tileset=tileset,
        title=&#34;Yet Another Roguelike Tutorial&#34;,
        vsync=True,
    ) as context:
        root_console = tcod.Console(screen_width, screen_height, order=&#34;F&#34;)
<span style="color:#f92672">-       while True:
</span><span style="color:#f92672">-           root_console.clear()
</span><span style="color:#f92672">-           engine.event_handler.on_render(console=root_console)
</span><span style="color:#f92672">-           context.present(root_console)
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-           try:
</span><span style="color:#f92672">-               for event in tcod.event.wait():
</span><span style="color:#f92672">-                   context.convert_event(event)
</span><span style="color:#f92672">-                   engine.event_handler.handle_events(event)
</span><span style="color:#f92672">-           except Exception:  # Handle exceptions in game.
</span><span style="color:#f92672">-               traceback.print_exc()  # Print error to stderr.
</span><span style="color:#f92672">-               # Then print the error to the message log.
</span><span style="color:#f92672">-               engine.message_log.add_message(traceback.format_exc(), color.error)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       try:
</span><span style="color:#a6e22e">+           while True:
</span><span style="color:#a6e22e">+               root_console.clear()
</span><span style="color:#a6e22e">+               handler.on_render(console=root_console)
</span><span style="color:#a6e22e">+               context.present(root_console)
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+               try:
</span><span style="color:#a6e22e">+                   for event in tcod.event.wait():
</span><span style="color:#a6e22e">+                       context.convert_event(event)
</span><span style="color:#a6e22e">+                       handler = handler.handle_events(event)
</span><span style="color:#a6e22e">+               except Exception:  # Handle exceptions in game.
</span><span style="color:#a6e22e">+                   traceback.print_exc()  # Print error to stderr.
</span><span style="color:#a6e22e">+                   # Then print the error to the message log.
</span><span style="color:#a6e22e">+                   if isinstance(handler, input_handlers.EventHandler):
</span><span style="color:#a6e22e">+                       handler.engine.message_log.add_message(
</span><span style="color:#a6e22e">+                           traceback.format_exc(), color.error
</span><span style="color:#a6e22e">+                       )
</span><span style="color:#a6e22e">+       except exceptions.QuitWithoutSaving:
</span><span style="color:#a6e22e">+           raise
</span><span style="color:#a6e22e">+       except SystemExit:  # Save and quit.
</span><span style="color:#a6e22e">+           # TODO: Add the save function here
</span><span style="color:#a6e22e">+           raise
</span><span style="color:#a6e22e">+       except BaseException:  # Save on any other unexpected exception.
</span><span style="color:#a6e22e">+           # TODO: Add the save function here
</span><span style="color:#a6e22e">+           raise
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>#!/usr/bin/env python3
import copy
import traceback

import tcod

import color
from engine import Engine
import entity_factories
<span class="new-text">import exceptions</span>
<span class="new-text">import input_handlers</span>
from procgen import generate_dungeon

def main() -> None:
    ...
    engine.message_log.add_message(
        "Hello and welcome, adventurer, to yet another dungeon!", color.welcome_text
    )

    <span class="new-text">handler: input_handlers.BaseEventHandler = input_handlers.MainGameEventHandler(engine)</span>

    with tcod.context.new_terminal(
        screen_width,
        screen_height,
        tileset=tileset,
        title="Yet Another Roguelike Tutorial",
        vsync=True,
    ) as context:
        root_console = tcod.Console(screen_width, screen_height, order="F")
        <span class="crossed-out-text">while True:</span>
            <span class="crossed-out-text">root_console.clear()</span>
            <span class="crossed-out-text">engine.event_handler.on_render(console=root_console)</span>
            <span class="crossed-out-text">context.present(root_console)</span>

            <span class="crossed-out-text">try:</span>
                <span class="crossed-out-text">for event in tcod.event.wait():</span>
                    <span class="crossed-out-text">context.convert_event(event)</span>
                    <span class="crossed-out-text">engine.event_handler.handle_events(event)</span>
            <span class="crossed-out-text">except Exception:  # Handle exceptions in game.</span>
                <span class="crossed-out-text">traceback.print_exc()  # Print error to stderr.</span>
                <span class="crossed-out-text"># Then print the error to the message log.</span>
                <span class="crossed-out-text">engine.message_log.add_message(traceback.format_exc(), color.error)</span>
        <span class="new-text">try:
            while True:
                root_console.clear()
                handler.on_render(console=root_console)
                context.present(root_console)

                try:
                    for event in tcod.event.wait():
                        context.convert_event(event)
                        handler = handler.handle_events(event)
                except Exception:  # Handle exceptions in game.
                    traceback.print_exc()  # Print error to stderr.
                    # Then print the error to the message log.
                    if isinstance(handler, input_handlers.EventHandler):
                        handler.engine.message_log.add_message(
                            traceback.format_exc(), color.error
                        )
        except exceptions.QuitWithoutSaving:
            raise
        except SystemExit:  # Save and quit.
            # TODO: Add the save function here
            raise
        except BaseException:  # Save on any other unexpected exception.
            # TODO: Add the save function here
            raise</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>We&rsquo;re now defining our <code>handler</code> in <code>main.py</code> rather than passing it to the <code>Engine</code>. The handler can change if a different handler is returned from <code>handler.handle_events</code>. We&rsquo;ve also added a few exception statements for the various exception types. They all do the same thing at the moment, but soon, once we&rsquo;ve implemented our save function, the <code>SystemExit</code> and <code>BaseException</code> exceptions will save the game before exiting. <code>QuitWithoutSaving</code> will not, as this will be called when we don&rsquo;t want to save the game.</p>
<p>If you run the project now, things should work the same as before.</p>
<p>Let&rsquo;s clean up the <code>Engine</code> class by removing the <code>event_handler</code> attribute, as we don&rsquo;t need it anymore:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from __future__ import annotations

from typing import TYPE_CHECKING

from tcod.console import Console
from tcod.map import compute_fov

import exceptions
<span style="color:#f92672">-from input_handlers import MainGameEventHandler
</span><span style="color:#f92672"></span>from message_log import MessageLog
from render_functions import (
    render_bar,
    render_names_at_mouse_location,
)

if TYPE_CHECKING:
    from entity import Actor
    from game_map import GameMap
<span style="color:#f92672">-   from input_handlers import EventHandler
</span><span style="color:#f92672"></span>

class Engine:
    game_map: GameMap

    def __init__(self, player: Actor):
<span style="color:#f92672">-       self.event_handler: EventHandler = MainGameEventHandler(self)
</span><span style="color:#f92672"></span>        self.message_log = MessageLog()
        self.mouse_location = (0, 0)
        self.player = player
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from __future__ import annotations

from typing import TYPE_CHECKING

from tcod.console import Console
from tcod.map import compute_fov

import exceptions
<span class="crossed-out-text">from input_handlers import MainGameEventHandler</span>
from message_log import MessageLog
from render_functions import (
    render_bar,
    render_names_at_mouse_location,
)

if TYPE_CHECKING:
    from entity import Actor
    from game_map import GameMap
    <span class="crossed-out-text">from input_handlers import EventHandler</span>


class Engine:
    game_map: GameMap

    def __init__(self, player: Actor):
        <span class="crossed-out-text">self.event_handler: EventHandler = MainGameEventHandler(self)</span>
        self.message_log = MessageLog()
        self.mouse_location = (0, 0)
        self.player = player
        ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>If you run the project again, nothing should change. The <code>event_handler</code> in <code>Engine</code> was not doing anything at this point.</p>
<p>Before we implement saving the game, we need to implement a main menu, where the user can choose to start a new game or load an existing one (or simply quit). It would also be handy to move all the logic of setting up a new game into a function, as we won&rsquo;t need to call it when we eventually get to loading a game from a save file.</p>
<p>Create a new file, called <code>setup_game.py</code>, and put the following contents into it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#e6db74">&#34;&#34;&#34;Handle the loading and initialization of game sessions.&#34;&#34;&#34;</span>
<span style="color:#f92672">from</span> __future__ <span style="color:#f92672">import</span> annotations

<span style="color:#f92672">import</span> copy
<span style="color:#f92672">from</span> typing <span style="color:#f92672">import</span> Optional

<span style="color:#f92672">import</span> tcod

<span style="color:#f92672">import</span> color
<span style="color:#f92672">from</span> engine <span style="color:#f92672">import</span> Engine
<span style="color:#f92672">import</span> entity_factories
<span style="color:#f92672">import</span> input_handlers
<span style="color:#f92672">from</span> procgen <span style="color:#f92672">import</span> generate_dungeon


<span style="color:#75715e"># Load the background image and remove the alpha channel.</span>
background_image <span style="color:#f92672">=</span> tcod<span style="color:#f92672">.</span>image<span style="color:#f92672">.</span>load(<span style="color:#e6db74">&#34;menu_background.png&#34;</span>)[:, :, :<span style="color:#ae81ff">3</span>]


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">new_game</span>() <span style="color:#f92672">-&gt;</span> Engine:
    <span style="color:#e6db74">&#34;&#34;&#34;Return a brand new game session as an Engine instance.&#34;&#34;&#34;</span>
    map_width <span style="color:#f92672">=</span> <span style="color:#ae81ff">80</span>
    map_height <span style="color:#f92672">=</span> <span style="color:#ae81ff">43</span>

    room_max_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
    room_min_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>
    max_rooms <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>

    max_monsters_per_room <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
    max_items_per_room <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>

    player <span style="color:#f92672">=</span> copy<span style="color:#f92672">.</span>deepcopy(entity_factories<span style="color:#f92672">.</span>player)

    engine <span style="color:#f92672">=</span> Engine(player<span style="color:#f92672">=</span>player)

    engine<span style="color:#f92672">.</span>game_map <span style="color:#f92672">=</span> generate_dungeon(
        max_rooms<span style="color:#f92672">=</span>max_rooms,
        room_min_size<span style="color:#f92672">=</span>room_min_size,
        room_max_size<span style="color:#f92672">=</span>room_max_size,
        map_width<span style="color:#f92672">=</span>map_width,
        map_height<span style="color:#f92672">=</span>map_height,
        max_monsters_per_room<span style="color:#f92672">=</span>max_monsters_per_room,
        max_items_per_room<span style="color:#f92672">=</span>max_items_per_room,
        engine<span style="color:#f92672">=</span>engine,
    )
    engine<span style="color:#f92672">.</span>update_fov()

    engine<span style="color:#f92672">.</span>message_log<span style="color:#f92672">.</span>add_message(
        <span style="color:#e6db74">&#34;Hello and welcome, adventurer, to yet another dungeon!&#34;</span>, color<span style="color:#f92672">.</span>welcome_text
    )
    <span style="color:#66d9ef">return</span> engine


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MainMenu</span>(input_handlers<span style="color:#f92672">.</span>BaseEventHandler):
    <span style="color:#e6db74">&#34;&#34;&#34;Handle the main menu rendering and input.&#34;&#34;&#34;</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">on_render</span>(self, console: tcod<span style="color:#f92672">.</span>Console) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
        <span style="color:#e6db74">&#34;&#34;&#34;Render the main menu on a background image.&#34;&#34;&#34;</span>
        console<span style="color:#f92672">.</span>draw_semigraphics(background_image, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)

        console<span style="color:#f92672">.</span>print(
            console<span style="color:#f92672">.</span>width <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>,
            console<span style="color:#f92672">.</span>height <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">4</span>,
            <span style="color:#e6db74">&#34;TOMBS OF THE ANCIENT KINGS&#34;</span>,
            fg<span style="color:#f92672">=</span>color<span style="color:#f92672">.</span>menu_title,
            alignment<span style="color:#f92672">=</span>tcod<span style="color:#f92672">.</span>CENTER,
        )
        console<span style="color:#f92672">.</span>print(
            console<span style="color:#f92672">.</span>width <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>,
            console<span style="color:#f92672">.</span>height <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>,
            <span style="color:#e6db74">&#34;By (Your name here)&#34;</span>,
            fg<span style="color:#f92672">=</span>color<span style="color:#f92672">.</span>menu_title,
            alignment<span style="color:#f92672">=</span>tcod<span style="color:#f92672">.</span>CENTER,
        )

        menu_width <span style="color:#f92672">=</span> <span style="color:#ae81ff">24</span>
        <span style="color:#66d9ef">for</span> i, text <span style="color:#f92672">in</span> enumerate(
            [<span style="color:#e6db74">&#34;[N] Play a new game&#34;</span>, <span style="color:#e6db74">&#34;[C] Continue last game&#34;</span>, <span style="color:#e6db74">&#34;[Q] Quit&#34;</span>]
        ):
            console<span style="color:#f92672">.</span>print(
                console<span style="color:#f92672">.</span>width <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>,
                console<span style="color:#f92672">.</span>height <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> i,
                text<span style="color:#f92672">.</span>ljust(menu_width),
                fg<span style="color:#f92672">=</span>color<span style="color:#f92672">.</span>menu_text,
                bg<span style="color:#f92672">=</span>color<span style="color:#f92672">.</span>black,
                alignment<span style="color:#f92672">=</span>tcod<span style="color:#f92672">.</span>CENTER,
                bg_blend<span style="color:#f92672">=</span>tcod<span style="color:#f92672">.</span>BKGND_ALPHA(<span style="color:#ae81ff">64</span>),
            )

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ev_keydown</span>(
        self, event: tcod<span style="color:#f92672">.</span>event<span style="color:#f92672">.</span>KeyDown
    ) <span style="color:#f92672">-&gt;</span> Optional[input_handlers<span style="color:#f92672">.</span>BaseEventHandler]:
        <span style="color:#66d9ef">if</span> event<span style="color:#f92672">.</span>sym <span style="color:#f92672">in</span> (tcod<span style="color:#f92672">.</span>event<span style="color:#f92672">.</span>K_q, tcod<span style="color:#f92672">.</span>event<span style="color:#f92672">.</span>K_ESCAPE):
            <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">SystemExit</span>()
        <span style="color:#66d9ef">elif</span> event<span style="color:#f92672">.</span>sym <span style="color:#f92672">==</span> tcod<span style="color:#f92672">.</span>event<span style="color:#f92672">.</span>K_c:
            <span style="color:#75715e"># TODO: Load the game here</span>
            <span style="color:#66d9ef">pass</span>
        <span style="color:#66d9ef">elif</span> event<span style="color:#f92672">.</span>sym <span style="color:#f92672">==</span> tcod<span style="color:#f92672">.</span>event<span style="color:#f92672">.</span>K_n:
            <span style="color:#66d9ef">return</span> input_handlers<span style="color:#f92672">.</span>MainGameEventHandler(new_game())

        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</code></pre></div><p>Let&rsquo;s break this code down a bit.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3">background_image <span style="color:#f92672">=</span> tcod<span style="color:#f92672">.</span>image<span style="color:#f92672">.</span>load(<span style="color:#e6db74">&#34;menu_background.png&#34;</span>)[:, :, :<span style="color:#ae81ff">3</span>]
</code></pre></div><p>This line loads the image file we&rsquo;ll use for our background in the main menu. If you haven&rsquo;t already, be sure to download that file. You can find it <a href="https://github.com/TStand90/tcod_tutorial_v2/blob/bff29c352d76068845730ff61e62cd382e5e2adc/menu_background.png">here</a>, or download it by right-clicking and saving it from here:</p>
<p><img src="/images/menu_background.png" alt="Main Menu Background Image"></p>
<p>Save the file to your project directory and you should be good to go.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">new_game</span>() <span style="color:#f92672">-&gt;</span> Engine:
    <span style="color:#e6db74">&#34;&#34;&#34;Return a brand new game session as an Engine instance.&#34;&#34;&#34;</span>
    map_width <span style="color:#f92672">=</span> <span style="color:#ae81ff">80</span>
    map_height <span style="color:#f92672">=</span> <span style="color:#ae81ff">43</span>

    room_max_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
    room_min_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>
    max_rooms <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>

    max_monsters_per_room <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
    max_items_per_room <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>

    player <span style="color:#f92672">=</span> copy<span style="color:#f92672">.</span>deepcopy(entity_factories<span style="color:#f92672">.</span>player)

    engine <span style="color:#f92672">=</span> Engine(player<span style="color:#f92672">=</span>player)

    engine<span style="color:#f92672">.</span>game_map <span style="color:#f92672">=</span> generate_dungeon(
        max_rooms<span style="color:#f92672">=</span>max_rooms,
        room_min_size<span style="color:#f92672">=</span>room_min_size,
        room_max_size<span style="color:#f92672">=</span>room_max_size,
        map_width<span style="color:#f92672">=</span>map_width,
        map_height<span style="color:#f92672">=</span>map_height,
        max_monsters_per_room<span style="color:#f92672">=</span>max_monsters_per_room,
        max_items_per_room<span style="color:#f92672">=</span>max_items_per_room,
        engine<span style="color:#f92672">=</span>engine,
    )
    engine<span style="color:#f92672">.</span>update_fov()

    engine<span style="color:#f92672">.</span>message_log<span style="color:#f92672">.</span>add_message(
        <span style="color:#e6db74">&#34;Hello and welcome, adventurer, to yet another dungeon!&#34;</span>, color<span style="color:#f92672">.</span>welcome_text
    )
    <span style="color:#66d9ef">return</span> engine
</code></pre></div><p>This should all look very familiar: it&rsquo;s the same code we used to initialize our engine in <code>main.py</code>. We initialize the same things here, but return the <code>Engine</code>, so that <code>main.py</code> can make use of it. This will help reduce the amount of code in <code>main.py</code> while also making sure that we don&rsquo;t waste time initializing the engine class if we&rsquo;re loading from a saved file.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MainMenu</span>(input_handlers<span style="color:#f92672">.</span>BaseEventHandler):
    <span style="color:#e6db74">&#34;&#34;&#34;Handle the main menu rendering and input.&#34;&#34;&#34;</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">on_render</span>(self, console: tcod<span style="color:#f92672">.</span>Console) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
        <span style="color:#e6db74">&#34;&#34;&#34;Render the main menu on a background image.&#34;&#34;&#34;</span>
        console<span style="color:#f92672">.</span>draw_semigraphics(background_image, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)

        console<span style="color:#f92672">.</span>print(
            console<span style="color:#f92672">.</span>width <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>,
            console<span style="color:#f92672">.</span>height <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">4</span>,
            <span style="color:#e6db74">&#34;TOMBS OF THE ANCIENT KINGS&#34;</span>,
            fg<span style="color:#f92672">=</span>color<span style="color:#f92672">.</span>menu_title,
            alignment<span style="color:#f92672">=</span>tcod<span style="color:#f92672">.</span>CENTER,
        )
        console<span style="color:#f92672">.</span>print(
            console<span style="color:#f92672">.</span>width <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>,
            console<span style="color:#f92672">.</span>height <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>,
            <span style="color:#e6db74">&#34;By (Your name here)&#34;</span>,
            fg<span style="color:#f92672">=</span>color<span style="color:#f92672">.</span>menu_title,
            alignment<span style="color:#f92672">=</span>tcod<span style="color:#f92672">.</span>CENTER,
        )

        menu_width <span style="color:#f92672">=</span> <span style="color:#ae81ff">24</span>
        <span style="color:#66d9ef">for</span> i, text <span style="color:#f92672">in</span> enumerate(
            [<span style="color:#e6db74">&#34;[N] Play a new game&#34;</span>, <span style="color:#e6db74">&#34;[C] Continue last game&#34;</span>, <span style="color:#e6db74">&#34;[Q] Quit&#34;</span>]
        ):
            console<span style="color:#f92672">.</span>print(
                console<span style="color:#f92672">.</span>width <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>,
                console<span style="color:#f92672">.</span>height <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> i,
                text<span style="color:#f92672">.</span>ljust(menu_width),
                fg<span style="color:#f92672">=</span>color<span style="color:#f92672">.</span>menu_text,
                bg<span style="color:#f92672">=</span>color<span style="color:#f92672">.</span>black,
                alignment<span style="color:#f92672">=</span>tcod<span style="color:#f92672">.</span>CENTER,
                bg_blend<span style="color:#f92672">=</span>tcod<span style="color:#f92672">.</span>BKGND_ALPHA(<span style="color:#ae81ff">64</span>),
            )

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ev_keydown</span>(
        self, event: tcod<span style="color:#f92672">.</span>event<span style="color:#f92672">.</span>KeyDown
    ) <span style="color:#f92672">-&gt;</span> Optional[input_handlers<span style="color:#f92672">.</span>BaseEventHandler]:
        <span style="color:#66d9ef">if</span> event<span style="color:#f92672">.</span>sym <span style="color:#f92672">in</span> (tcod<span style="color:#f92672">.</span>event<span style="color:#f92672">.</span>K_q, tcod<span style="color:#f92672">.</span>event<span style="color:#f92672">.</span>K_ESCAPE):
            <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">SystemExit</span>()
        <span style="color:#66d9ef">elif</span> event<span style="color:#f92672">.</span>sym <span style="color:#f92672">==</span> tcod<span style="color:#f92672">.</span>event<span style="color:#f92672">.</span>K_c:
            <span style="color:#75715e"># TODO: Load the game here</span>
            <span style="color:#66d9ef">pass</span>
        <span style="color:#66d9ef">elif</span> event<span style="color:#f92672">.</span>sym <span style="color:#f92672">==</span> tcod<span style="color:#f92672">.</span>event<span style="color:#f92672">.</span>K_n:
            <span style="color:#66d9ef">return</span> input_handlers<span style="color:#f92672">.</span>MainGameEventHandler(new_game())

        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</code></pre></div><p>It might seem strange to put an event handler here rather than in its normal spot (<code>input_handlers.py</code>), but this makes sense for two reasons:</p>
<ol>
<li>The main menu is specific to the start of the game.</li>
<li>It won&rsquo;t be called during the normal course of the game, like the other input handlers in that file.</li>
</ol>
<p>Anyway, the class renders the image we specified earlier, and it displays a title, <code>&quot;TOMBS OF THE ANCIENT KINGS&quot;</code>. Of course, you can change this to whatever name you have in mind for your game. It also includes a <code>&quot;By (Your name here)&quot;</code> section, so be sure to fill your name in and let everyone know who it was that worked so hard to make this game!</p>
<p>The menu also gives three choices: new game, continue last game, and quit. The <code>ev_keydown</code> method, as you might expect, handles these inputs.</p>
<ul>
<li>If the player presses &ldquo;Q&rdquo;, the game just exits.</li>
<li>If the player presses &ldquo;N&rdquo;, a new game starts. We do this by returing the <code>MainGameEventHandler</code>, and calling the <code>new_game</code> function to create our new engine.</li>
<li>If the player presses &ldquo;C&rdquo;, theoretically, a saved game should load. However, we haven&rsquo;t gotten there yet, so as of now, nothing happens.</li>
</ul>
<p>Let&rsquo;s utilize our <code>MainMenu</code> function in <code>main.py</code>, like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">#!/usr/bin/env python3
<span style="color:#f92672">-import copy
</span><span style="color:#f92672"></span>import traceback

import tcod

import color
<span style="color:#f92672">-from engine import Engine
</span><span style="color:#f92672">-import entity_factories
</span><span style="color:#f92672"></span>import exceptions
import input_handlers
<span style="color:#f92672">-from procgen import generate_dungeon
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+import setup_game
</span><span style="color:#a6e22e"></span>

def main() -&gt; None:
    screen_width = 80
    screen_height = 50

<span style="color:#f92672">-   map_width = 80
</span><span style="color:#f92672">-   map_height = 43
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-   room_max_size = 10
</span><span style="color:#f92672">-   room_min_size = 6
</span><span style="color:#f92672">-   max_rooms = 30
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-   max_monsters_per_room = 2
</span><span style="color:#f92672">-   max_items_per_room = 2
</span><span style="color:#f92672"></span>
    tileset = tcod.tileset.load_tilesheet(
        &#34;dejavu10x10_gs_tc.png&#34;, 32, 8, tcod.tileset.CHARMAP_TCOD
    )

<span style="color:#f92672">-   player = copy.deepcopy(entity_factories.player)
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-   engine = Engine(player=player)
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-   engine.game_map = generate_dungeon(
</span><span style="color:#f92672">-       max_rooms=max_rooms,
</span><span style="color:#f92672">-       room_min_size=room_min_size,
</span><span style="color:#f92672">-       room_max_size=room_max_size,
</span><span style="color:#f92672">-       map_width=map_width,
</span><span style="color:#f92672">-       map_height=map_height,
</span><span style="color:#f92672">-       max_monsters_per_room=max_monsters_per_room,
</span><span style="color:#f92672">-       max_items_per_room=max_items_per_room,
</span><span style="color:#f92672">-       engine=engine,
</span><span style="color:#f92672">-   )
</span><span style="color:#f92672">-   engine.update_fov()
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-   engine.message_log.add_message(
</span><span style="color:#f92672">-       &#34;Hello and welcome, adventurer, to yet another dungeon!&#34;, color.welcome_text
</span><span style="color:#f92672">-   )
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-   handler: input_handlers.BaseEventHandler = input_handlers.MainGameEventHandler(engine)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   handler: input_handlers.BaseEventHandler = setup_game.MainMenu()
</span><span style="color:#a6e22e"></span>
    with tcod.context.new_terminal(
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>#!/usr/bin/env python3
<span class="crossed-out-text">import copy</span>
import traceback

import tcod

import color
<span class="crossed-out-text">from engine import Engine</span>
<span class="crossed-out-text">import entity_factories</span>
import exceptions
import input_handlers
<span class="crossed-out-text">from procgen import generate_dungeon</span>
<span class="new-text">import setup_game</span>


def main() -> None:
    screen_width = 80
    screen_height = 50

    <span class="crossed-out-text">map_width = 80</span>
    <span class="crossed-out-text">map_height = 43</span>

    <span class="crossed-out-text">room_max_size = 10</span>
    <span class="crossed-out-text">room_min_size = 6</span>
    <span class="crossed-out-text">max_rooms = 30</span>

    <span class="crossed-out-text">max_monsters_per_room = 2</span>
    <span class="crossed-out-text">max_items_per_room = 2</span>

    tileset = tcod.tileset.load_tilesheet(
        "dejavu10x10_gs_tc.png", 32, 8, tcod.tileset.CHARMAP_TCOD
    )

    <span class="crossed-out-text">player = copy.deepcopy(entity_factories.player)</span>

    <span class="crossed-out-text">engine = Engine(player=player)</span>

    <span class="crossed-out-text">engine.game_map = generate_dungeon(</span>
        <span class="crossed-out-text">max_rooms=max_rooms,</span>
        <span class="crossed-out-text">room_min_size=room_min_size,</span>
        <span class="crossed-out-text">room_max_size=room_max_size,</span>
        <span class="crossed-out-text">map_width=map_width,</span>
        <span class="crossed-out-text">map_height=map_height,</span>
        <span class="crossed-out-text">max_monsters_per_room=max_monsters_per_room,</span>
        <span class="crossed-out-text">max_items_per_room=max_items_per_room,</span>
        <span class="crossed-out-text">engine=engine,</span>
    <span class="crossed-out-text">)</span>
    <span class="crossed-out-text">engine.update_fov()</span>

    <span class="crossed-out-text">engine.message_log.add_message(</span>
        <span class="crossed-out-text">"Hello and welcome, adventurer, to yet another dungeon!", color.welcome_text</span>
    <span class="crossed-out-text">)</span>

    <span class="crossed-out-text">handler: input_handlers.BaseEventHandler = input_handlers.MainGameEventHandler(engine)</span>
    <span class="new-text">handler: input_handlers.BaseEventHandler = setup_game.MainMenu()</span>

    with tcod.context.new_terminal(
        ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>We&rsquo;re removing the code that dealt with setting up the engine, as that&rsquo;s been moved into the <code>new_game</code> function. All we have to do here is set our handler to <code>MainMenu</code>, and the <code>MainMenu</code> class handles the rest from there.</p>
<p>Run the game now, and you should see the main menu!</p>
<p><img src="/images/part-10-main-menu.png" alt="Part 10 - Main Menu"></p>
<p>*<em>Note: If you run the project and get this error: <code>Process finished with exit code 139 (interrupted by signal 11: SIGSEGV)</code>, it means you didn&rsquo;t download the menu image file.</em></p>
<p>At last, we&rsquo;ve come to the part where we&rsquo;ll write the function that will save our game! This will be a method in <code>Engine</code>, and we&rsquo;ll write it like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from __future__ import annotations

<span style="color:#a6e22e">+import lzma
</span><span style="color:#a6e22e">+import pickle
</span><span style="color:#a6e22e"></span>from typing import TYPE_CHECKING
...

class Engine:
    ...

<span style="color:#a6e22e">+   def save_as(self, filename: str) -&gt; None:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Save this Engine instance as a compressed file.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       save_data = lzma.compress(pickle.dumps(self))
</span><span style="color:#a6e22e">+       with open(filename, &#34;wb&#34;) as f:
</span><span style="color:#a6e22e">+           f.write(save_data)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from __future__ import annotations

<span class="new-text">import lzma
import pickle</span>
from typing import TYPE_CHECKING
...

class Engine:
    ...

    <span class="new-text">def save_as(self, filename: str) -> None:
        """Save this Engine instance as a compressed file."""
        save_data = lzma.compress(pickle.dumps(self))
        with open(filename, "wb") as f:
            f.write(save_data)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p><code>pickle.dumps</code> serializes an object hierarchy in Python. <code>lzma.compress</code> compresses the data, so it takes up less space. We then use <code>with open(filename, &quot;wb&quot;) as f:</code> to write the file (<code>wb</code> means &ldquo;write in binary mode&rdquo;), calling <code>f.write(save_data)</code> to write the data.</p>
<p>It might be hard to believe, but this is all we need to save our game! Because all of the things we need to save exist in the <code>Engine</code> class, we can pickle it, and we&rsquo;re done!</p>
<p>Of course, it&rsquo;s not quite <em>that</em> simple. We still need to call this method, and handle a few edge cases, like when the user tries to load a save file that doesn&rsquo;t exist.</p>
<p>To save our game, we&rsquo;ll call <code>save_as</code> from our <code>main.py</code> function. We&rsquo;ll set up another function called <code>save_game</code> to call it, like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
import color
import exceptions
import setup_game
import input_handlers


<span style="color:#a6e22e">+def save_game(handler: input_handlers.BaseEventHandler, filename: str) -&gt; None:
</span><span style="color:#a6e22e">+   &#34;&#34;&#34;If the current event handler has an active Engine then save it.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+   if isinstance(handler, input_handlers.EventHandler):
</span><span style="color:#a6e22e">+       handler.engine.save_as(filename)
</span><span style="color:#a6e22e">+       print(&#34;Game saved.&#34;)
</span><span style="color:#a6e22e"></span>

def main() -&gt; None:
    ...

        ...
        except exceptions.QuitWithoutSaving:
            raise
        except SystemExit:  # Save and quit.
<span style="color:#f92672">-           # TODO: Add the save function here
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           save_game(handler, &#34;savegame.sav&#34;)
</span><span style="color:#a6e22e"></span>            raise
        except BaseException:  # Save on any other unexpected exception.
<span style="color:#f92672">-           # TODO: Add the save function here
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           save_game(handler, &#34;savegame.sav&#34;)
</span><span style="color:#a6e22e"></span>            raise


if __name__ == &#34;__main__&#34;:
    main()
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
import color
import exceptions
import setup_game
import input_handlers


<span class="new-text">def save_game(handler: input_handlers.BaseEventHandler, filename: str) -> None:
    """If the current event handler has an active Engine then save it."""
    if isinstance(handler, input_handlers.EventHandler):
        handler.engine.save_as(filename)
        print("Game saved.")</span>


def main() -> None:
    ...

        ...
        except exceptions.QuitWithoutSaving:
            raise
        except SystemExit:  # Save and quit.
            <span class="crossed-out-text"># TODO: Add the save function here</span>
            <span class="new-text">save_game(handler, "savegame.sav")</span>
            raise
        except BaseException:  # Save on any other unexpected exception.
            <span class="crossed-out-text"># TODO: Add the save function here</span>
            <span class="new-text">save_game(handler, "savegame.sav")</span>
            raise


if __name__ == "__main__":
    main()</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now when you exit the game, you should see a new <code>savegame.sav</code> in your project directory.</p>
<p>One thing that would help to handle the case where the user tries to load a saved file when one doesn&rsquo;t exist would be a pop-up message. This message will appear in the center of the screen, and disappear after any key is pressed.</p>
<p>Add this class to <code>input_handlers.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class BaseEventHandler(tcod.event.EventDispatch[ActionOrHandler]):
    ...


<span style="color:#a6e22e">+class PopupMessage(BaseEventHandler):
</span><span style="color:#a6e22e">+   &#34;&#34;&#34;Display a popup text window.&#34;&#34;&#34;
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def __init__(self, parent_handler: BaseEventHandler, text: str):
</span><span style="color:#a6e22e">+       self.parent = parent_handler
</span><span style="color:#a6e22e">+       self.text = text
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def on_render(self, console: tcod.Console) -&gt; None:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Render the parent and dim the result, then print the message on top.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       self.parent.on_render(console)
</span><span style="color:#a6e22e">+       console.tiles_rgb[&#34;fg&#34;] //= 8
</span><span style="color:#a6e22e">+       console.tiles_rgb[&#34;bg&#34;] //= 8
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+       console.print(
</span><span style="color:#a6e22e">+           console.width // 2,
</span><span style="color:#a6e22e">+           console.height // 2,
</span><span style="color:#a6e22e">+           self.text,
</span><span style="color:#a6e22e">+           fg=color.white,
</span><span style="color:#a6e22e">+           bg=color.black,
</span><span style="color:#a6e22e">+           alignment=tcod.CENTER,
</span><span style="color:#a6e22e">+       )
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def ev_keydown(self, event: tcod.event.KeyDown) -&gt; Optional[BaseEventHandler]:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Any key returns to the parent handler.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       return self.parent
</span><span style="color:#a6e22e"></span>

class EventHandler(BaseEventHandler):
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class BaseEventHandler(tcod.event.EventDispatch[ActionOrHandler]):
    ...


<span class="new-text">class PopupMessage(BaseEventHandler):
    """Display a popup text window."""

    def __init__(self, parent_handler: BaseEventHandler, text: str):
        self.parent = parent_handler
        self.text = text

    def on_render(self, console: tcod.Console) -> None:
        """Render the parent and dim the result, then print the message on top."""
        self.parent.on_render(console)
        console.tiles_rgb["fg"] //= 8
        console.tiles_rgb["bg"] //= 8

        console.print(
            console.width // 2,
            console.height // 2,
            self.text,
            fg=color.white,
            bg=color.black,
            alignment=tcod.CENTER,
        )

    def ev_keydown(self, event: tcod.event.KeyDown) -> Optional[BaseEventHandler]:
        """Any key returns to the parent handler."""
        return self.parent</span>


class EventHandler(BaseEventHandler):
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>This displays a message on top of the current display, whether it&rsquo;s the main menu or the main game. When the player presses a key (any key), the message disappears.</p>
<p>Now let&rsquo;s shift our focus to loading the game. We can add a <code>load_game</code> function in our <code>setup_game.py</code> file, which will attempt to load the game. We&rsquo;ll call it when we press the &ldquo;c&rdquo; key on the main menu. Open up <code>setup_game.py</code> and edit it like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from __future__ import annotations

import copy
<span style="color:#a6e22e">+import lzma
</span><span style="color:#a6e22e">+import pickle
</span><span style="color:#a6e22e">+import traceback
</span><span style="color:#a6e22e"></span>from typing import Optional

import tcod
...


def new_game() -&gt; Engine:
    ...


<span style="color:#a6e22e">+def load_game(filename: str) -&gt; Engine:
</span><span style="color:#a6e22e">+   &#34;&#34;&#34;Load an Engine instance from a file.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+   with open(filename, &#34;rb&#34;) as f:
</span><span style="color:#a6e22e">+       engine = pickle.loads(lzma.decompress(f.read()))
</span><span style="color:#a6e22e">+   assert isinstance(engine, Engine)
</span><span style="color:#a6e22e">+   return engine
</span><span style="color:#a6e22e"></span>

class MainMenu(input_handlers.BaseEventHandler):
    ...

    def ev_keydown(
        self, event: tcod.event.KeyDown
    ) -&gt; Optional[input_handlers.BaseEventHandler]:
        if event.sym in (tcod.event.K_q, tcod.event.K_ESCAPE):
            raise SystemExit()
        elif event.sym == tcod.event.K_c:
<span style="color:#f92672">-           # TODO: Load the game here
</span><span style="color:#f92672">-           pass
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           try:
</span><span style="color:#a6e22e">+               return input_handlers.MainGameEventHandler(load_game(&#34;savegame.sav&#34;))
</span><span style="color:#a6e22e">+           except FileNotFoundError:
</span><span style="color:#a6e22e">+               return input_handlers.PopupMessage(self, &#34;No saved game to load.&#34;)
</span><span style="color:#a6e22e">+           except Exception as exc:
</span><span style="color:#a6e22e">+               traceback.print_exc()  # Print to stderr.
</span><span style="color:#a6e22e">+               return input_handlers.PopupMessage(self, f&#34;Failed to load save:\n{exc}&#34;)
</span><span style="color:#a6e22e"></span>        elif event.sym == tcod.event.K_n:
            return input_handlers.MainGameEventHandler(new_game())

        return None
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from __future__ import annotations

import copy
<span class="new-text">import lzma</span>
<span class="new-text">import pickle</span>
<span class="new-text">import traceback</span>
from typing import Optional

import tcod
...


def new_game() -> Engine:
    ...


<span class="new-text">def load_game(filename: str) -> Engine:
    """Load an Engine instance from a file."""
    with open(filename, "rb") as f:
        engine = pickle.loads(lzma.decompress(f.read()))
    assert isinstance(engine, Engine)
    return engine</span>


class MainMenu(input_handlers.BaseEventHandler):
    ...

    def ev_keydown(
        self, event: tcod.event.KeyDown
    ) -> Optional[input_handlers.BaseEventHandler]:
        if event.sym in (tcod.event.K_q, tcod.event.K_ESCAPE):
            raise SystemExit()
        elif event.sym == tcod.event.K_c:
            <span class="crossed-out-text"># TODO: Load the game here</span>
            <span class="crossed-out-text">pass</span>
            <span class="new-text">try:
                return input_handlers.MainGameEventHandler(load_game("savegame.sav"))
            except FileNotFoundError:
                return input_handlers.PopupMessage(self, "No saved game to load.")
            except Exception as exc:
                traceback.print_exc()  # Print to stderr.
                return input_handlers.PopupMessage(self, f"Failed to load save:\n{exc}")</span>
        elif event.sym == tcod.event.K_n:
            return input_handlers.MainGameEventHandler(new_game())

        return None</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p><code>load_game</code> essentially works the opposite of <code>save_as</code>, by opening up the file, uncompressing and unpickling it, and returning the instance of the <code>Engine</code> class. It then passes that engine to <code>MainGameEventHandler</code>. If no save game exists, or an error occured, we display a popup message.</p>
<p>And with that change, we can load our game! Try exiting your game and loading it afterwards.</p>
<p>The implementation as it exists now does have one major issue though: the player can load their save file after dying, and doing so actually allows the player to take an extra turn! The player can&rsquo;t continue the game after that though, as our game immediately after detects that the player is dead, and the game state reverts to a game over. Still, this is an odd little bug that can be fixed quite simply: by deleting the save game file after the player dies.</p>
<p>To do that, we can override the <code>ev_quit</code> method in <code>GameOverEventHandler</code>. Open up <code>input_handlers.py</code> and make the following fix:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">from __future__ import annotations

<span style="color:#a6e22e">+import os
</span><span style="color:#a6e22e"></span>
from typing import Callable, Optional, Tuple, TYPE_CHECKING, Union
...


class GameOverEventHandler(EventHandler):
<span style="color:#a6e22e">+   def on_quit(self) -&gt; None:
</span><span style="color:#a6e22e">+       &#34;&#34;&#34;Handle exiting out of a finished game.&#34;&#34;&#34;
</span><span style="color:#a6e22e">+       if os.path.exists(&#34;savegame.sav&#34;):
</span><span style="color:#a6e22e">+           os.remove(&#34;savegame.sav&#34;)  # Deletes the active save file.
</span><span style="color:#a6e22e">+       raise exceptions.QuitWithoutSaving()  # Avoid saving a finished game.
</span><span style="color:#a6e22e"></span>
<span style="color:#a6e22e">+   def ev_quit(self, event: tcod.event.Quit) -&gt; None:
</span><span style="color:#a6e22e">+       self.on_quit()
</span><span style="color:#a6e22e"></span>
    def ev_keydown(self, event: tcod.event.KeyDown) -&gt; None:
        if event.sym == tcod.event.K_ESCAPE:
<span style="color:#f92672">-           raise SystemExit()
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           self.on_quit()
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from __future__ import annotations

<span class="new-text">import os</span>

from typing import Callable, Optional, Tuple, TYPE_CHECKING, Union
...


class GameOverEventHandler(EventHandler):
    <span class="new-text">def on_quit(self) -> None:
        """Handle exiting out of a finished game."""
        if os.path.exists("savegame.sav"):
            os.remove("savegame.sav")  # Deletes the active save file.
        raise exceptions.QuitWithoutSaving()  # Avoid saving a finished game.

    def ev_quit(self, event: tcod.event.Quit) -> None:
        self.on_quit()</span>

    def ev_keydown(self, event: tcod.event.KeyDown) -> None:
        if event.sym == tcod.event.K_ESCAPE:
            <span class="crossed-out-text">raise SystemExit()</span>
            <span class="new-text">self.on_quit()</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>We use the <code>os</code> module to find the save file, and if it exists, we remove it. We then raise <code>QuitWithoutSaving</code>, so that the game won&rsquo;t be saved on exiting. Now when the player meets his or her tragic end (it&rsquo;s a roguelike, it&rsquo;s inevitable!), the save file will be deleted.</p>
<p>Last thing before we wrap up: We&rsquo;re creating the <code>.sav</code> files to represent our saved games, but we don&rsquo;t want to include these in our Git repository, since that should be reserved for just the code. The fix for this is to add this to our <code>.gitignore</code> file:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

  
<div class="data-pane active" data-pane="diff">
  
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#a6e22e">+# Saved games
</span><span style="color:#a6e22e">+*.sav
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="new-text"># Saved games
*.sav</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p><em>The rest of the .gitignore is omitted, as your .gitignore file may look different from mine. It doesn&rsquo;t matter where you add this in.</em></p>
<p>If you want to see the code so far in its entirety, <a href="https://github.com/TStand90/tcod_tutorial_v2/tree/2020/part-10">click here</a>.</p>
<p><a href="/tutorials/tcod/v2/part-11">Click here to move on to the next part of this tutorial.</a></p>


    

    


</article>



        </div>

        <aside class="col-12 col-lg-3 ml-auto blog-sidebar">
    
    
        <section>
    
        
    
        
    
</section>
    
</aside>

      </div>
    </div>
    

    
      







<footer class="blog-footer w-100">
    <nav class="navbar navbar-light bg-light">
        <p class="w-100 text-center">Last updated July 7th, 2020</p>
        <p class="w-100 text-center"><a href="#">Back to top</a></p>
    </nav>
</footer>

    

    
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
