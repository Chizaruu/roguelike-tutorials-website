<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Part 9 - Ranged Scrolls and Targeting" />
<meta property="og:description" content="Adding health potions was a big step, but we won&rsquo;t stop there. Let&rsquo;s continue adding a few items, this time with a focus on offense. We&rsquo;ll add a few scrolls, which will give the player a one-time ranged attack. This gives the player a lot more tactical options to work with, and is definitely something you&rsquo;ll want to expand upon in your own game.
Let&rsquo;s start simple, with a spell that just hits the closest enemy." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rogueliketutorials.com/tutorials/tcod/2019/part-9/" /><meta property="article:section" content="tutorials" />
<meta property="article:published_time" content="2019-03-30T09:34:01-07:00" />
<meta property="article:modified_time" content="2019-03-30T09:34:01-07:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Part 9 - Ranged Scrolls and Targeting"/>
<meta name="twitter:description" content="Adding health potions was a big step, but we won&rsquo;t stop there. Let&rsquo;s continue adding a few items, this time with a focus on offense. We&rsquo;ll add a few scrolls, which will give the player a one-time ranged attack. This gives the player a lot more tactical options to work with, and is definitely something you&rsquo;ll want to expand upon in your own game.
Let&rsquo;s start simple, with a spell that just hits the closest enemy."/>



    <link rel="canonical" href="https://rogueliketutorials.com/tutorials/tcod/2019/part-9/">

    <title>
      
        Part 9 - Ranged Scrolls and Targeting | Roguelike Tutorials
      
    </title>

    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="https://rogueliketutorials.com/css/style.css" rel="stylesheet">

    

    

    
  </head>
  <body>
    
      

<header class="blog-header">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <a class="navbar-brand" href="/">
            Roguelike Tutorials
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-between" id="navbarNav">
            <ul class="navbar-nav">
                
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/">Home</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutorials/tcod/2019/">TCOD Tutorial (2019)</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutorials/tcod/v2/">TCOD Tutorial (2020)</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/about/">About</a>
                    
                </li>
                
            </ul>
            
        </div>
    </nav>
</header>

    

    
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-8 blog-main">

          

<header>
    <h2 class="blog-post-title">
    <a class="text-dark" href="/tutorials/tcod/2019/part-9/">Part 9 - Ranged Scrolls and Targeting</a>
</h2>

    


<div class="blog-post-date text-secondary">
    
        <time datetime="2019-03-30">Mar 30, 2019</time>
    
    
</div>

    
    
    <hr>
</header>
<article class="blog-post">
    <p>Adding health potions was a big step, but we won&rsquo;t stop there. Let&rsquo;s
continue adding a few items, this time with a focus on offense. We&rsquo;ll
add a few scrolls, which will give the player a one-time ranged attack.
This gives the player a lot more tactical options to work with, and is
definitely something you&rsquo;ll want to expand upon in your own game.</p>
<p>Let&rsquo;s start simple, with a spell that just hits the closest enemy. We&rsquo;ll
create a scroll of lightning, which automatically targets an enemy
nearby the player. Start by adding the function to <code>item_functions.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def heal(*args, **kwargs):
    ...

<span style="color:#a6e22e">+def cast_lightning(*args, **kwargs):
</span><span style="color:#a6e22e">+   caster = args[0]
</span><span style="color:#a6e22e">+   entities = kwargs.get(&#39;entities&#39;)
</span><span style="color:#a6e22e">+   fov_map = kwargs.get(&#39;fov_map&#39;)
</span><span style="color:#a6e22e">+   damage = kwargs.get(&#39;damage&#39;)
</span><span style="color:#a6e22e">+   maximum_range = kwargs.get(&#39;maximum_range&#39;)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   results = []
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   target = None
</span><span style="color:#a6e22e">+   closest_distance = maximum_range + 1
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   for entity in entities:
</span><span style="color:#a6e22e">+       if entity.fighter and entity != caster and libtcod.map_is_in_fov(fov_map, entity.x, entity.y):
</span><span style="color:#a6e22e">+           distance = caster.distance_to(entity)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           if distance &lt; closest_distance:
</span><span style="color:#a6e22e">+               target = entity
</span><span style="color:#a6e22e">+               closest_distance = distance
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   if target:
</span><span style="color:#a6e22e">+       results.append({&#39;consumed&#39;: True, &#39;target&#39;: target, &#39;message&#39;: Message(&#39;A lighting bolt strikes the {0} with a loud thunder! The damage is {1}&#39;.format(target.name, damage))})
</span><span style="color:#a6e22e">+       results.extend(target.fighter.take_damage(damage))
</span><span style="color:#a6e22e">+   else:
</span><span style="color:#a6e22e">+       results.append({&#39;consumed&#39;: False, &#39;target&#39;: None, &#39;message&#39;: Message(&#39;No enemy is close enough to strike.&#39;, libtcod.red)})
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   return results
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def heal(*args, **kwargs):
    ...

<span class="new-text">def cast_lightning(*args, **kwargs):
    caster = args[0]
    entities = kwargs.get('entities')
    fov_map = kwargs.get('fov_map')
    damage = kwargs.get('damage')
    maximum_range = kwargs.get('maximum_range')

    results = []

    target = None
    closest_distance = maximum_range + 1

    for entity in entities:
        if entity.fighter and entity != caster and libtcod.map_is_in_fov(fov_map, entity.x, entity.y):
            distance = caster.distance_to(entity)

            if distance < closest_distance:
                target = entity
                closest_distance = distance

    if target:
        results.append({'consumed': True, 'target': target, 'message': Message('A lighting bolt strikes the {0} with a loud thunder! The damage is {1}'.format(target.name, damage))})
        results.extend(target.fighter.take_damage(damage))
    else:
        results.append({'consumed': False, 'target': None, 'message': Message('No enemy is close enough to strike.', libtcod.red)})

    return results</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now let&rsquo;s add a chance for this scroll to drop on the map. Most of the
items will still be health potions, but we&rsquo;ll sprinkle in a few
lightning scrolls as well. In <code>game_map.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            if not any([entity for entity in entities if entity.x == x and entity.y == y]):
<span style="color:#a6e22e">+               item_chance = randint(0, 100)
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-               item_component = Item(use_function=heal, amount=4)
</span><span style="color:#f92672">-               item = Entity(x, y, &#39;!&#39;, libtcod.violet, &#39;Healing Potion&#39;, render_order=RenderOrder.ITEM,
</span><span style="color:#f92672">-                              item=item_component)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               if item_chance &lt; 70:
</span><span style="color:#a6e22e">+                   item_component = Item(use_function=heal, amount=4)
</span><span style="color:#a6e22e">+                   item = Entity(x, y, &#39;!&#39;, libtcod.violet, &#39;Healing Potion&#39;, render_order=RenderOrder.ITEM,
</span><span style="color:#a6e22e">+                                 item=item_component)
</span><span style="color:#a6e22e">+               else:
</span><span style="color:#a6e22e">+                   item_component = Item(use_function=cast_lightning, damage=20, maximum_range=5)
</span><span style="color:#a6e22e">+                   item = Entity(x, y, &#39;#&#39;, libtcod.yellow, &#39;Lightning Scroll&#39;, render_order=RenderOrder.ITEM,
</span><span style="color:#a6e22e">+                                 item=item_component)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            if not any([entity for entity in entities if entity.x == x and entity.y == y]):
                <span class="new-text">item_chance = randint(0, 100)

                if item_chance < 70:</span>
                    <span style="color: blue">item_component = Item(use_function=heal, amount=4)
                    item = Entity(x, y, '!', libtcod.violet, 'Healing Potion', render_order=RenderOrder.ITEM,
                                  item=item_component)</span>
                <span class="new-text">else:
                    item_component = Item(use_function=cast_lightning, damage=20, maximum_range=5)
                    item = Entity(x, y, '#', libtcod.yellow, 'Lightning Scroll', render_order=RenderOrder.ITEM,
                                  item=item_component)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Be sure to import <code>cast_lightning</code> at the top of the file.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
from entity import Entity

<span style="color:#f92672">-from item_functions import heal
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from item_functions import cast_lightning, heal
</span><span style="color:#a6e22e"></span>
from map_objects.rectangle import Rect
...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
from entity import Entity

from item_functions import <span class="new-text">cast_lightning,</span> heal

from map_objects.rectangle import Rect
...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Lastly, we&rsquo;ll need to adjust our &ldquo;use&rdquo; call in <code>engine.py</code>, since our
lightning spell is expecting more keyword arguments than we&rsquo;re currently
passing.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            if game_state == GameStates.SHOW_INVENTORY:
<span style="color:#f92672">-               player_turn_results.extend(player.inventory.use(item))
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+               player_turn_results.extend(player.inventory.use(item, entities=entities, fov_map=fov_map))
</span><span style="color:#a6e22e"></span>            elif game_state == GameStates.DROP_INVENTORY:
                player_turn_results.extend(player.inventory.drop_item(item))
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            if game_state == GameStates.SHOW_INVENTORY:
                <span class="crossed-out-text">player_turn_results.extend(player.inventory.use(item))</span>
                <span class="new-text">player_turn_results.extend(player.inventory.use(item, entities=entities, fov_map=fov_map))</span>
            elif game_state == GameStates.DROP_INVENTORY:
                player_turn_results.extend(player.inventory.drop_item(item))</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Run the project now, and you should have a working lightning scroll.
That was pretty easy!</p>
<p><em>*Tip: For testing, you may want to increase the maximum amount of
items per room.</em></p>
<p>Needless to say, the spell would be much more usable if we were allowed
to select the target. While we won&rsquo;t change the lightning spell, we
should have another type of spell that allows targeting. Let&rsquo;s focus on
creating a fireball spell, which will not only ask for a target, but
also hit multiple enemies in a set radius.</p>
<p>We&rsquo;ll work backwards in this case, by starting with the end result (the
&ldquo;fireball&rdquo; spell) and modifying everything else to make this work.
Here&rsquo;s the fireball spell, which should go in <code>item_functions.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
def cast_lightning(*args, **kwargs):
    ...

<span style="color:#a6e22e">+def cast_fireball(*args, **kwargs):
</span><span style="color:#a6e22e">+   entities = kwargs.get(&#39;entities&#39;)
</span><span style="color:#a6e22e">+   fov_map = kwargs.get(&#39;fov_map&#39;)
</span><span style="color:#a6e22e">+   damage = kwargs.get(&#39;damage&#39;)
</span><span style="color:#a6e22e">+   radius = kwargs.get(&#39;radius&#39;)
</span><span style="color:#a6e22e">+   target_x = kwargs.get(&#39;target_x&#39;)
</span><span style="color:#a6e22e">+   target_y = kwargs.get(&#39;target_y&#39;)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   results = []
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   if not libtcod.map_is_in_fov(fov_map, target_x, target_y):
</span><span style="color:#a6e22e">+       results.append({&#39;consumed&#39;: False, &#39;message&#39;: Message(&#39;You cannot target a tile outside your field of view.&#39;, libtcod.yellow)})
</span><span style="color:#a6e22e">+       return results
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   results.append({&#39;consumed&#39;: True, &#39;message&#39;: Message(&#39;The fireball explodes, burning everything within {0} tiles!&#39;.format(radius), libtcod.orange)})
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   for entity in entities:
</span><span style="color:#a6e22e">+       if entity.distance(target_x, target_y) &lt;= radius and entity.fighter:
</span><span style="color:#a6e22e">+           results.append({&#39;message&#39;: Message(&#39;The {0} gets burned for {1} hit points.&#39;.format(entity.name, damage), libtcod.orange)})
</span><span style="color:#a6e22e">+           results.extend(entity.fighter.take_damage(damage))
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   return results
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
def cast_lightning(*args, **kwargs):
    ...

<span class="new-text">def cast_fireball(*args, **kwargs):
    entities = kwargs.get('entities')
    fov_map = kwargs.get('fov_map')
    damage = kwargs.get('damage')
    radius = kwargs.get('radius')
    target_x = kwargs.get('target_x')
    target_y = kwargs.get('target_y')

    results = []

    if not libtcod.map_is_in_fov(fov_map, target_x, target_y):
        results.append({'consumed': False, 'message': Message('You cannot target a tile outside your field of view.', libtcod.yellow)})
        return results

    results.append({'consumed': True, 'message': Message('The fireball explodes, burning everything within {0} tiles!'.format(radius), libtcod.orange)})

    for entity in entities:
        if entity.distance(target_x, target_y) <= radius and entity.fighter:
            results.append({'message': Message('The {0} gets burned for {1} hit points.'.format(entity.name, damage), libtcod.orange)})
            results.extend(entity.fighter.take_damage(damage))

    return results</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>What do we need to do to make this function work? The most obvious thing
is to pass the damage, radius, and target location. Damage and radius
are easy; we can do those when we create the item in <code>place_entities</code>.
The target is trickier, because we don&rsquo;t know that is until the player
selects a tile after using the item.</p>
<p>We&rsquo;re going to need another game state for targeting. When the player
selects a certain type of item, the game will ask him or her to select a
location before proceeding. The player then can left-click on a
location, or right-click to cancel, so we&rsquo;ll need a new set of input
handlers as well.</p>
<p>Start with the easy part: Add a new game state to <code>GameStates</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class GameStates(Enum):
    PLAYERS_TURN = 1
    ENEMY_TURN = 2
    PLAYER_DEAD = 3
    SHOW_INVENTORY = 4
    DROP_INVENTORY = 5
<span style="color:#a6e22e">+   TARGETING = 6
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class GameStates(Enum):
    PLAYERS_TURN = 1
    ENEMY_TURN = 2
    PLAYER_DEAD = 3
    SHOW_INVENTORY = 4
    DROP_INVENTORY = 5
    <span class="new-text">TARGETING = 6</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now let&rsquo;s modify the input handlers. We&rsquo;ll add a function for the keys
while we&rsquo;re targeting, and also add a generalized mouse handler, to know
where the player clicks.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def handle_keys(key, game_state):
    if game_state == GameStates.PLAYERS_TURN:
        return handle_player_turn_keys(key)
    elif game_state == GameStates.PLAYER_DEAD:
        return handle_player_dead_keys(key)
<span style="color:#a6e22e">+   elif game_state == GameStates.TARGETING:
</span><span style="color:#a6e22e">+       return handle_targeting_keys(key)
</span><span style="color:#a6e22e"></span>    elif game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
        return handle_inventory_keys(key)
    ...


<span style="color:#a6e22e">+def handle_targeting_keys(key):
</span><span style="color:#a6e22e">+   if key.vk == libtcod.KEY_ESCAPE:
</span><span style="color:#a6e22e">+       return {&#39;exit&#39;: True}
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   return {}
</span><span style="color:#a6e22e"></span>
def handle_player_dead_keys(key):
    ...


<span style="color:#a6e22e">+def handle_mouse(mouse):
</span><span style="color:#a6e22e">+   (x, y) = (mouse.cx, mouse.cy)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   if mouse.lbutton_pressed:
</span><span style="color:#a6e22e">+       return {&#39;left_click&#39;: (x, y)}
</span><span style="color:#a6e22e">+   elif mouse.rbutton_pressed:
</span><span style="color:#a6e22e">+       return {&#39;right_click&#39;: (x, y)}
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   return {}
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def handle_keys(key, game_state):
    if game_state == GameStates.PLAYERS_TURN:
        return handle_player_turn_keys(key)
    elif game_state == GameStates.PLAYER_DEAD:
        return handle_player_dead_keys(key)
    <span class="new-text">elif game_state == GameStates.TARGETING:
        return handle_targeting_keys(key)</span>
    elif game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
        return handle_inventory_keys(key)
    ...


<span class="new-text">def handle_targeting_keys(key):
    if key.vk == libtcod.KEY_ESCAPE:
        return {'exit': True}

    return {}</span>

def handle_player_dead_keys(key):
    ...


<span class="new-text">def handle_mouse(mouse):
    (x, y) = (mouse.cx, mouse.cy)

    if mouse.lbutton_pressed:
        return {'left_click': (x, y)}
    elif mouse.rbutton_pressed:
        return {'right_click': (x, y)}

    return {}</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>If the player is in targeting mode, the only key we&rsquo;ll accept is Escape,
which cancels the targeting. The mouse handler doesn&rsquo;t take the game
state into account; it just tells the engine if the left or right mouse
button was clicked. The engine will have to decide what to do with that.
Modify <code>engine.py</code> to accept the mouse inputs:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
        action = handle_keys(key, game_state)
<span style="color:#a6e22e">+       mouse_action = handle_mouse(mouse)
</span><span style="color:#a6e22e"></span>
        move = action.get(&#39;move&#39;)
        pickup = action.get(&#39;pickup&#39;)
        show_inventory = action.get(&#39;show_inventory&#39;)
        inventory_index = action.get(&#39;inventory_index&#39;)
        exit = action.get(&#39;exit&#39;)
        fullscreen = action.get(&#39;fullscreen&#39;)

<span style="color:#a6e22e">+       left_click = mouse_action.get(&#39;left_click&#39;)
</span><span style="color:#a6e22e">+       right_click = mouse_action.get(&#39;right_click&#39;)
</span><span style="color:#a6e22e"></span>
        player_turn_results = []
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        ...
        action = handle_keys(key, game_state)
        <span class="new-text">mouse_action = handle_mouse(mouse)</span>

        move = action.get('move')
        pickup = action.get('pickup')
        show_inventory = action.get('show_inventory')
        inventory_index = action.get('inventory_index')
        exit = action.get('exit')
        fullscreen = action.get('fullscreen')

        <span class="new-text">left_click = mouse_action.get('left_click')
        right_click = mouse_action.get('right_click')</span>

        player_turn_results = []</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Of course, we need to import <code>handle_mouse</code> into <code>engine.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
from game_states import GameStates
<span style="color:#f92672">-from input_handlers import handle_keys
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from input_handlers import handle_keys, handle_mouse
</span><span style="color:#a6e22e"></span>from map_objects.game_map import GameMap
...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
from game_states import GameStates
from input_handlers import handle_keys<span class="new-text">, handle_mouse</span>
from map_objects.game_map import GameMap
...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>So how do we even know what types of items need to select a target? We
can add an attribute to the <code>Item</code> component which will tell us. We
should also add a message, which will display when the user activates
the item, to inform the user that a target needs to be selected. Modify
the <code>__init__</code> function in <code>Item</code> like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class Item:
<span style="color:#f92672">-   def __init__(self, use_function=None, **kwargs):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def __init__(self, use_function=None, targeting=False, targeting_message=None, **kwargs):
</span><span style="color:#a6e22e"></span>        self.use_function = use_function
<span style="color:#a6e22e">+       self.targeting = targeting
</span><span style="color:#a6e22e">+       self.targeting_message = targeting_message
</span><span style="color:#a6e22e"></span>        self.function_kwargs = kwargs
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class Item:
    def __init__(self, use_function=None, <span class="new-text">targeting=False, targeting_message=None,</span> **kwargs):
        self.use_function = use_function
        <span class="new-text">self.targeting = targeting
        self.targeting_message = targeting_message</span>
        self.function_kwargs = kwargs</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Because we&rsquo;re setting the values of <code>targeting</code> and <code>targeting_message</code>
to <code>None</code> by default, we don&rsquo;t have to worry about changing the items
we&rsquo;ve already made.</p>
<p>We&rsquo;ll need to change our <code>use</code> function in <code>Inventory</code> to take the
targeting variable into account. If the item needs a target, we should
return a result that tells the engine that, and not use the item. If
not, we proceed as before. Add a new &ldquo;if&rdquo; statement to <code>use</code>, and wrap
the previous code section in the &ldquo;else&rdquo; clause, like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def use(self, item_entity, **kwargs):
        results = []

        item_component = item_entity.item

        if item_component.use_function is None:
            results.append({&#39;message&#39;: Message(&#39;The {0} cannot be used&#39;.format(item_entity.name), libtcod.yellow)})
        else:
<span style="color:#f92672">-           kwargs = {**item_component.function_kwargs, **kwargs}
</span><span style="color:#f92672">-           item_use_results = item_component.use_function(self.owner, **kwargs)
</span><span style="color:#f92672"></span>
<span style="color:#f92672">-           for item_use_result in item_use_results:
</span><span style="color:#f92672">-               if item_use_result.get(&#39;consumed&#39;):
</span><span style="color:#f92672">-                   self.remove_item(item_entity)
</span><span style="color:#f92672">-
</span><span style="color:#f92672">-           results.extend(item_use_results)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           if item_component.targeting and not (kwargs.get(&#39;target_x&#39;) or kwargs.get(&#39;target_y&#39;)):
</span><span style="color:#a6e22e">+               results.append({&#39;targeting&#39;: item_entity})
</span><span style="color:#a6e22e">+           else:
</span><span style="color:#a6e22e">+               kwargs = {**item_component.function_kwargs, **kwargs}
</span><span style="color:#a6e22e">+               item_use_results = item_component.use_function(self.owner, **kwargs)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               for item_use_result in item_use_results:
</span><span style="color:#a6e22e">+                   if item_use_result.get(&#39;consumed&#39;):
</span><span style="color:#a6e22e">+                       self.remove_item(item_entity)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                results.extend(item_use_results)
</span><span style="color:#a6e22e"></span>
        return results
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    def use(self, item_entity, **kwargs):
        results = []

        item_component = item_entity.item

        if item_component.use_function is None:
            results.append({'message': Message('The {0} cannot be used'.format(item_entity.name), libtcod.yellow)})
        else:
            <span class="new-text">if item_component.targeting and not (kwargs.get('target_x') or kwargs.get('target_y')):
                results.append({'targeting': item_entity})
            else:</span>
                <span style="color: blue">kwargs = {**item_component.function_kwargs, **kwargs}
                item_use_results = item_component.use_function(self.owner, **kwargs)

                for item_use_result in item_use_results:
                    if item_use_result.get('consumed'):
                        self.remove_item(item_entity)

                results.extend(item_use_results)</span>

        return results</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>So basically, we check if the item has &ldquo;targeting&rdquo; set to True, and if
it does, whether or not we received the <code>target_x</code> and <code>target_y</code>
variables. If we didn&rsquo;t we can assume that the target has not yet been
selected, and the game state needs to switch to targeting. If it did, we
can use the item like normal.</p>
<p>Now let&rsquo;s modify the engine to handle this new result type. Note that
this result returns the item entity to the engine. That&rsquo;s because the
engine will need to &ldquo;remember&rdquo; which item was selected in the first
place. Therefore, we&rsquo;ll need a new variable right before the main game
loop to keep track of the targeting item that was selected.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...
    game_state = GameStates.PLAYERS_TURN
    previous_game_state = game_state

<span style="color:#a6e22e">+   targeting_item = None
</span><span style="color:#a6e22e"></span>
    while not libtcod.console_is_window_closed():
        ...
            message = player_turn_result.get(&#39;message&#39;)
            dead_entity = player_turn_result.get(&#39;dead&#39;)
            item_added = player_turn_result.get(&#39;item_added&#39;)
            item_consumed = player_turn_result.get(&#39;consumed&#39;)
            item_dropped = player_turn_result.get(&#39;item_dropped&#39;)
<span style="color:#a6e22e">+           targeting = player_turn_result.get(&#39;targeting&#39;)
</span><span style="color:#a6e22e"></span>            ...

            if item_consumed:
                game_state = GameStates.ENEMY_TURN

<span style="color:#a6e22e">+           if targeting:
</span><span style="color:#a6e22e">+               previous_game_state = GameStates.PLAYERS_TURN
</span><span style="color:#a6e22e">+               game_state = GameStates.TARGETING
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               targeting_item = targeting
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               message_log.add_message(targeting_item.item.targeting_message)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    ...
    game_state = GameStates.PLAYERS_TURN
    previous_game_state = game_state

    <span class="new-text">targeting_item = None</span>

    while not libtcod.console_is_window_closed():
        ...
            message = player_turn_result.get('message')
            dead_entity = player_turn_result.get('dead')
            item_added = player_turn_result.get('item_added')
            item_consumed = player_turn_result.get('consumed')
            item_dropped = player_turn_result.get('item_dropped')
            <span class="new-text">targeting = player_turn_result.get('targeting')</span>
            ...

            if item_consumed:
                game_state = GameStates.ENEMY_TURN

            <span class="new-text">if targeting:
                previous_game_state = GameStates.PLAYERS_TURN
                game_state = GameStates.TARGETING

                targeting_item = targeting

                message_log.add_message(targeting_item.item.targeting_message)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now our game state will switch to targeting when we select an item from
the inventory that needs it. Note that we&rsquo;re doing something a little
strange with the previous game state; we&rsquo;re setting it to the player&rsquo;s
turn rather than the actual previous state. This is so that cancelling
the targeting will not reopen the inventory screen.</p>
<p>Let&rsquo;s now do something with the left and right clicks we added in
before. If the player left clicks while in targeting, we&rsquo;ll activate the
use function again, this time with the target variables. If the user
right clicks, we&rsquo;ll cancel the targeting. We can also add the cancel
targeting on Escape now.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
        if inventory_index is not None and previous_game_state != GameStates.PLAYER_DEAD and inventory_index &lt; len(
                player.inventory.items):
            ...

<span style="color:#a6e22e">+       if game_state == GameStates.TARGETING:
</span><span style="color:#a6e22e">+           if left_click:
</span><span style="color:#a6e22e">+               target_x, target_y = left_click
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               item_use_results = player.inventory.use(targeting_item, entities=entities, fov_map=fov_map,
</span><span style="color:#a6e22e">+                                                       target_x=target_x, target_y=target_y)
</span><span style="color:#a6e22e">+               player_turn_results.extend(item_use_results)
</span><span style="color:#a6e22e">+           elif right_click:
</span><span style="color:#a6e22e">+               player_turn_results.append({&#39;targeting_cancelled&#39;: True})
</span><span style="color:#a6e22e"></span>
        if exit:
            if game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
                game_state = previous_game_state
<span style="color:#a6e22e">+           elif game_state == GameStates.TARGETING:
</span><span style="color:#a6e22e">+               player_turn_results.append({&#39;targeting_cancelled&#39;: True})
</span><span style="color:#a6e22e"></span>            else:
                return True

        if fullscreen:
            ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        ...
        if inventory_index is not None and previous_game_state != GameStates.PLAYER_DEAD and inventory_index < len(
                player.inventory.items):
            ...

        <span class="new-text">if game_state == GameStates.TARGETING:
            if left_click:
                target_x, target_y = left_click

                item_use_results = player.inventory.use(targeting_item, entities=entities, fov_map=fov_map,
                                                        target_x=target_x, target_y=target_y)
                player_turn_results.extend(item_use_results)
            elif right_click:
                player_turn_results.append({'targeting_cancelled': True})</span>

        if exit:
            if game_state in (GameStates.SHOW_INVENTORY, GameStates.DROP_INVENTORY):
                game_state = previous_game_state
            <span class="new-text">elif game_state == GameStates.TARGETING:
                player_turn_results.append({'targeting_cancelled': True})</span>
            else:
                return True

        if fullscreen:
            ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Add the following to make the target cancellation revert the game state:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            targeting = player_turn_result.get(&#39;targeting&#39;)
<span style="color:#a6e22e">+           targeting_cancelled = player_turn_result.get(&#39;targeting_cancelled&#39;)
</span><span style="color:#a6e22e"></span>
            if message:
                ...

<span style="color:#a6e22e">+           if targeting_cancelled:
</span><span style="color:#a6e22e">+               game_state = previous_game_state
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               message_log.add_message(Message(&#39;Targeting cancelled&#39;))
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            targeting = player_turn_result.get('targeting')
            <span class="new-text">targeting_cancelled = player_turn_result.get('targeting_cancelled')</span>

            if message:
                ...

            <span class="new-text">if targeting_cancelled:
                game_state = previous_game_state

                message_log.add_message(Message('Targeting cancelled'))</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Finally, let&rsquo;s add the fireball scroll to the map. Modify
<code>place_entities</code> like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">                ...
                item_chance = randint(0, 100)

                if item_chance &lt; 70:
                    item_component = Item(use_function=heal, amount=4)
                    item = Entity(x, y, &#39;!&#39;, libtcod.violet, &#39;Healing Potion&#39;, render_order=RenderOrder.ITEM,
                                  item=item_component)
<span style="color:#a6e22e">+               elif item_chance &lt; 85:
</span><span style="color:#a6e22e">+                   item_component = Item(use_function=cast_fireball, targeting=True, targeting_message=Message(
</span><span style="color:#a6e22e">+                       &#39;Left-click a target tile for the fireball, or right-click to cancel.&#39;, libtcod.light_cyan),
</span><span style="color:#a6e22e">+                                         damage=12, radius=3)
</span><span style="color:#a6e22e">+                   item = Entity(x, y, &#39;#&#39;, libtcod.red, &#39;Fireball Scroll&#39;, render_order=RenderOrder.ITEM,
</span><span style="color:#a6e22e">+                                 item=item_component)
</span><span style="color:#a6e22e"></span>                else:
                    item_component = Item(use_function=cast_lightning, damage=20, maximum_range=5)
                    item = Entity(x, y, &#39;#&#39;, libtcod.yellow, &#39;Lightning Scroll&#39;, render_order=RenderOrder.ITEM,
                                  item=item_component)
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>                ...
                item_chance = randint(0, 100)

                if item_chance < 70:
                    item_component = Item(use_function=heal, amount=4)
                    item = Entity(x, y, '!', libtcod.violet, 'Healing Potion', render_order=RenderOrder.ITEM,
                                  item=item_component)
                <span class="new-text">elif item_chance < 85:
                    item_component = Item(use_function=cast_fireball, targeting=True, targeting_message=Message(
                        'Left-click a target tile for the fireball, or right-click to cancel.', libtcod.light_cyan),
                                          damage=12, radius=3)
                    item = Entity(x, y, '#', libtcod.red, 'Fireball Scroll', render_order=RenderOrder.ITEM,
                                  item=item_component)</span>
                else:
                    item_component = Item(use_function=cast_lightning, damage=20, maximum_range=5)
                    item = Entity(x, y, '#', libtcod.yellow, 'Lightning Scroll', render_order=RenderOrder.ITEM,
                                  item=item_component)</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>You&rsquo;ll need to import both <code>cast_fireball</code> and <code>Message</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
from entity import Entity

<span style="color:#a6e22e">+from game_messages import Message
</span><span style="color:#a6e22e"></span>
<span style="color:#f92672">-from item_functions import cast_lightning, heal
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from item_functions import cast_fireball, cast_lightning, heal
</span><span style="color:#a6e22e"></span>
from map_objects.rectangle import Rect
...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
from entity import Entity

<span class="new-text">from game_messages import Message</span>

from item_functions import <span class="new-text">cast_fireball,</span> cast_lightning, heal

from map_objects.rectangle import Rect
...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>One change we need to make for <code>cast_fireball</code> to work: We need a
<code>distance</code> function in <code>Entity</code>, to get the distance between the entity
and an arbitrary point.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def move_towards(self, target_x, target_y, game_map, entities):
        ...

<span style="color:#a6e22e">+   def distance(self, x, y):
</span><span style="color:#a6e22e">+       return math.sqrt((x - self.x) ** 2 + (y - self.y) ** 2)
</span><span style="color:#a6e22e"></span>
    def distance_to(self, other):
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>
    def move_towards(self, target_x, target_y, game_map, entities):
        ...

    <span class="new-text">def distance(self, x, y):
        return math.sqrt((x - self.x) ** 2 + (y - self.y) ** 2)</span>

    def distance_to(self, other):
        ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Run the project now, and you should have a functioning fireball spell!
Be careful though, the player can get damaged by this spell if you cast
it too close to yourself!</p>
<p>Let&rsquo;s add one more spell for fun: confusion. This will involve modifying
the target&rsquo;s AI for a few turns, and setting it back to normal once the
spell ends.</p>
<p>We&rsquo;ll begin by adding the confused AI, to <code>ai.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod

<span style="color:#a6e22e">+from random import randint
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+from game_messages import Message
</span><span style="color:#a6e22e"></span>

class BasicMonster:
    ...


<span style="color:#a6e22e">+class ConfusedMonster:
</span><span style="color:#a6e22e">+   def __init__(self, previous_ai, number_of_turns=10):
</span><span style="color:#a6e22e">+       self.previous_ai = previous_ai
</span><span style="color:#a6e22e">+       self.number_of_turns = number_of_turns
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   def take_turn(self, target, fov_map, game_map, entities):
</span><span style="color:#a6e22e">+       results = []
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       if self.number_of_turns &gt; 0:
</span><span style="color:#a6e22e">+           random_x = self.owner.x + randint(0, 2) - 1
</span><span style="color:#a6e22e">+           random_y = self.owner.y + randint(0, 2) - 1
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           if random_x != self.owner.x and random_y != self.owner.y:
</span><span style="color:#a6e22e">+               self.owner.move_towards(random_x, random_y, game_map, entities)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           self.number_of_turns -= 1
</span><span style="color:#a6e22e">+       else:
</span><span style="color:#a6e22e">+           self.owner.ai = self.previous_ai
</span><span style="color:#a6e22e">+           results.append({&#39;message&#39;: Message(&#39;The {0} is no longer confused!&#39;.format(self.owner.name), libtcod.red)})
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       return results
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod

<span class="new-text">from random import randint

from game_messages import Message</span>


class BasicMonster:
    ...


<span class="new-text">class ConfusedMonster:
    def __init__(self, previous_ai, number_of_turns=10):
        self.previous_ai = previous_ai
        self.number_of_turns = number_of_turns

    def take_turn(self, target, fov_map, game_map, entities):
        results = []

        if self.number_of_turns > 0:
            random_x = self.owner.x + randint(0, 2) - 1
            random_y = self.owner.y + randint(0, 2) - 1

            if random_x != self.owner.x and random_y != self.owner.y:
                self.owner.move_towards(random_x, random_y, game_map, entities)

            self.number_of_turns -= 1
        else:
            self.owner.ai = self.previous_ai
            results.append({'message': Message('The {0} is no longer confused!'.format(self.owner.name), libtcod.red)})

        return results</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>The class gets initialized with a number of turns that the entity is
confused for. It also keeps track of what the entity&rsquo;s actual AI is, so
that it can be switched back when the confusion wears off. For the
<code>take_turn</code> method, the entity moves randomly (or not at all), and one
turn gets taken off the timer. Once the timer hits 0, the entity is no
longer confused, and goes back to its previous AI.</p>
<p>Now for the confusion spell. Add the following to <code>item_functions.py</code></p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def cast_fireball(*args, **kwargs):
    ...

<span style="color:#a6e22e">+def cast_confuse(*args, **kwargs):
</span><span style="color:#a6e22e">+   entities = kwargs.get(&#39;entities&#39;)
</span><span style="color:#a6e22e">+   fov_map = kwargs.get(&#39;fov_map&#39;)
</span><span style="color:#a6e22e">+   target_x = kwargs.get(&#39;target_x&#39;)
</span><span style="color:#a6e22e">+   target_y = kwargs.get(&#39;target_y&#39;)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   results = []
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   if not libtcod.map_is_in_fov(fov_map, target_x, target_y):
</span><span style="color:#a6e22e">+       results.append({&#39;consumed&#39;: False, &#39;message&#39;: Message(&#39;You cannot target a tile outside your field of view.&#39;, libtcod.yellow)})
</span><span style="color:#a6e22e">+       return results
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   for entity in entities:
</span><span style="color:#a6e22e">+       if entity.x == target_x and entity.y == target_y and entity.ai:
</span><span style="color:#a6e22e">+           confused_ai = ConfusedMonster(entity.ai, 10)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           confused_ai.owner = entity
</span><span style="color:#a6e22e">+           entity.ai = confused_ai
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           results.append({&#39;consumed&#39;: True, &#39;message&#39;: Message(&#39;The eyes of the {0} look vacant, as he starts to stumble around!&#39;.format(entity.name), libtcod.light_green)})
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           break
</span><span style="color:#a6e22e">+   else:
</span><span style="color:#a6e22e">+       results.append({&#39;consumed&#39;: False, &#39;message&#39;: Message(&#39;There is no targetable enemy at that location.&#39;, libtcod.yellow)})
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+   return results
</span><span style="color:#a6e22e">+
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def cast_fireball(*args, **kwargs):
    ...

<span class="new-text">def cast_confuse(*args, **kwargs):
    entities = kwargs.get('entities')
    fov_map = kwargs.get('fov_map')
    target_x = kwargs.get('target_x')
    target_y = kwargs.get('target_y')

    results = []

    if not libtcod.map_is_in_fov(fov_map, target_x, target_y):
        results.append({'consumed': False, 'message': Message('You cannot target a tile outside your field of view.', libtcod.yellow)})
        return results

    for entity in entities:
        if entity.x == target_x and entity.y == target_y and entity.ai:
            confused_ai = ConfusedMonster(entity.ai, 10)

            confused_ai.owner = entity
            entity.ai = confused_ai

            results.append({'consumed': True, 'message': Message('The eyes of the {0} look vacant, as he starts to stumble around!'.format(entity.name), libtcod.light_green)})

            break
    else:
        results.append({'consumed': False, 'message': Message('There is no targetable enemy at that location.', libtcod.yellow)})

    return results
</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>You&rsquo;ll need to import the <code>ConfusedMonster</code> class to the top of the
file:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod

<span style="color:#a6e22e">+from components.ai import ConfusedMonster
</span><span style="color:#a6e22e"></span>
from game_messages import Message
...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod

<span class="new-text">from components.ai import ConfusedMonster</span>

from game_messages import Message
...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Finally, we&rsquo;ll put the scroll on the map. First, import the
<code>cast_confuse</code> function:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
from game_messages import Message

<span style="color:#f92672">-from item_functions import cast_fireball, cast_lightning, heal
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from item_functions import cast_confuse, cast_fireball, cast_lightning, heal
</span><span style="color:#a6e22e"></span>
from map_objects.rectangle import Rect
...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
from game_messages import Message

from item_functions import <span class="new-text">cast_confuse,</span> cast_fireball, cast_lightning, heal

from map_objects.rectangle import Rect
...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>We&rsquo;ll also modify the chances of our scrolls, so that each one has a 10%
chance of spawning.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">                if item_chance &lt; 70:
                    item_component = Item(use_function=heal, amount=4)
                    item = Entity(x, y, &#39;!&#39;, libtcod.violet, &#39;Healing Potion&#39;, render_order=RenderOrder.ITEM,
                                  item=item_component)
<span style="color:#f92672">-               elif item_chance &lt; 85:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+               elif item_chance &lt; 80:
</span><span style="color:#a6e22e"></span>                    item_component = Item(use_function=cast_fireball, targeting=True, targeting_message=Message(
                        &#39;Left-click a target tile for the fireball, or right-click to cancel.&#39;, libtcod.light_cyan),
                                          damage=12, radius=3)
                    item = Entity(x, y, &#39;#&#39;, libtcod.red, &#39;Fireball Scroll&#39;, render_order=RenderOrder.ITEM,
                                  item=item_component)
<span style="color:#a6e22e">+               elif item_chance &lt; 90:
</span><span style="color:#a6e22e">+                   item_component = Item(use_function=cast_confuse, targeting=True, targeting_message=Message(
</span><span style="color:#a6e22e">+                       &#39;Left-click an enemy to confuse it, or right-click to cancel.&#39;, libtcod.light_cyan))
</span><span style="color:#a6e22e">+                   item = Entity(x, y, &#39;#&#39;, libtcod.light_pink, &#39;Confusion Scroll&#39;, render_order=RenderOrder.ITEM,
</span><span style="color:#a6e22e">+                                 item=item_component)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>                if item_chance < 70:
                    item_component = Item(use_function=heal, amount=4)
                    item = Entity(x, y, '!', libtcod.violet, 'Healing Potion', render_order=RenderOrder.ITEM,
                                  item=item_component)
                <span class="crossed-out-text">elif item_chance < 85:</span>
                <span class="new-text">elif item_chance < 80:</span>
                    item_component = Item(use_function=cast_fireball, targeting=True, targeting_message=Message(
                        'Left-click a target tile for the fireball, or right-click to cancel.', libtcod.light_cyan),
                                          damage=12, radius=3)
                    item = Entity(x, y, '#', libtcod.red, 'Fireball Scroll', render_order=RenderOrder.ITEM,
                                  item=item_component)
                <span class="new-text">elif item_chance < 90:
                    item_component = Item(use_function=cast_confuse, targeting=True, targeting_message=Message(
                        'Left-click an enemy to confuse it, or right-click to cancel.', libtcod.light_cyan))
                    item = Entity(x, y, '#', libtcod.light_pink, 'Confusion Scroll', render_order=RenderOrder.ITEM,
                                  item=item_component)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Run the project, and you should be able to cast confusion on enemies.
Enemies who are confused will waste their turns either moving randomly,
or staying in one spot.</p>
<p>That&rsquo;s all for today. We now have 3 different types of scrolls the
player can utilize against enemies. Feel free to try adding more scrolls
and spells as you see fit.</p>
<p>If you want to see the code so far in its entirety, <a href="https://github.com/TStand90/roguelike_tutorial_revised/tree/part9">click
here</a>.</p>
<p><a href="/tutorials/tcod/2019/part-10">Click here to move on to the next part of this
tutorial.</a></p>
<!-- raw HTML omitted -->


    

    


</article>



        </div>

        <aside class="col-12 col-lg-3 ml-auto blog-sidebar">
    
    
        <section>
    
        
    
        
    
</section>
    
</aside>

      </div>
    </div>
    

    
      







<footer class="blog-footer w-100">
    <nav class="navbar navbar-light bg-light">
        <p class="w-100 text-center">Last updated July 7th, 2020</p>
        <p class="w-100 text-center"><a href="#">Back to top</a></p>
    </nav>
</footer>

    

    
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
