<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Part 6 - Doing (and taking) some damage" />
<meta property="og:description" content="The last part of this tutorial set us up for combat, so now it&rsquo;s time to actually implement it.
In order to make &ldquo;killable&rdquo; Entities, rather than attaching hit points to each Entity we create, we&rsquo;ll create a component, called Fighter, which will hold information related to combat, like HP, max HP, attack, and defense. If an Entity can fight, it will have this component attached to it, and if not, it won&rsquo;t." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rogueliketutorials.com/tutorials/tcod/2019/part-6/" /><meta property="article:section" content="tutorials" />
<meta property="article:published_time" content="2019-03-30T09:33:50-07:00" />
<meta property="article:modified_time" content="2019-03-30T09:33:50-07:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Part 6 - Doing (and taking) some damage"/>
<meta name="twitter:description" content="The last part of this tutorial set us up for combat, so now it&rsquo;s time to actually implement it.
In order to make &ldquo;killable&rdquo; Entities, rather than attaching hit points to each Entity we create, we&rsquo;ll create a component, called Fighter, which will hold information related to combat, like HP, max HP, attack, and defense. If an Entity can fight, it will have this component attached to it, and if not, it won&rsquo;t."/>



    <link rel="canonical" href="https://rogueliketutorials.com/tutorials/tcod/2019/part-6/">

    <title>
      
        Part 6 - Doing (and taking) some damage | Roguelike Tutorials
      
    </title>

    
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href="https://rogueliketutorials.com/css/style.css" rel="stylesheet">

    

    

    
  </head>
  <body>
    
      

<header class="blog-header">
    <nav class="navbar navbar-expand-md navbar-dark bg-dark">
        <a class="navbar-brand" href="/">
            Roguelike Tutorials
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
            aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse justify-content-between" id="navbarNav">
            <ul class="navbar-nav">
                
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/">Home</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutorials/tcod/2019/">TCOD Tutorial (2019)</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/tutorials/tcod/v2/">TCOD Tutorial (2020)</a>
                    
                </li>
                
                <li class="nav-item ">
                    
                        <a class="nav-link" href="/about/">About</a>
                    
                </li>
                
            </ul>
            
        </div>
    </nav>
</header>

    

    
    <div class="container">
      <div class="row">
        <div class="col-12 col-lg-8 blog-main">

          

<header>
    <h2 class="blog-post-title">
    <a class="text-dark" href="/tutorials/tcod/2019/part-6/">Part 6 - Doing (and taking) some damage</a>
</h2>

    


<div class="blog-post-date text-secondary">
    
        <time datetime="2019-03-30">Mar 30, 2019</time>
    
    
</div>

    
    
    <hr>
</header>
<article class="blog-post">
    <p>The last part of this tutorial set us up for combat, so now it&rsquo;s time to
actually implement it.</p>
<p>In order to make &ldquo;killable&rdquo; Entities, rather than attaching hit points
to each Entity we create, we&rsquo;ll create a <strong>component</strong>, called
<code>Fighter</code>, which will hold information related to combat, like HP, max
HP, attack, and defense. If an Entity can fight, it will have this
component attached to it, and if not, it won&rsquo;t. This way of doing things
is called <strong>composition</strong>, and it&rsquo;s an alternative to your typical
inheritance-based programming model.</p>
<p>Create a new Python package (a folder with an empty __init__.py
file), called <code>components</code>. In there, put a new file called
<code>fighter.py</code>, and put the following code in it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fighter</span>:
    <span style="color:#66d9ef">def</span> __init__(self, hp, defense, power):
        self<span style="color:#f92672">.</span>max_hp <span style="color:#f92672">=</span> hp
        self<span style="color:#f92672">.</span>hp <span style="color:#f92672">=</span> hp
        self<span style="color:#f92672">.</span>defense <span style="color:#f92672">=</span> defense
        self<span style="color:#f92672">.</span>power <span style="color:#f92672">=</span> power</code></pre></div>
<p>These variables should look familiar to anyone who&rsquo;s played an RPG
before. HP represents the entity&rsquo;s health, defense blocks damage, and
power is the entity&rsquo;s attack strength. Perhaps the game you have in mind
has a more complex combat model, but we&rsquo;ll keep it simple here.</p>
<p>Another component we&rsquo;ll need is one to define the enemy AI. Some
entities (enemies) will have AI, whereas others (player, items) will
not. We&rsquo;ll set up our game loop to allow any entity with an AI
component, regardless of what it is, to take a turn, and all others
won&rsquo;t get to.</p>
<p>Create a file in <code>components</code> called <code>ai.py</code>, and put the following
class in it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BasicMonster</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">take_turn</span>(self):
        print(<span style="color:#e6db74">&#39;The &#39;</span> <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>owner<span style="color:#f92672">.</span>name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39; wonders when it will get to move.&#39;</span>)</code></pre></div>
<p>We&rsquo;ve defined a basic method called <code>take_turn</code>, which we&rsquo;ll call in our
game loop in a minute. It&rsquo;s just a placeholder for now, but by the end
of this chapter, the <code>take_turn</code> function will actually move the entity
around.</p>
<p>With our classes in place, we&rsquo;ll turn our attention to the <code>Entity</code>
class once more. We need to pass the components through the constructor,
like we do for everything else. Modify the <code>__init__</code> function in
<code>Entity</code> to look like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class Entity:
<span style="color:#f92672">-   def __init__(self, x, y, char, color, name, blocks=False):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def __init__(self, x, y, char, color, name, blocks=False, fighter=None, ai=None):
</span><span style="color:#a6e22e"></span>        self.x = x
        self.y = y
        self.char = char
        self.color = color
        self.name = name
        self.blocks = blocks
<span style="color:#a6e22e">+       self.fighter = fighter
</span><span style="color:#a6e22e">+       self.ai = ai
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       if self.fighter:
</span><span style="color:#a6e22e">+           self.fighter.owner = self
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       if self.ai:
</span><span style="color:#a6e22e">+           self.ai.owner = self
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class Entity:
    <span class="crossed-out-text">def __init__(self, x, y, char, color, name, blocks=False):</span>
    <span class="new-text">def __init__(self, x, y, char, color, name, blocks=False, fighter=None, ai=None):</span>
        self.x = x
        self.y = y
        self.char = char
        self.color = color
        self.name = name
        self.blocks = blocks
        <span class="new-text">self.fighter = fighter
        self.ai = ai

        if self.fighter:
            self.fighter.owner = self

        if self.ai:
            self.ai.owner = self</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>So the <code>fighter</code> and <code>ai</code> components are optional, so entities that
don&rsquo;t need them won&rsquo;t need to do anything.</p>
<p>Why do we need to set the owner of the component to self? There will be
a few instances where we&rsquo;ll want to access the Entity from within the
component. In our previous bit of code for the <code>BasicMonster</code>, we gained
access to the entity&rsquo;s &ldquo;name&rdquo; simply by referencing the &ldquo;owner&rdquo;. We just
have to be sure we set the owner upon initializing the entity.</p>
<p>Now we&rsquo;ll need to add our new components to all the entities we&rsquo;ve
created so far. Let&rsquo;s start with the easiest one: the player. The player
doesn&rsquo;t actually need AI (because we&rsquo;re controlling the player object
directly), but it does need the <code>Fighter</code> component.</p>
<p>First, import the <code>Fighter</code> component into <code>engine.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod

<span style="color:#a6e22e">+from components.fighter import Fighter
</span><span style="color:#a6e22e"></span>from entity import Entity, get_blocking_entities_at_location
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod

<span class="new-text">from components.fighter import Fighter</span>
from entity import Entity, get_blocking_entities_at_location</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Then, create the component and add it to the player Entity.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#a6e22e">+   fighter_component = Fighter(hp=30, defense=2, power=5)
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-   player = Entity(0, 0, &#39;@&#39;, libtcod.white, &#39;Player&#39;, blocks=True)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   player = Entity(0, 0, &#39;@&#39;, libtcod.white, &#39;Player&#39;, blocks=True, fighter=fighter_component)
</span><span style="color:#a6e22e"></span>    entities = [player]
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
        <pre>
    <span class="new-text">fighter_component = Fighter(hp=30, defense=2, power=5)</span>
    <span class="crossed-out-text">player = Entity(0, 0, '@', libtcod.white, 'Player', blocks=True)</span>
    <span class="new-text">player = Entity(0, 0, '@', libtcod.white, 'Player', blocks=True, fighter=fighter_component)</span>
    entities = [player]
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>And now for our monsters. We&rsquo;ll need both the Fighter and BasicMonster
components for them.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">                if randint(0, 100) &lt; 80:
<span style="color:#a6e22e">+                   fighter_component = Fighter(hp=10, defense=0, power=3)
</span><span style="color:#a6e22e">+                   ai_component = BasicMonster()
</span><span style="color:#a6e22e"></span>
<span style="color:#f92672">-                   monster = Entity(x, y, &#39;o&#39;, libtcod.desaturated_green, &#39;Orc&#39;, blocks=True)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   monster = Entity(x, y, &#39;o&#39;, libtcod.desaturated_green, &#39;Orc&#39;, blocks=True,
</span><span style="color:#a6e22e">+                                    fighter=fighter_component, ai=ai_component)
</span><span style="color:#a6e22e"></span>                else:
<span style="color:#a6e22e">+                   fighter_component = Fighter(hp=16, defense=1, power=4)
</span><span style="color:#a6e22e">+                   ai_component = BasicMonster()
</span><span style="color:#a6e22e"></span>
<span style="color:#f92672">-                   monster = Entity(x, y, &#39;T&#39;, libtcod.darker_green, &#39;Troll&#39;, blocks=True)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   monster = Entity(x, y, &#39;T&#39;, libtcod.darker_green, &#39;Troll&#39;, blocks=True, fighter=fighter_component,
</span><span style="color:#a6e22e">+                                    ai=ai_component)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>
                if randint(0, 100) < 80:
                    <span class="new-text">fighter_component = Fighter(hp=10, defense=0, power=3)
                    ai_component = BasicMonster()</span>

                    <span class="crossed-out-text">monster = Entity(x, y, 'o', libtcod.desaturated_green, 'Orc', blocks=True)</span>
                    <span class="new-text">monster = Entity(x, y, 'o', libtcod.desaturated_green, 'Orc', blocks=True,
                                     fighter=fighter_component, ai=ai_component)</span>
                else:
                    <span class="new-text">fighter_component = Fighter(hp=16, defense=1, power=4)
                    ai_component = BasicMonster()</span>

                    <span class="crossed-out-text">monster = Entity(x, y, 'T', libtcod.darker_green, 'Troll', blocks=True)</span>
                    <span class="new-text">monster = Entity(x, y, 'T', libtcod.darker_green, 'Troll', blocks=True, fighter=fighter_component,
                                     ai=ai_component)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Remember to import the needed classes at the top.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod
from random import randint

<span style="color:#a6e22e">+from components.ai import BasicMonster
</span><span style="color:#a6e22e">+from components.fighter import Fighter
</span><span style="color:#a6e22e"></span>
from entity import Entity

from map_objects.rectangle import Rect
from map_objects.tile import Tile
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod
from random import randint

<span class="new-text">from components.ai import BasicMonster
from components.fighter import Fighter</span>

from entity import Entity

from map_objects.rectangle import Rect
from map_objects.tile import Tile</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now we can modify our monster&rsquo;s turn loop to use the <code>take_turn</code>
function.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
        if game_state == GameStates.ENEMY_TURN:
            for entity in entities:
<span style="color:#f92672">-               if entity != player:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+               if entity.ai:
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-                   print(&#39;The &#39; + entity.name + &#39; ponders the meaning of its existence.&#39;)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   entity.ai.take_turn()
</span><span style="color:#a6e22e"></span>
            game_state = GameStates.PLAYERS_TURN
            ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        ...
        if game_state == GameStates.ENEMY_TURN:
            for entity in entities:
                <span class="crossed-out-text">if entity != player:</span>
                <span class="new-text">if entity.ai:</span>
                    <span class="crossed-out-text">print('The ' + entity.name + ' ponders the meaning of its existence.')</span>
                    <span class="new-text">entity.ai.take_turn()</span>

            game_state = GameStates.PLAYERS_TURN
            ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Not a whole lot has changed yet (we&rsquo;re still printing something instead
of the monsters taking a real turn), but we&rsquo;re getting there. Notice
that rather than checking if the entity is not the player, we&rsquo;re
checking if the entity has an AI component. The player doesn&rsquo;t have an
AI component, so the loop will skip the player, but more importantly,
any items we implement later on won&rsquo;t get a &ldquo;turn&rdquo; either.</p>
<p>Now for our actual AI implementation. Our AI will be very simple
(stupidly so, really). If the enemy can &ldquo;see&rdquo; the player, it will move
towards the player, and if it is next to the player, it will attack. We
won&rsquo;t implement enemy FOV in this tutorial; instead, we&rsquo;ll just assume
that if you can see an enemy, it can see you too.</p>
<p>Let&rsquo;s put a basic movement function in place. Put the following code in
the <code>Entity</code> class.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def move(self, dx, dy):
        ...

<span style="color:#a6e22e">+   def move_towards(self, target_x, target_y, game_map, entities):
</span><span style="color:#a6e22e">+       dx = target_x - self.x
</span><span style="color:#a6e22e">+       dy = target_y - self.y
</span><span style="color:#a6e22e">+       distance = math.sqrt(dx ** 2 + dy ** 2)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       dx = int(round(dx / distance))
</span><span style="color:#a6e22e">+       dy = int(round(dy / distance))
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       if not (game_map.is_blocked(self.x + dx, self.y + dy) or
</span><span style="color:#a6e22e">+                   get_blocking_entities_at_location(entities, self.x + dx, self.y + dy)):
</span><span style="color:#a6e22e">+           self.move(dx, dy)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    def move(self, dx, dy):
        ...

    <span class="new-text">def move_towards(self, target_x, target_y, game_map, entities):
        dx = target_x - self.x
        dy = target_y - self.y
        distance = math.sqrt(dx ** 2 + dy ** 2)

        dx = int(round(dx / distance))
        dy = int(round(dy / distance))

        if not (game_map.is_blocked(self.x + dx, self.y + dy) or
                    get_blocking_entities_at_location(entities, self.x + dx, self.y + dy)):
            self.move(dx, dy)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>We&rsquo;ll also need a function to get the distance between the Entity and
its target.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def move_towards(self, target_x, target_y, game_map, entities):
        ...

<span style="color:#a6e22e">+   def distance_to(self, other):
</span><span style="color:#a6e22e">+       dx = other.x - self.x
</span><span style="color:#a6e22e">+       dy = other.y - self.y
</span><span style="color:#a6e22e">+       return math.sqrt(dx ** 2 + dy ** 2)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    def move_towards(self, target_x, target_y, game_map, entities):
        ...

    <span class="new-text">def distance_to(self, other):
        dx = other.x - self.x
        dy = other.y - self.y
        return math.sqrt(dx ** 2 + dy ** 2)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Both of these functions use the <code>math</code> module, so we&rsquo;ll need to import
that.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#a6e22e">+import math
</span><span style="color:#a6e22e"></span>

class Entity:
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="new-text">import math</span>


class Entity:
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now let&rsquo;s replace our placeholder <code>take_turn</code> function with one that
will actually move the Entity.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod


class BasicMonster:
<span style="color:#f92672">-   def take_turn(self):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def take_turn(self, target, fov_map, game_map, entities):
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-       print(&#39;The &#39; + self.owner.name + &#39; wonders when it will get to move.&#39;)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+       monster = self.owner
</span><span style="color:#a6e22e">+       if libtcod.map_is_in_fov(fov_map, monster.x, monster.y):
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           if monster.distance_to(target) &gt;= 2:
</span><span style="color:#a6e22e">+               monster.move_towards(target.x, target.y, game_map, entities)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           elif target.fighter.hp &gt; 0:
</span><span style="color:#a6e22e">+               print(&#39;The {0} insults you! Your ego is damaged!&#39;.format(monster.name))
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="new-text">import tcod as libtcod</span>


class BasicMonster:
    <span class="crossed-out-text">def take_turn(self):</span>
    <span class="new-text">def take_turn(self, target, fov_map, game_map, entities):</span>
        <span class="crossed-out-text">print('The ' + self.owner.name + ' wonders when it will get to move.')</span>
        <span class="new-text">monster = self.owner
        if libtcod.map_is_in_fov(fov_map, monster.x, monster.y):

            if monster.distance_to(target) >= 2:
                monster.move_towards(target.x, target.y, game_map, entities)

            elif target.fighter.hp > 0:
                print('The {0} insults you! Your ego is damaged!'.format(monster.name))</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>We&rsquo;ll also need to update the call to <code>take_turn</code> in <code>engine.py</code></p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-                   entity.ai.take_turn()
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   entity.ai.take_turn(player, fov_map, game_map, entities)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>                    <span class="crossed-out-text">entity.ai.take_turn()</span>
                    <span class="new-text">entity.ai.take_turn(player, fov_map, game_map, entities)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now our enemies will give chase, and, if they catch up, hurl insults at
our poor player!</p>
<p>If you run the project, you may notice something strange about our mean
spirited monsters: They can insult you from a diagonal position, but the
player and the monsters can only move in the cardinal directions (north,
east, south, west). If the enemies were actually attacking us right now,
they&rsquo;d have an unfair advantage. While this could make for interesting
gameplay, we&rsquo;ll fix that here to allow for 8 directional attacking and
movement for all Entities.</p>
<p>For the player, that&rsquo;s easy enough; we just need to update <code>handle_keys</code>
to allow us to move diagonally. Modify the movement part of that
function like so:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">def handle_keys(key):
<span style="color:#a6e22e">+   key_char = chr(key.c)
</span><span style="color:#a6e22e"></span>
<span style="color:#f92672">-   if key.vk == libtcod.KEY_UP:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   if key.vk == libtcod.KEY_UP or key_char == &#39;k&#39;:
</span><span style="color:#a6e22e"></span>        return {&#39;move&#39;: (0, -1)}
<span style="color:#f92672">-  elif key.vk == libtcod.KEY_DOWN:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   elif key.vk == libtcod.KEY_DOWN or key_char == &#39;j&#39;:
</span><span style="color:#a6e22e"></span>        return {&#39;move&#39;: (0, 1)}
<span style="color:#f92672">-   elif key.vk == libtcod.KEY_LEFT:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   elif key.vk == libtcod.KEY_LEFT or key_char == &#39;h&#39;:
</span><span style="color:#a6e22e"></span>        return {&#39;move&#39;: (-1, 0)}
<span style="color:#f92672">-   elif key.vk == libtcod.KEY_RIGHT:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   elif key.vk == libtcod.KEY_RIGHT or key_char == &#39;l&#39;:
</span><span style="color:#a6e22e"></span>        return {&#39;move&#39;: (1, 0)}
<span style="color:#a6e22e">+   elif key_char == &#39;y&#39;:
</span><span style="color:#a6e22e">+       return {&#39;move&#39;: (-1, -1)}
</span><span style="color:#a6e22e">+   elif key_char == &#39;u&#39;:
</span><span style="color:#a6e22e">+       return {&#39;move&#39;: (1, -1)}
</span><span style="color:#a6e22e">+   elif key_char == &#39;b&#39;:
</span><span style="color:#a6e22e">+       return {&#39;move&#39;: (-1, 1)}
</span><span style="color:#a6e22e">+   elif key_char == &#39;n&#39;:
</span><span style="color:#a6e22e">+       return {&#39;move&#39;: (1, 1)}
</span><span style="color:#a6e22e"></span>
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>def handle_keys(key):
    <span class="new-text">key_char = chr(key.c)</span>

    if key.vk == libtcod.KEY_UP<span class="new-text"> or key_char == 'k'</span>:
        return {'move': (0, -1)}
    elif key.vk == libtcod.KEY_DOWN<span class="new-text"> or key_char == 'j'</span>:
        return {'move': (0, 1)}
    elif key.vk == libtcod.KEY_LEFT<span class="new-text"> or key_char == 'h'</span>:
        return {'move': (-1, 0)}
    elif key.vk == libtcod.KEY_RIGHT<span class="new-text"> or key_char == 'l'</span>:
        return {'move': (1, 0)}
    <span class="new-text">elif key_char == 'y':
        return {'move': (-1, -1)}
    elif key_char == 'u':
        return {'move': (1, -1)}
    elif key_char == 'b':
        return {'move': (-1, 1)}
    elif key_char == 'n':
        return {'move': (1, 1)}</span>

    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>The first line is just getting the &lsquo;character&rsquo; that we pressed on the
keyboard. This will be handy in other spots as well, when we check for
inventory and pickup commands.</p>
<p>For diagonal movement, we&rsquo;ve implemented the &ldquo;vim keys&rdquo; for movement,
while also retaining the arrow keys for cardinal directions. Vim keys
allow you to move diagonally without the help of a numpad. A lot of
older roguelikes do 8 directions through the numpad, but personally, I
play all my roguelikes on a laptop, which doesn&rsquo;t have one, so the Vim
keys are useful.</p>
<p>Getting the enemies to move in eight directions is going to be a bit
more complicated. For that, we&rsquo;ll want to use a pathfinding algorithm
known as A-star. I&rsquo;m simply going to be copying the code from the
<a href="http://www.roguebasin.com/index.php?title=Complete_Roguelike_Tutorial,_using_Python%2Blibtcod,_extras#A.2A_Pathfinding">Roguebasin
extra</a>
for our purposes. I won&rsquo;t go into detail explaining how this works, but
if you want to know more about the details of the algorithm, <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">click
here</a>.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def move_towards(self, target_x, target_y, game_map, entities):
    ...

<span style="color:#a6e22e">+   def move_astar(self, target, entities, game_map):
</span><span style="color:#a6e22e">+       # Create a FOV map that has the dimensions of the map
</span><span style="color:#a6e22e">+       fov = libtcod.map_new(game_map.width, game_map.height)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       # Scan the current map each turn and set all the walls as unwalkable
</span><span style="color:#a6e22e">+       for y1 in range(game_map.height):
</span><span style="color:#a6e22e">+           for x1 in range(game_map.width):
</span><span style="color:#a6e22e">+               libtcod.map_set_properties(fov, x1, y1, not game_map.tiles[x1][y1].block_sight,
</span><span style="color:#a6e22e">+                                          not game_map.tiles[x1][y1].blocked)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       # Scan all the objects to see if there are objects that must be navigated around
</span><span style="color:#a6e22e">+       # Check also that the object isn&#39;t self or the target (so that the start and the end points are free)
</span><span style="color:#a6e22e">+       # The AI class handles the situation if self is next to the target so it will not use this A* function anyway
</span><span style="color:#a6e22e">+       for entity in entities:
</span><span style="color:#a6e22e">+           if entity.blocks and entity != self and entity != target:
</span><span style="color:#a6e22e">+               # Set the tile as a wall so it must be navigated around
</span><span style="color:#a6e22e">+               libtcod.map_set_properties(fov, entity.x, entity.y, True, False)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       # Allocate a A* path
</span><span style="color:#a6e22e">+       # The 1.41 is the normal diagonal cost of moving, it can be set as 0.0 if diagonal moves are prohibited
</span><span style="color:#a6e22e">+       my_path = libtcod.path_new_using_map(fov, 1.41)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       # Compute the path between self&#39;s coordinates and the target&#39;s coordinates
</span><span style="color:#a6e22e">+       libtcod.path_compute(my_path, self.x, self.y, target.x, target.y)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       # Check if the path exists, and in this case, also the path is shorter than 25 tiles
</span><span style="color:#a6e22e">+       # The path size matters if you want the monster to use alternative longer paths (for example through other rooms) if for example the player is in a corridor
</span><span style="color:#a6e22e">+       # It makes sense to keep path size relatively low to keep the monsters from running around the map if there&#39;s an alternative path really far away
</span><span style="color:#a6e22e">+       if not libtcod.path_is_empty(my_path) and libtcod.path_size(my_path) &lt; 25:
</span><span style="color:#a6e22e">+           # Find the next coordinates in the computed full path
</span><span style="color:#a6e22e">+           x, y = libtcod.path_walk(my_path, True)
</span><span style="color:#a6e22e">+           if x or y:
</span><span style="color:#a6e22e">+               # Set self&#39;s coordinates to the next path tile
</span><span style="color:#a6e22e">+               self.x = x
</span><span style="color:#a6e22e">+               self.y = y
</span><span style="color:#a6e22e">+       else:
</span><span style="color:#a6e22e">+           # Keep the old move function as a backup so that if there are no paths (for example another monster blocks a corridor)
</span><span style="color:#a6e22e">+           # it will still try to move towards the player (closer to the corridor opening)
</span><span style="color:#a6e22e">+           self.move_towards(target.x, target.y, game_map, entities)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           # Delete the path to free memory
</span><span style="color:#a6e22e">+       libtcod.path_delete(my_path)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    def move_towards(self, target_x, target_y, game_map, entities):
    ...

    <span class="new-text">def move_astar(self, target, entities, game_map):
        # Create a FOV map that has the dimensions of the map
        fov = libtcod.map_new(game_map.width, game_map.height)

        # Scan the current map each turn and set all the walls as unwalkable
        for y1 in range(game_map.height):
            for x1 in range(game_map.width):
                libtcod.map_set_properties(fov, x1, y1, not game_map.tiles[x1][y1].block_sight,
                                           not game_map.tiles[x1][y1].blocked)

        # Scan all the objects to see if there are objects that must be navigated around
        # Check also that the object isn't self or the target (so that the start and the end points are free)
        # The AI class handles the situation if self is next to the target so it will not use this A* function anyway
        for entity in entities:
            if entity.blocks and entity != self and entity != target:
                # Set the tile as a wall so it must be navigated around
                libtcod.map_set_properties(fov, entity.x, entity.y, True, False)

        # Allocate a A* path
        # The 1.41 is the normal diagonal cost of moving, it can be set as 0.0 if diagonal moves are prohibited
        my_path = libtcod.path_new_using_map(fov, 1.41)

        # Compute the path between self's coordinates and the target's coordinates
        libtcod.path_compute(my_path, self.x, self.y, target.x, target.y)

        # Check if the path exists, and in this case, also the path is shorter than 25 tiles
        # The path size matters if you want the monster to use alternative longer paths (for example through other rooms) if for example the player is in a corridor
        # It makes sense to keep path size relatively low to keep the monsters from running around the map if there's an alternative path really far away
        if not libtcod.path_is_empty(my_path) and libtcod.path_size(my_path) < 25:
            # Find the next coordinates in the computed full path
            x, y = libtcod.path_walk(my_path, True)
            if x or y:
                # Set self's coordinates to the next path tile
                self.x = x
                self.y = y
        else:
            # Keep the old move function as a backup so that if there are no paths (for example another monster blocks a corridor)
            # it will still try to move towards the player (closer to the corridor opening)
            self.move_towards(target.x, target.y, game_map, entities)

            # Delete the path to free memory
        libtcod.path_delete(my_path)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>For this to work, we&rsquo;ll need to import <code>libtcod</code> into <code>entity.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#a6e22e">+import tcod as libtcod
</span><span style="color:#a6e22e"></span>
import math
...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="new-text">import tcod as libtcod</span>

import math
...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Note that if for whatever reason the algorithm doesn&rsquo;t find a path, it
will revert back to our previous movement function, so we still need
that.</p>
<p>Modify the <code>take_turn</code> function in <code>BasicMonster</code> to take advantage of
this new function.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            if monster.distance_to(target) &gt;= 2:
<span style="color:#a6e22e">+               monster.move_astar(target, entities, game_map)
</span><span style="color:#a6e22e"></span><span style="color:#f92672">-               monster.move_towards(target.x, target.y, game_map, entities)
</span><span style="color:#f92672"></span>            ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            if monster.distance_to(target) >= 2:
                <span class="new-text">monster.move_astar(target, entities, game_map)</span>
                <span style="color: red; text-decoration: line-through;">monster.move_towards(target.x, target.y, game_map, entities)</span>
            ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now both the player and enemies can move in diagonals. With that taken
care of, it&rsquo;s time to implement an actual combat system. Let&rsquo;s start by
adding a method to <code>Fighter</code> that allows the entity to take damage.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class Fighter:
    def __init__(self, hp, defense, power):
        ...

<span style="color:#a6e22e">+   def take_damage(self, amount):
</span><span style="color:#a6e22e">+       self.hp -= amount
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class Fighter:
    def __init__(self, hp, defense, power):
        ...

    <span class="new-text">def take_damage(self, amount):
        self.hp -= amount</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Simple enough. Now for the attack function (also in <code>Fighter</code>):</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    ...

<span style="color:#a6e22e">+   def attack(self, target):
</span><span style="color:#a6e22e">+       damage = self.power - target.fighter.defense
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       if damage &gt; 0:
</span><span style="color:#a6e22e">+           target.fighter.take_damage(damage)
</span><span style="color:#a6e22e">+           print(&#39;{0} attacks {1} for {2} hit points.&#39;.format(self.owner.name.capitalize(), target.name, str(damage)))
</span><span style="color:#a6e22e">+       else:
</span><span style="color:#a6e22e">+           print(&#39;{0} attacks {1} but does no damage.&#39;.format(self.owner.name.capitalize(), target.name))
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    ...

    <span class="new-text">def attack(self, target):
        damage = self.power - target.fighter.defense

        if damage > 0:
            target.fighter.take_damage(damage)
            print('{0} attacks {1} for {2} hit points.'.format(self.owner.name.capitalize(), target.name, str(damage)))
        else:
            print('{0} attacks {1} but does no damage.'.format(self.owner.name.capitalize(), target.name))</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>There&rsquo;s nothing too complex about this system. We&rsquo;re taking the
attacker&rsquo;s power and subtracting the defender&rsquo;s defense, and getting our
damage dealt. If the damage is above zero, then the target takes damage.</p>
<p>We can finally replace our placeholders from earlier! Modify the
player&rsquo;s placeholder in <code>engine.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">                if target:
<span style="color:#f92672">-                   print(&#39;You kick the &#39; + target.name + &#39; in the shins, much to its annoyance!&#39;)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   player.fighter.attack(target)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>                if target:
                    <span class="crossed-out-text">print('You kick the ' + target.name + ' in the shins, much to its annoyance!')</span>
                    <span class="new-text">player.fighter.attack(target)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>&hellip; And for the enemy placeholder in <code>BasicMonster</code></p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            elif target.fighter.hp &gt; 0:
<span style="color:#f92672">-               print(&#39;The {0} insults you! Your ego is damaged!&#39;.format(monster.name))
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+               monster.fighter.attack(target)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            elif target.fighter.hp > 0:
                <span class="crossed-out-text">print('The {0} insults you! Your ego is damaged!'.format(monster.name))</span>
                <span class="new-text">monster.fighter.attack(target)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now we can attack enemies, and they can attack us!</p>
<p>As exciting as this all is, we have to take a step back for a moment and
think about a design question. Right now, we&rsquo;re printing our messages to
the console, but in the next chapter we&rsquo;ll move that to a more formal
message log. Also, later in this chapter, we need to alter the game
state when the player is killed in action. Do functions like <code>attack</code>
and <code>take_damage</code> really need to receive the message log or game state
as arguments? And should they be directly manipulating those things in
the first place?</p>
<p>There&rsquo;s a lot of different ways to handle this. For this tutorial, we&rsquo;ll
implement a <code>results</code> list for functions like this, which will be
returned to the <code>engine.py</code> file, and be handled there. We&rsquo;re already
doing something similar in <code>handle_keys</code>; that function just returns the
results of the key press, it doesn&rsquo;t actually <em>move</em> the player.</p>
<p>Let&rsquo;s modify the <code>take_damage</code> and <code>attack</code> functions to return an array
of results, rather than print anything.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    def take_damage(self, amount):
<span style="color:#a6e22e">+       results = []
</span><span style="color:#a6e22e"></span>
        self.hp -= amount

<span style="color:#a6e22e">+       if self.hp &lt;= 0:
</span><span style="color:#a6e22e">+           results.append({&#39;dead&#39;: self.owner})
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       return results
</span><span style="color:#a6e22e"></span>
    def attack(self, target):
<span style="color:#a6e22e">+       results = []
</span><span style="color:#a6e22e"></span>
        damage = self.power - target.fighter.defense

        if damage &gt; 0:
<span style="color:#f92672">-           target.fighter.take_damage(damage)
</span><span style="color:#f92672">-           print(&#39;{0} attacks {1} for {2} hit points.&#39;.format(self.owner.name.capitalize(), target.name, str(damage)))
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           results.append({&#39;message&#39;: &#39;{0} attacks {1} for {2} hit points.&#39;.format(
</span><span style="color:#a6e22e">+               self.owner.name.capitalize(), target.name, str(damage))})
</span><span style="color:#a6e22e">+           results.extend(target.fighter.take_damage(damage))
</span><span style="color:#a6e22e"></span>        else:
<span style="color:#f92672">-           print(&#39;{0} attacks {1} but does no damage.&#39;.format(self.owner.name.capitalize(), target.name))
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+           results.append({&#39;message&#39;: &#39;{0} attacks {1} but does no damage.&#39;.format(
</span><span style="color:#a6e22e">+               self.owner.name.capitalize(), target.name)})
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       return results
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>
    def take_damage(self, amount):
        <span class="new-text">results = []</span>

        self.hp -= amount

        <span class="new-text">if self.hp <= 0:
            results.append({'dead': self.owner})

        return results</span>

    def attack(self, target):
        <span class="new-text">results = []</span>

        damage = self.power - target.fighter.defense

        if damage > 0:
            <span style="color: red; text-decoration: line-through;">target.fighter.take_damage(damage)</span>
            <span style="color: red; text-decoration: line-through;">print('{0} attacks {1} for {2} hit points.'.format(self.owner.name.capitalize(), target.name, str(damage)))</span>
            <span class="new-text">results.append({'message': '{0} attacks {1} for {2} hit points.'.format(
                self.owner.name.capitalize(), target.name, str(damage))})
            results.extend(target.fighter.take_damage(damage))</span>
        else:
            <span style="color: red; text-decoration: line-through;">print('{0} attacks {1} but does no damage.'.format(self.owner.name.capitalize(), target.name))</span>
            <span class="new-text">results.append({'message': '{0} attacks {1} but does no damage.'.format(
                self.owner.name.capitalize(), target.name)})

        return results</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Let&rsquo;s break it down a little. In <code>take_damage</code>, we add a dictionary to
<code>results</code> if the entity happens to die after taking damage. The results
list is returned regardless (it may be empty).</p>
<p>In <code>attack</code>, we&rsquo;re again setting a list called <code>results</code>, and we add our
message to it regardless of damage was taken or not. Notice that in the
<code>if</code> block, we&rsquo;re using <code>extend</code> to add the results of <code>take_damage</code> to
our current <code>results</code> list.</p>
<p>The <code>extend</code> function is similar to <code>append</code>, but it keeps our list
flat, so we don&rsquo;t get something like <code>[{'message': 'something'}, [{'message': 'something else'}]]</code>. Instead, we would get: <code>[{'message': 'something'}, {'message': 'something else'}]</code>. That will make looping
through our results much simpler.</p>
<p>Let&rsquo;s extend this logic to the <code>take_turn</code> function in <code>BasicMonster</code>.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class BasicMonster:
    def take_turn(self, target, fov_map, game_map, entities):
<span style="color:#a6e22e">+       results = []
</span><span style="color:#a6e22e"></span>
        monster = self.owner
        if libtcod.map_is_in_fov(fov_map, monster.x, monster.y):

            if monster.distance_to(target) &gt;= 2:
                monster.move_astar(target, entities, game_map)

            elif target.fighter.hp &gt; 0:
<span style="color:#f92672">-               monster.fighter.attack(target)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+               attack_results = monster.fighter.attack(target)
</span><span style="color:#a6e22e">+               results.extend(attack_results)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+       return results
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class BasicMonster:
    def take_turn(self, target, fov_map, game_map, entities):
        <span class="new-text">results = []</span>

        monster = self.owner
        if libtcod.map_is_in_fov(fov_map, monster.x, monster.y):

            if monster.distance_to(target) >= 2:
                monster.move_astar(target, entities, game_map)

            elif target.fighter.hp > 0:
                <span class="crossed-out-text">monster.fighter.attack(target)</span>
                <span class="new-text">attack_results = monster.fighter.attack(target)
                results.extend(attack_results)

        return results</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>So what do we actually <em>do</em> with this <code>results</code> list? Lets modify
<code>engine.py</code> to react to the results of our attacks.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">        ...
        fullscreen = action.get(&#39;fullscreen&#39;)

<span style="color:#a6e22e">+       player_turn_results = []
</span><span style="color:#a6e22e"></span>
        if move and game_state == GameStates.PLAYERS_TURN:
            dx, dy = move
            destination_x = player.x + dx
            destination_y = player.y + dy

            if not game_map.is_blocked(destination_x, destination_y):
                target = get_blocking_entities_at_location(entities, destination_x, destination_y)

                if target:
<span style="color:#f92672">-                   player.fighter.attack(target)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   attack_results = player.fighter.attack(target)
</span><span style="color:#a6e22e">+                   player_turn_results.extend(attack_results)
</span><span style="color:#a6e22e"></span>                else:
                    player.move(dx, dy)

                    fov_recompute = True

                game_state = GameStates.ENEMY_TURN

        if exit:
            return True

        if fullscreen:
            libtcod.console_set_fullscreen(not libtcod.console_is_fullscreen())

<span style="color:#a6e22e">+       for player_turn_result in player_turn_results:
</span><span style="color:#a6e22e">+           message = player_turn_result.get(&#39;message&#39;)
</span><span style="color:#a6e22e">+           dead_entity = player_turn_result.get(&#39;dead&#39;)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           if message:
</span><span style="color:#a6e22e">+               print(message)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           if dead_entity:
</span><span style="color:#a6e22e">+               pass # We&#39;ll do something here momentarily
</span><span style="color:#a6e22e"></span>
        if game_state == GameStates.ENEMY_TURN:
            for entity in entities:
                if entity.ai:
<span style="color:#f92672">-                   entity.ai.take_turn(player, fov_map, game_map, entities)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   enemy_turn_results = entity.ai.take_turn(player, fov_map, game_map, entities)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                   for enemy_turn_result in enemy_turn_results:
</span><span style="color:#a6e22e">+                       message = enemy_turn_result.get(&#39;message&#39;)
</span><span style="color:#a6e22e">+                       dead_entity = enemy_turn_result.get(&#39;dead&#39;)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                       if message:
</span><span style="color:#a6e22e">+                           print(message)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                       if dead_entity:
</span><span style="color:#a6e22e">+                           pass
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+           else:
</span><span style="color:#a6e22e"></span>                game_state = GameStates.PLAYERS_TURN
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>        ...
        fullscreen = action.get('fullscreen')

        <span class="new-text">player_turn_results = []</span>

        if move and game_state == GameStates.PLAYERS_TURN:
            dx, dy = move
            destination_x = player.x + dx
            destination_y = player.y + dy

            if not game_map.is_blocked(destination_x, destination_y):
                target = get_blocking_entities_at_location(entities, destination_x, destination_y)

                if target:
                    <span style="color: red; text-decoration: line-through;">player.fighter.attack(target)</span>
                    <span class="new-text">attack_results = player.fighter.attack(target)
                    player_turn_results.extend(attack_results)</span>
                else:
                    player.move(dx, dy)

                    fov_recompute = True

                game_state = GameStates.ENEMY_TURN

        if exit:
            return True

        if fullscreen:
            libtcod.console_set_fullscreen(not libtcod.console_is_fullscreen())

        <span class="new-text">for player_turn_result in player_turn_results:
            message = player_turn_result.get('message')
            dead_entity = player_turn_result.get('dead')

            if message:
                print(message)

            if dead_entity:
                pass # We'll do something here momentarily</span>

        if game_state == GameStates.ENEMY_TURN:
            for entity in entities:
                if entity.ai:
                    <span class="crossed-out-text">entity.ai.take_turn(player, fov_map, game_map, entities)</span>
                    <span class="new-text">enemy_turn_results = entity.ai.take_turn(player, fov_map, game_map, entities)

                    for enemy_turn_result in enemy_turn_results:
                        message = enemy_turn_result.get('message')
                        dead_entity = enemy_turn_result.get('dead')

                        if message:
                            print(message)

                        if dead_entity:
                            pass

            else:</span>
                <span style="color: blue">game_state = GameStates.PLAYERS_TURN</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p><em>* Note: There&rsquo;s that for-else statement again. There&rsquo;s no <code>break</code>
statement yet, so the &lsquo;else&rsquo; will always happen, but we&rsquo;ll add it in
just a minute.</em></p>
<p>Not that much has changed yet, but now we&rsquo;ve set ourselves up to handle
the death of the player and the other entities. Let&rsquo;s implement that
now. Create a new python file called <code>death_functions.py</code> and put the
following two functions in it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#f92672">import</span> tcod <span style="color:#66d9ef">as</span> libtcod

<span style="color:#f92672">from</span> game_states <span style="color:#f92672">import</span> GameStates


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kill_player</span>(player):
    player<span style="color:#f92672">.</span>char <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;%&#39;</span>
    player<span style="color:#f92672">.</span>color <span style="color:#f92672">=</span> libtcod<span style="color:#f92672">.</span>dark_red

    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;You died!&#39;</span>, GameStates<span style="color:#f92672">.</span>PLAYER_DEAD


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kill_monster</span>(monster):
    death_message <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{0}</span><span style="color:#e6db74"> is dead!&#39;</span><span style="color:#f92672">.</span>format(monster<span style="color:#f92672">.</span>name<span style="color:#f92672">.</span>capitalize())

    monster<span style="color:#f92672">.</span>char <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;%&#39;</span>
    monster<span style="color:#f92672">.</span>color <span style="color:#f92672">=</span> libtcod<span style="color:#f92672">.</span>dark_red
    monster<span style="color:#f92672">.</span>blocks <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
    monster<span style="color:#f92672">.</span>fighter <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
    monster<span style="color:#f92672">.</span>ai <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
    monster<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;remains of &#39;</span> <span style="color:#f92672">+</span> monster<span style="color:#f92672">.</span>name

    <span style="color:#66d9ef">return</span> death_message</code></pre></div>
<p>These two functions will handle the death of the player and monsters.
They&rsquo;re different because obviously the death of a monster isn&rsquo;t <em>that</em>
big a deal (we&rsquo;ll be killing quite a few of them), but the death of the
player is a <em>very</em> big deal (this is a roguelike after all!).</p>
<p>Modify <code>engine.py</code> to use these two functions. Replace the <code>pass</code>
section like this:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">            ...
            if dead_entity:
<span style="color:#f92672">-               pass
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+               if dead_entity == player:
</span><span style="color:#a6e22e">+                   message, game_state = kill_player(dead_entity)
</span><span style="color:#a6e22e">+               else:
</span><span style="color:#a6e22e">+                   message = kill_monster(dead_entity)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+               print(message)
</span><span style="color:#a6e22e"></span>
        if game_state == GameStates.ENEMY_TURN:
            for entity in entities:
                if entity.ai:
                    enemy_turn_results = entity.ai.take_turn(player, fov_map, game_map, entities)

                    for enemy_turn_result in enemy_turn_results:
                        message = enemy_turn_result.get(&#39;message&#39;)
                        dead_entity = enemy_turn_result.get(&#39;dead&#39;)

                        if message:
                            print(message)

                        if dead_entity:
<span style="color:#f92672">-                           pass
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                           if dead_entity == player:
</span><span style="color:#a6e22e">+                               message, game_state = kill_player(dead_entity)
</span><span style="color:#a6e22e">+                           else:
</span><span style="color:#a6e22e">+                               message = kill_monster(dead_entity)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                           print(message)
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                           if game_state == GameStates.PLAYER_DEAD:
</span><span style="color:#a6e22e">+                               break
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+                   if game_state == GameStates.PLAYER_DEAD:
</span><span style="color:#a6e22e">+                       break
</span><span style="color:#a6e22e"></span>            else:
                game_state = GameStates.PLAYERS_TURN
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>            ...
            if dead_entity:
                <span style="color: red; text-decoration: line-through;">pass</span>
                <span class="new-text">if dead_entity == player:
                    message, game_state = kill_player(dead_entity)
                else:
                    message = kill_monster(dead_entity)

                print(message)</span>

        if game_state == GameStates.ENEMY_TURN:
            for entity in entities:
                if entity.ai:
                    enemy_turn_results = entity.ai.take_turn(player, fov_map, game_map, entities)

                    for enemy_turn_result in enemy_turn_results:
                        message = enemy_turn_result.get('message')
                        dead_entity = enemy_turn_result.get('dead')

                        if message:
                            print(message)

                        if dead_entity:
                            <span style="color: red; text-decoration: line-through;">pass</span>
                            <span class="new-text">if dead_entity == player:
                                message, game_state = kill_player(dead_entity)
                            else:
                                message = kill_monster(dead_entity)

                            print(message)

                            if game_state == GameStates.PLAYER_DEAD:
                                break

                    if game_state == GameStates.PLAYER_DEAD:
                        break</span>
            else:
                game_state = GameStates.PLAYERS_TURN</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p><em>*Note: There&rsquo;s the break statements that will skip over the &lsquo;else&rsquo; in
our &lsquo;for-else&rsquo;. Why do this? Because if the player is dead, we don&rsquo;t
want to set the game state back to the player&rsquo;s turn when all the
enemies are done moving. That, and there&rsquo;s no reason to continue with
the loop; the game is over.</em></p>
<p>Remember to import the killing functions at the top of <code>engine.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">...
from components.fighter import Fighter
<span style="color:#a6e22e">+from death_functions import kill_monster, kill_player
</span><span style="color:#a6e22e"></span>from entity import Entity, get_blocking_entities_at_location
...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>...
from components.fighter import Fighter
<span class="new-text">from death_functions import kill_monster, kill_player</span>
from entity import Entity, get_blocking_entities_at_location
...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Also, we need to add the <code>PLAYER_DEAD</code> value to <code>GameStates</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">class GameStates(Enum):
    PLAYERS_TURN = 1
    ENEMY_TURN = 2
<span style="color:#a6e22e">+   PLAYER_DEAD = 3
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>class GameStates(Enum):
    PLAYERS_TURN = 1
    ENEMY_TURN = 2
    <span class="new-text">PLAYER_DEAD = 3</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Run the project now. Entities will now drop dead when hitting 0 HP,
including the player! When the player dies, you won&rsquo;t be able to move,
but you can still exit the game. At long last, we have a real combat
system in place!</p>
<p>It&rsquo;s been a long chapter already, but let&rsquo;s clean things up just a
little bit. Right now, we&rsquo;re clueless as to how much HP the player has
remaining before death. Rather than having the user keep track of the
math in their head, we can add a little health bar by putting the
following code at the end of <code>render_all</code>, right before the blit
statement (note that the player needs to be passed to <code>render_all</code>
now).</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-def render_all(con, entities, game_map, fov_map, fov_recompute, screen_width, screen_height, colors):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+def render_all(con, entities, player, game_map, fov_map, fov_recompute, screen_width, screen_height, colors):
</span><span style="color:#a6e22e"></span>    ...
    for entity in entities:
        draw_entity(con, entity, fov_map)

<span style="color:#a6e22e">+   libtcod.console_set_default_foreground(con, libtcod.white)
</span><span style="color:#a6e22e">+   libtcod.console_print_ex(con, 1, screen_height - 2, libtcod.BKGND_NONE, libtcod.LEFT,
</span><span style="color:#a6e22e">+                        &#39;HP: {0:02}/{1:02}&#39;.format(player.fighter.hp, player.fighter.max_hp))
</span><span style="color:#a6e22e"></span>
    libtcod.console_blit(con, 0, 0, screen_width, screen_height, 0, 0, 0)
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="crossed-out-text">def render_all(con, entities, game_map, fov_map, fov_recompute, screen_width, screen_height, colors):</span>
<span class="new-text">def render_all(con, entities, player, game_map, fov_map, fov_recompute, screen_width, screen_height, colors):</span>
    ...
    for entity in entities:
        draw_entity(con, entity, fov_map)

    <span class="new-text">libtcod.console_set_default_foreground(con, libtcod.white)
    libtcod.console_print_ex(con, 1, screen_height - 2, libtcod.BKGND_NONE, libtcod.LEFT,
                         'HP: {0:02}/{1:02}'.format(player.fighter.hp, player.fighter.max_hp))</span>

    libtcod.console_blit(con, 0, 0, screen_width, screen_height, 0, 0, 0)</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Update the call to <code>render_all</code> in
<code>engine.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-render_all(con, entities, game_map, fov_map, fov_recompute, screen_width, screen_height, colors)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+render_all(con, entities, player, game_map, fov_map, fov_recompute, screen_width, screen_height, colors)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre><span class="crossed-out-text">render_all(con, entities, game_map, fov_map, fov_recompute, screen_width, screen_height, colors)</span>
<span class="new-text">render_all(con, entities, player, game_map, fov_map, fov_recompute, screen_width, screen_height, colors)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>One thing you probably noticed by now is that the enemy corpses will
&ldquo;cover up&rdquo; the player if we move onto them. This obviously isn&rsquo;t
desired; acting entities should always appear above corpses, items, and
other things in the dungeon. To solve this, let&rsquo;s add an Enum to the
Entities, that describes the render order in which they should be drawn.
Lower priority items will be drawn first, to ensure they never appear
above the Entities.</p>
<p>Add the following to <code>render_functions.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod

<span style="color:#a6e22e">+from enum import Enum
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+
</span><span style="color:#a6e22e">+class RenderOrder(Enum):
</span><span style="color:#a6e22e">+   CORPSE = 1
</span><span style="color:#a6e22e">+   ITEM = 2
</span><span style="color:#a6e22e">+   ACTOR = 3
</span><span style="color:#a6e22e"></span>

def render_all(con, entities, player, game_map, fov_map, fov_recompute, screen_width, screen_height, colors):
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod

<span class="new-text">from enum import Enum


class RenderOrder(Enum):
    CORPSE = 1
    ITEM = 2
    ACTOR = 3</span>


def render_all(con, entities, player, game_map, fov_map, fov_recompute, screen_width, screen_height, colors):
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now modify the <code>__init__</code> function in <code>Entity</code> to take this into
account.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">import tcod as libtcod
import math

<span style="color:#a6e22e">+from render_functions import RenderOrder
</span><span style="color:#a6e22e"></span>

class Entity:
    &#34;&#34;&#34;
    A generic object to represent players, enemies, items, etc.
    &#34;&#34;&#34;
<span style="color:#f92672">-   def __init__(self, x, y, char, color, name, blocks=False, fighter=None, ai=None):
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   def __init__(self, x, y, char, color, name, blocks=False, render_order=RenderOrder.CORPSE, fighter=None, ai=None):
</span><span style="color:#a6e22e"></span>        self.x = x
        self.y = y
        self.char = char
        self.color = color
        self.name = name
        self.blocks = blocks
<span style="color:#a6e22e">+       self.render_order = render_order
</span><span style="color:#a6e22e"></span>        self.fighter = fighter
        ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>import tcod as libtcod
import math

<span class="new-text">from render_functions import RenderOrder</span>


class Entity:
    """
    A generic object to represent players, enemies, items, etc.
    """
    def __init__(self, x, y, char, color, name, blocks=False, <span class="new-text">render_order=RenderOrder.CORPSE,</span> fighter=None, ai=None):
        self.x = x
        self.y = y
        self.char = char
        self.color = color
        self.name = name
        self.blocks = blocks
        <span class="new-text">self.render_order = render_order</span>
        self.fighter = fighter
        ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now modify our Entity initializations, starting with
<code>engine.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-player = Entity(0, 0, &#39;@&#39;, libtcod.white, &#39;Player&#39;, blocks=True, fighter=fighter_component)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+player = Entity(0, 0, &#39;@&#39;, libtcod.white, &#39;Player&#39;, blocks=True, render_order=RenderOrder.ACTOR, fighter=fighter_component)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>player = Entity(0, 0, '@', libtcod.white, 'Player', blocks=True, <span class="new-text">render_order=RenderOrder.ACTOR,</span> fighter=fighter_component)</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>&hellip; And don&rsquo;t leave out the import:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="color:#f92672">-from render_functions import clear_all, render_all
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+from render_functions import clear_all, render_all, RenderOrder
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>from render_functions import clear_all, render_all<span class="new-text">, RenderOrder</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now for the monsters, in <code>game_map.py</code>:</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">                if randint(0, 100) &lt; 80:
                    fighter_component = Fighter(hp=10, defense=0, power=3)
                    ai_component = BasicMonster()

<span style="color:#f92672">-                   monster = Entity(x, y, &#39;o&#39;, libtcod.desaturated_green, &#39;Orc&#39;, blocks=True,
</span><span style="color:#f92672">-                                    fighter=fighter_component, ai=ai_component)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   monster = Entity(x, y, &#39;o&#39;, libtcod.desaturated_green, &#39;Orc&#39;, blocks=True,
</span><span style="color:#a6e22e">+                                    render_order=RenderOrder.ACTOR, fighter=fighter_component, ai=ai_component)
</span><span style="color:#a6e22e"></span>                else:
                    fighter_component = Fighter(hp=16, defense=1, power=4)
                    ai_component = BasicMonster()

<span style="color:#f92672">-                   monster = Entity(x, y, &#39;T&#39;, libtcod.darker_green, &#39;Troll&#39;, blocks=True, fighter=fighter_component,
</span><span style="color:#f92672">-                                    ai=ai_component)
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+                   monster = Entity(x, y, &#39;T&#39;, libtcod.darker_green, &#39;Troll&#39;, blocks=True, fighter=fighter_component,
</span><span style="color:#a6e22e">+                                    render_order=RenderOrder.ACTOR, ai=ai_component)
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>                if randint(0, 100) < 80:
                    fighter_component = Fighter(hp=10, defense=0, power=3)
                    ai_component = BasicMonster()

                    <span class="crossed-out-text">monster = Entity(x, y, 'o', libtcod.desaturated_green, 'Orc', blocks=True,</span>
                                     <span class="crossed-out-text">fighter=fighter_component, ai=ai_component)</span>
                    <span class="new-text">monster = Entity(x, y, 'o', libtcod.desaturated_green, 'Orc', blocks=True,
                                     render_order=RenderOrder.ACTOR, fighter=fighter_component, ai=ai_component)</span>
                else:
                    fighter_component = Fighter(hp=16, defense=1, power=4)
                    ai_component = BasicMonster()

                    <span class="crossed-out-text">monster = Entity(x, y, 'T', libtcod.darker_green, 'Troll', blocks=True, fighter=fighter_component,</span>
                                     <span class="crossed-out-text">ai=ai_component)</span>
                    <span class="new-text">monster = Entity(x, y, 'T', libtcod.darker_green, 'Troll', blocks=True, fighter=fighter_component,
                                     render_order=RenderOrder.ACTOR, ai=ai_component)</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>&hellip; And the import:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#f92672">from</span> render_functions <span style="color:#f92672">import</span> RenderOrder</code></pre></div>
<p>We&rsquo;ll also need to change the Entity&rsquo;s <code>render_order</code> when they die.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    monster.ai = None
    monster.name = &#39;remains of &#39; + monster.name
<span style="color:#a6e22e">+   monster.render_order = RenderOrder.CORPSE
</span></code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
    <pre>    monster.ai = None
    monster.name = 'remains of ' + monster.name
    <span class="new-text">monster.render_order = RenderOrder.CORPSE</span></pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>And, you guessed it, make sure you import:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py3" data-lang="py3"><span style="color:#f92672">from</span> render_functions <span style="color:#f92672">import</span> RenderOrder</code></pre></div>
<p><em>* Note: We&rsquo;re not changing the <code>render_order</code> on the player when it
dies; we actually <strong>want</strong> that corpse on top so we&rsquo;ll see it. It&rsquo;s more
dramatic that way!</em></p>
<p>Now let&rsquo;s implement the part in <code>render_all</code> that will actually take
this new variable into account.</p>
<div>
  <button class="btn btn-primary data-toggle-tab active" data-toggle-tab="diff">
    Diff
  </button>
  <button class="btn btn-secondary data-toggle-tab" data-toggle-tab="original">
    Original
  </button>

   <div class="data-pane active" data-pane="diff">
   <div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff">    if fov_recompute:
        ...

<span style="color:#a6e22e">+   entities_in_render_order = sorted(entities, key=lambda x: x.render_order.value)
</span><span style="color:#a6e22e"></span>
<span style="color:#f92672">-   for entity in entities:
</span><span style="color:#f92672"></span><span style="color:#a6e22e">+   for entity in entities_in_render_order:
</span><span style="color:#a6e22e"></span>        draw_entity(con, entity, fov_map)
    ...
</code></pre></div>

</div>
<div class="data-pane" data-pane="original">
  
<pre>    if fov_recompute:
        ...

    <span class="new-text">entities_in_render_order = sorted(entities, key=lambda x: x.render_order.value)</span>

    <span class="crossed-out-text">for entity in entities:</span>
    <span class="new-text">for entity in entities_in_render_order:</span>
        draw_entity(con, entity, fov_map)
    ...</pre>

</div>

</div>

<script src="/js/codetabs.js"></script>
<p>Now the corpses will be drawn first, then the items (when we put them
in), then the entities. This ensures we will see what&rsquo;s most important
first.</p>
<p>And we&rsquo;re done! That was quite the chapter, but you survived! Run the
project and see how long you can last in the now-deadly Dungeons of
Doom! With an actual combat system, we&rsquo;ve taken a pretty massive step
towards having a real roguelike game on our hands.</p>
<p>If you want to see the code so far in its entirety, <a href="https://github.com/TStand90/roguelike_tutorial_revised/tree/part6">click
here</a>.</p>
<p><a href="/tutorials/tcod/2019/part-7">Click here to move on to the next part of this
tutorial.</a></p>
<!-- raw HTML omitted -->


    

    


</article>



        </div>

        <aside class="col-12 col-lg-3 ml-auto blog-sidebar">
    
    
        <section>
    
        
    
        
    
</section>
    
</aside>

      </div>
    </div>
    

    
      







<footer class="blog-footer w-100">
    <nav class="navbar navbar-light bg-light">
        <p class="w-100 text-center">Last updated July 7th, 2020</p>
        <p class="w-100 text-center"><a href="#">Back to top</a></p>
    </nav>
</footer>

    

    
    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
  </body>
</html>
